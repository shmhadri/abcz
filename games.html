<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>Ù…Ù†ØµØ© Ø£Ù„Ø¹Ø§Ø¨ Ø§Ù„Ø­Ø±ÙˆÙ Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© - Phonics Game Lab</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© ØªØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡ÙŠ */
        :root {
            --primary: #4361ee;
            --primary-light: #4895ef;
            --primary-dark: #3a0ca3;
            --secondary: #f72585;
            --accent: #4cc9f0;
            --success: #4ade80;
            --warning: #f59e0b;
            --error: #ef4444;
            --background: #ffffff;
            --surface: #ffffff;
            --surface-light: #f8fafc;
            --text: #1e293b;
            --text-secondary: #475569;
            --border: #e2e8f0;
            --radius-lg: 20px;
            --radius-md: 12px;
            --radius-sm: 8px;
            --shadow: 0 10px 25px rgba(0, 0, 0, 0.08);
            --shadow-light: 0 5px 15px rgba(0, 0, 0, 0.05);
            --gradient-primary: linear-gradient(135deg, var(--primary), var(--primary-light));
            --gradient-accent: linear-gradient(135deg, var(--accent), var(--primary-light));
            --gradient-success: linear-gradient(135deg, var(--success), #22c55e);
            --gradient-surface: linear-gradient(135deg, #ffffff, #f8fafc);
            
            --night-bg: #0f172a;
            --night-surface: #1e293b;
            --night-text: #f1f5f9;
            --night-text-secondary: #cbd5e1;
            --night-border: #475569;
            --night-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }

        /* Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© ØªØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡ÙŠ */
        .night-mode {
            --background: var(--night-bg);
            --surface: var(--night-surface);
            --surface-light: #334155;
            --text: var(--night-text);
            --text-secondary: var(--night-text-secondary);
            --border: var(--night-border);
            --shadow: var(--night-shadow);
            --shadow-light: 0 5px 15px rgba(0, 0, 0, 0.2);
            --gradient-surface: linear-gradient(135deg, var(--surface), #1e293b);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            touch-action: manipulation;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* ... Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© ØªØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡ÙŠ ... */

        /* ØªØ­Ø³ÙŠÙ†Ø§Øª Ù„Ù„Ø£Ù„Ø¹Ø§Ø¨ */
        .game-area {
            position: relative;
            overflow: hidden;
        }

        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 100;
            font-size: 24px;
            font-weight: bold;
        }

        .power-up {
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
        }

        .explosion {
            position: absolute;
            width: 100px;
            height: 100px;
            pointer-events: none;
            z-index: 50;
        }

        .particle {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: particle-explode 1s ease-out forwards;
        }

        @keyframes particle-explode {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--tx, 0), var(--ty, 0)) scale(0);
                opacity: 0;
            }
        }

        .game-object {
            transition: transform 0.2s ease;
        }

        .game-object:hover {
            transform: scale(1.1);
        }

        /* ØªØ­Ø³ÙŠÙ†Ø§Øª Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„ØµÙŠØ¯ */
        .fishing-game .hook {
            transition: transform 0.1s ease;
        }

        .fishing-game .fish {
            animation: swim 3s ease-in-out infinite;
        }

        @keyframes swim {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-5px) rotate(5deg); }
        }

        /* ØªØ­Ø³ÙŠÙ†Ø§Øª Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¨Ø§Ù„ÙˆÙ†Ø§Øª */
        .balloon {
            animation: float-balloon 5s ease-in-out infinite;
        }

        @keyframes float-balloon {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-10px) rotate(5deg); }
        }

        /* ØªØ­Ø³ÙŠÙ†Ø§Øª Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ø°Ø§ÙƒØ±Ø© */
        .memory-card {
            transform-style: preserve-3d;
            transition: transform 0.6s;
        }

        .memory-card.flipped {
            transform: rotateY(180deg);
        }

        .memory-card .front,
        .memory-card .back {
            position: absolute;
            backface-visibility: hidden;
        }

        .memory-card .back {
            transform: rotateY(180deg);
        }

        /* ØªØ£Ø«ÙŠØ±Ø§Øª Ø§Ù„ÙÙˆØ² Ø§Ù„Ù…Ø­Ø³Ù†Ø© */
        .win-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .firework {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: firework-explode 1.5s ease-out forwards;
        }

        @keyframes firework-explode {
            0% {
                transform: translateY(100vh) scale(0);
                opacity: 0;
            }
            50% {
                transform: translateY(var(--y)) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(var(--y)) scale(0);
                opacity: 0;
            }
        }

        .sparkle {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            animation: sparkle 1s ease-in-out infinite;
        }

        @keyframes sparkle {
            0%, 100% { opacity: 0.3; transform: scale(0.5); }
            50% { opacity: 1; transform: scale(1); }
        }

        /* Ø´Ø±ÙŠØ· Ø§Ù„ØªÙ‚Ø¯Ù… ÙÙŠ Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨ */
        .game-progress {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
        }

        .game-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #22c55e);
            border-radius: 5px;
            transition: width 0.3s ease;
        }

        /* Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø© */
        .game-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            z-index: 10;
        }

        .combo-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(247, 37, 133, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            z-index: 10;
            animation: pulse 1s infinite;
        }
    </style>
</head>
<body>
    <!-- Ø§Ù„Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ ÙŠØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡Ùˆ -->
    <div class="app-container">
        <!-- ... Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ù‡ÙŠÙƒÙ„ ... -->
    </div>

    <script>
        // Ù†Ø¸Ø§Ù… Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨ Ø§Ù„Ù…Ø­Ø³Ù† ÙˆØ§Ù„Ù…Ø·ÙˆØ±
        class EnhancedGameSystem {
            constructor(gameManager) {
                this.gameManager = gameManager;
                this.effects = [];
                this.powerUps = [];
                this.combo = 0;
                this.comboTimer = null;
                this.gameDifficulty = 1;
            }

            // ØªØ­Ø³ÙŠÙ† Ù„Ø¹Ø¨Ø© Ø³Ø¨Ø§Ù‚ Ø§Ù„Ø³ÙŠØ§Ø±Ø§Øª
            initEnhancedCarRace(ctx, canvas) {
                const currentLetter = this.gameManager.currentLetter;
                const letterData = this.gameManager.letterData;
                
                // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ù…Ø­Ø³Ù†Ø©
                const gameSettings = {
                    carSpeed: 6,
                    obstacleSpeed: 3,
                    roadSpeed: 2,
                    laneCount: 3,
                    laneWidth: canvas.width / 3,
                    gameTime: 60,
                    targetScore: 50,
                    powerUpChance: 0.1,
                    difficultyFactor: this.gameDifficulty
                };

                // ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ù…Ø±ÙƒØ¨Ø©
                const car = {
                    x: canvas.width / 2 - 25,
                    y: canvas.height - 100,
                    width: 60,
                    height: 100,
                    speed: gameSettings.carSpeed,
                    lane: 1,
                    color: '#4361ee',
                    nitro: false,
                    nitroTime: 0,
                    shield: false,
                    shieldTime: 0,
                    score: 0,
                    lives: 3,
                    
                    draw: function(ctx) {
                        // Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø³ÙŠØ§Ø±Ø©
                        ctx.save();
                        
                        // ØªØ£Ø«ÙŠØ± Ø§Ù„Ù†ÙŠØªØ±Ùˆ
                        if (this.nitro) {
                            const gradient = ctx.createLinearGradient(
                                this.x, this.y + this.height,
                                this.x, this.y + this.height + 50
                            );
                            gradient.addColorStop(0, '#4cc9f0');
                            gradient.addColorStop(1, 'transparent');
                            ctx.fillStyle = gradient;
                            ctx.fillRect(this.x + 10, this.y + this.height, 40, 50);
                        }
                        
                        // Ø§Ù„Ø¯Ø±Ø¹
                        if (this.shield) {
                            ctx.strokeStyle = '#4cc9f0';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.arc(
                                this.x + this.width/2,
                                this.y + this.height/2,
                                this.width/2 + 10,
                                0,
                                Math.PI * 2
                            );
                            ctx.stroke();
                        }
                        
                        // Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø³ÙŠØ§Ø±Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
                        ctx.fillStyle = this.color;
                        ctx.fillRect(this.x, this.y, this.width, this.height);
                        
                        // Ø§Ù„Ù†ÙˆØ§ÙØ°
                        ctx.fillStyle = '#4cc9f0';
                        ctx.fillRect(this.x + 5, this.y + 10, 20, 25);
                        ctx.fillRect(this.x + 35, this.y + 10, 20, 25);
                        
                        // Ø§Ù„Ø¹Ø¬Ù„Ø§Øª
                        ctx.fillStyle = '#1e293b';
                        ctx.fillRect(this.x - 5, this.y + 70, 10, 25);
                        ctx.fillRect(this.x + this.width - 5, this.y + 70, 10, 25);
                        
                        ctx.restore();
                    },
                    
                    moveLeft: function() {
                        if (this.lane > 0) {
                            this.lane--;
                            this.x = this.lane * gameSettings.laneWidth + (gameSettings.laneWidth - this.width) / 2;
                        }
                    },
                    
                    moveRight: function() {
                        if (this.lane < gameSettings.laneCount - 1) {
                            this.lane++;
                            this.x = this.lane * gameSettings.laneWidth + (gameSettings.laneWidth - this.width) / 2;
                        }
                    },
                    
                    update: function(deltaTime) {
                        if (this.nitro) {
                            this.nitroTime -= deltaTime;
                            if (this.nitroTime <= 0) {
                                this.nitro = false;
                            }
                        }
                        
                        if (this.shield) {
                            this.shieldTime -= deltaTime;
                            if (this.shieldTime <= 0) {
                                this.shield = false;
                            }
                        }
                    },
                    
                    activateNitro: function() {
                        this.nitro = true;
                        this.nitroTime = 5000; // 5 Ø«ÙˆØ§Ù†ÙŠ
                        this.speed = gameSettings.carSpeed * 2;
                    },
                    
                    activateShield: function() {
                        this.shield = true;
                        this.shieldTime = 10000; // 10 Ø«ÙˆØ§Ù†ÙŠ
                    }
                };

                // ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø¹Ù‚Ø¨Ø§Øª
                class Obstacle {
                    constructor() {
                        this.lane = Math.floor(Math.random() * gameSettings.laneCount);
                        this.x = this.lane * gameSettings.laneWidth + (gameSettings.laneWidth - 40) / 2;
                        this.y = -100;
                        this.width = 40;
                        this.height = 60;
                        this.speed = gameSettings.obstacleSpeed + Math.random() * 2;
                        this.type = Math.random() < 0.7 ? 'letter' : 'powerup';
                        
                        if (this.type === 'letter') {
                            this.isCorrect = Math.random() > 0.5;
                            this.letter = this.isCorrect ? currentLetter : 
                                         this.getRandomDifferentLetter(currentLetter);
                            this.color = this.isCorrect ? '#4ade80' : '#ef4444';
                        } else {
                            this.powerUpType = Math.random() < 0.5 ? 'nitro' : 'shield';
                            this.color = this.powerUpType === 'nitro' ? '#f59e0b' : '#4cc9f0';
                        }
                    }
                    
                    getRandomDifferentLetter(currentLetter) {
                        const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                        const differentLetters = letters.filter(l => l !== currentLetter);
                        return differentLetters[Math.floor(Math.random() * differentLetters.length)];
                    }
                    
                    draw(ctx) {
                        ctx.save();
                        
                        if (this.type === 'letter') {
                            // Ø±Ø³Ù… Ø§Ù„Ø¹Ù‚Ø¨Ø©
                            ctx.fillStyle = this.color;
                            ctx.fillRect(this.x, this.y, this.width, this.height);
                            
                            // Ø§Ù„Ø­Ø±Ù
                            ctx.fillStyle = 'white';
                            ctx.font = 'bold 24px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(this.letter, this.x + this.width/2, this.y + this.height/2);
                            
                            // ØªØ£Ø«ÙŠØ± Ù„Ù„Ø¹Ù‚Ø¨Ø§Øª Ø§Ù„ØµØ­ÙŠØ­Ø©
                            if (this.isCorrect) {
                                ctx.strokeStyle = '#ffffff';
                                ctx.lineWidth = 2;
                                ctx.strokeRect(this.x - 2, this.y - 2, this.width + 4, this.height + 4);
                            }
                        } else {
                            // Ø±Ø³Ù… Ø§Ù„Ø¨Ø§ÙˆØ± Ø£Ø¨
                            ctx.fillStyle = this.color;
                            ctx.beginPath();
                            ctx.arc(
                                this.x + this.width/2,
                                this.y + this.height/2,
                                this.width/2,
                                0,
                                Math.PI * 2
                            );
                            ctx.fill();
                            
                            // Ø±Ù…Ø² Ø§Ù„Ø¨Ø§ÙˆØ± Ø£Ø¨
                            ctx.fillStyle = 'white';
                            ctx.font = 'bold 20px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(
                                this.powerUpType === 'nitro' ? 'âš¡' : 'ğŸ›¡ï¸',
                                this.x + this.width/2,
                                this.y + this.height/2
                            );
                        }
                        
                        ctx.restore();
                    }
                    
                    update(deltaTime) {
                        this.y += this.speed * (car.nitro ? 1.5 : 1);
                        return this.y > canvas.height;
                    }
                    
                    checkCollision(car) {
                        return (
                            this.x < car.x + car.width &&
                            this.x + this.width > car.x &&
                            this.y < car.y + car.height &&
                            this.y + this.height > car.y
                        );
                    }
                }

                // Ø®Ø·ÙˆØ· Ø§Ù„Ø·Ø±ÙŠÙ‚ Ø§Ù„Ù…ØªØ­Ø±ÙƒØ©
                const roadLines = [];
                for (let i = 0; i < 10; i++) {
                    roadLines.push({
                        x: canvas.width / 2 - 2,
                        y: i * 80,
                        width: 4,
                        height: 40
                    });
                }

                // Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„Ù„Ø¹Ø¨Ø©
                const obstacles = [];
                let score = 0;
                let gameOver = false;
                let lastObstacleTime = 0;
                let lastRoadUpdate = 0;
                
                // Ø¯ÙˆØ±Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ù…Ø­Ø³Ù†Ø©
                const gameLoop = (timestamp) => {
                    if (gameOver) return;
                    
                    const deltaTime = timestamp - lastTime;
                    lastTime = timestamp;
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø±ÙƒØ¨Ø©
                    car.update(deltaTime);
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¹Ù‚Ø¨Ø§Øª
                    obstacles.forEach((obstacle, index) => {
                        if (obstacle.update(deltaTime)) {
                            obstacles.splice(index, 1);
                        }
                        
                        // Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…
                        if (obstacle.checkCollision(car)) {
                            if (obstacle.type === 'letter') {
                                if (obstacle.isCorrect) {
                                    score += 10;
                                    this.gameManager.gameScore += 10;
                                    this.gameManager.soundManager.playSound('success');
                                    this.addCombo();
                                    this.createExplosion(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2, '#4ade80');
                                } else if (!car.shield) {
                                    car.lives--;
                                    this.gameManager.soundManager.playSound('error');
                                    this.createExplosion(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2, '#ef4444');
                                    
                                    if (car.lives <= 0) {
                                        gameOver = true;
                                        this.showGameOver(canvas, ctx, score);
                                    }
                                }
                            } else {
                                if (obstacle.powerUpType === 'nitro') {
                                    car.activateNitro();
                                } else {
                                    car.activateShield();
                                }
                                this.gameManager.soundManager.playSound('success');
                                this.createExplosion(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2, obstacle.color);
                            }
                            obstacles.splice(index, 1);
                        }
                    });
                    
                    // Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ù‚Ø¨Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©
                    if (timestamp - lastObstacleTime > 1000 - (this.gameDifficulty * 100)) {
                        obstacles.push(new Obstacle());
                        lastObstacleTime = timestamp;
                    }
                    
                    // ØªØ­Ø¯ÙŠØ« Ø®Ø·ÙˆØ· Ø§Ù„Ø·Ø±ÙŠÙ‚
                    if (timestamp - lastRoadUpdate > 1000 / 60) {
                        roadLines.forEach(line => {
                            line.y += gameSettings.roadSpeed * (car.nitro ? 1.5 : 1);
                            if (line.y > canvas.height) {
                                line.y = -40;
                            }
                        });
                        lastRoadUpdate = timestamp;
                    }
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø¤Ø«Ø±Ø§Øª
                    this.updateEffects(deltaTime);
                    
                    // Ø§Ù„Ø±Ø³Ù…
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Ø®Ù„ÙÙŠØ© Ø§Ù„Ø·Ø±ÙŠÙ‚
                    const roadGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    roadGradient.addColorStop(0, '#475569');
                    roadGradient.addColorStop(1, '#334155');
                    ctx.fillStyle = roadGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Ø®Ø·ÙˆØ· Ø§Ù„Ø·Ø±ÙŠÙ‚
                    ctx.fillStyle = '#f1f5f9';
                    roadLines.forEach(line => {
                        ctx.fillRect(line.x, line.y, line.width, line.height);
                    });
                    
                    // Ø§Ù„Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ©
                    ctx.fillStyle = '#1e293b';
                    ctx.fillRect(0, 0, 20, canvas.height);
                    ctx.fillRect(canvas.width - 20, 0, 20, canvas.height);
                    
                    // Ø±Ø³Ù… Ø§Ù„Ø¹Ù‚Ø¨Ø§Øª
                    obstacles.forEach(obstacle => obstacle.draw(ctx));
                    
                    // Ø±Ø³Ù… Ø§Ù„Ù…Ø±ÙƒØ¨Ø©
                    car.draw(ctx);
                    
                    // Ø±Ø³Ù… Ø§Ù„Ù…Ø¤Ø«Ø±Ø§Øª
                    this.drawEffects(ctx);
                    
                    // Ø±Ø³Ù… Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª
                    this.drawGameInfo(ctx, canvas, score, car.lives, car.nitro, car.shield);
                    
                    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙÙˆØ²
                    if (score >= gameSettings.targetScore) {
                        gameOver = true;
                        this.showWinScreen(canvas, ctx, score);
                    }
                    
                    requestAnimationFrame(gameLoop);
                };

                let lastTime = 0;
                requestAnimationFrame((timestamp) => {
                    lastTime = timestamp;
                    gameLoop(timestamp);
                });

                // Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙ…Ø¹ÙŠ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ù„Ù„ØªØ­ÙƒÙ…
                this.setupCarRaceControls(car);
            }

            setupCarRaceControls(car) {
                const keyHandler = (e) => {
                    switch(e.key) {
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            car.moveLeft();
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            car.moveRight();
                            break;
                    }
                };

                document.addEventListener('keydown', keyHandler);
                this.gameManager.currentKeyHandler = keyHandler;

                // Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³
                const touchHandler = (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = this.gameManager.gameCanvas.getBoundingClientRect();
                    const touchX = touch.clientX - rect.left;
                    
                    if (touchX < rect.width / 2) {
                        car.moveLeft();
                    } else {
                        car.moveRight();
                    }
                };

                this.gameManager.gameCanvas.addEventListener('touchstart', touchHandler);
                this.gameManager.currentTouchHandler = touchHandler;
            }

            // ØªØ­Ø³ÙŠÙ† Ù„Ø¹Ø¨Ø© Ø§Ù„ØµÙŠØ¯
            initEnhancedFishing(ctx, canvas) {
                const currentLetter = this.gameManager.currentLetter;
                
                // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ù…Ø­Ø³Ù†Ø©
                const gameSettings = {
                    hookSpeed: 0.08,
                    hookLength: 200,
                    fishCount: 15,
                    fishSpeed: 1,
                    gameTime: 60,
                    targetScore: 30,
                    difficultyFactor: this.gameDifficulty
                };

                // ØµÙ†Ø§Ø±Ø© Ø§Ù„ØµÙŠØ¯ Ø§Ù„Ù…Ø­Ø³Ù†Ø©
                const fishingRod = {
                    x: canvas.width / 2,
                    y: 80,
                    angle: 0,
                    length: gameSettings.hookLength,
                    speed: gameSettings.hookSpeed,
                    hook: {
                        x: 0,
                        y: 0,
                        radius: 15,
                        hasFish: false,
                        fish: null,
                        lineLength: 0
                    },
                    score: 0,
                    combo: 0,
                    lastCatchTime: 0,
                    
                    draw: function(ctx) {
                        // Ø±Ø³Ù… Ø§Ù„Ù‚ØµØ¨Ø©
                        ctx.save();
                        ctx.strokeStyle = '#8b5a2b';
                        ctx.lineWidth = 8;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        
                        // Ù…Ù†Ø­Ù†Ù‰ Ø§Ù„Ù‚ØµØ¨Ø©
                        const controlX = this.x + Math.sin(this.angle) * 50;
                        const controlY = this.y + Math.cos(this.angle) * 50;
                        ctx.quadraticCurveTo(controlX, controlY, this.hook.x, this.hook.y);
                        ctx.stroke();
                        
                        // Ø±Ø³Ù… Ø§Ù„Ø®Ø·Ø§Ù
                        ctx.fillStyle = this.hook.hasFish ? '#4ade80' : '#1e293b';
                        ctx.beginPath();
                        ctx.arc(this.hook.x, this.hook.y, this.hook.radius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Ø®Ø·Ø§Ù Ø­Ù‚ÙŠÙ‚ÙŠ
                        ctx.strokeStyle = '#1e293b';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(this.hook.x, this.hook.y);
                        ctx.lineTo(this.hook.x - 10, this.hook.y + 10);
                        ctx.lineTo(this.hook.x + 10, this.hook.y + 10);
                        ctx.closePath();
                        ctx.stroke();
                        
                        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø³Ù…ÙƒØ©
                        if (this.hook.hasFish && this.hook.fish) {
                            this.hook.fish.drawHook(ctx, this.hook.x, this.hook.y);
                        }
                        
                        ctx.restore();
                    },
                    
                    update: function(deltaTime) {
                        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø²Ø§ÙˆÙŠØ©
                        this.angle += this.speed;
                        
                        // Ø­Ø³Ø§Ø¨ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø®Ø·Ø§Ù
                        this.hook.x = this.x + Math.sin(this.angle) * this.length;
                        this.hook.y = this.y + Math.cos(this.angle) * 0.8 * this.length;
                        
                        // Ø§Ù„ØªØ­ÙƒÙ…
                        if (this.gameManager.touchControls.left) {
                            this.speed = -gameSettings.hookSpeed * 1.5;
                        } else if (this.gameManager.touchControls.right) {
                            this.speed = gameSettings.hookSpeed * 1.5;
                        } else {
                            this.speed = this.speed > 0 ? 
                                gameSettings.hookSpeed : 
                                -gameSettings.hookSpeed;
                        }
                        
                        // ØªÙ‚ÙŠÙŠØ¯ Ø§Ù„Ø³Ø±Ø¹Ø©
                        this.speed = Math.max(-gameSettings.hookSpeed * 2, 
                                            Math.min(gameSettings.hookSpeed * 2, this.speed));
                        
                        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø®Ø·Ø§Ù
                        if (this.hook.hasFish && this.hook.fish) {
                            this.hook.y -= 3; // Ø³Ø­Ø¨ Ø§Ù„Ø³Ù…ÙƒØ© Ù„Ù„Ø£Ø¹Ù„Ù‰
                        }
                        
                        // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙƒÙˆÙ…Ø¨Ùˆ
                        if (Date.now() - this.lastCatchTime > 3000) {
                            this.combo = 0;
                        }
                    },
                    
                    catchFish: function(fish) {
                        this.hook.hasFish = true;
                        this.hook.fish = fish;
                        fish.isCaught = true;
                        this.lastCatchTime = Date.now();
                    },
                    
                    releaseHook: function() {
                        if (this.hook.hasFish && this.hook.fish) {
                            const fish = this.hook.fish;
                            this.score += fish.isCorrect ? 10 : -5;
                            this.combo += fish.isCorrect ? 1 : 0;
                            this.hook.hasFish = false;
                            this.hook.fish = null;
                            return fish;
                        }
                        return null;
                    }
                };

                // Ø§Ù„Ø£Ø³Ù…Ø§Ùƒ Ø§Ù„Ù…Ø­Ø³Ù†Ø©
                class Fish {
                    constructor() {
                        this.width = 50 + Math.random() * 30;
                        this.height = 25 + Math.random() * 15;
                        this.x = Math.random() * (canvas.width - this.width);
                        this.y = 150 + Math.random() * (canvas.height - 250);
                        this.speedX = (Math.random() - 0.5) * 2;
                        this.speedY = (Math.random() - 0.5) * 1;
                        this.isCorrect = Math.random() > 0.5;
                        this.letter = this.isCorrect ? currentLetter : 
                                     this.getRandomDifferentLetter(currentLetter);
                        this.color = this.getFishColor();
                        this.isCaught = false;
                        this.caughtTime = 0;
                        this.wobble = Math.random() * Math.PI * 2;
                        this.wobbleSpeed = 0.1 + Math.random() * 0.1;
                    }
                    
                    getRandomDifferentLetter(currentLetter) {
                        const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                        const differentLetters = letters.filter(l => l !== currentLetter);
                        return differentLetters[Math.floor(Math.random() * differentLetters.length)];
                    }
                    
                    getFishColor() {
                        const colors = this.isCorrect ? 
                            ['#4cc9f0', '#4895ef', '#4361ee'] : 
                            ['#ef4444', '#f59e0b', '#f97316'];
                        return colors[Math.floor(Math.random() * colors.length)];
                    }
                    
                    draw(ctx) {
                        if (this.isCaught) return;
                        
                        ctx.save();
                        
                        // Ø­Ø±ÙƒØ© Ø§Ù„ØªÙ…Ø§ÙŠÙ„
                        const wobbleOffset = Math.sin(this.wobble) * 5;
                        
                        // Ø¬Ø³Ù… Ø§Ù„Ø³Ù…ÙƒØ©
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        
                        // Ø´ÙƒÙ„ Ø§Ù„Ø³Ù…ÙƒØ© Ø§Ù„Ø¨ÙŠØ¶Ø§ÙˆÙŠ
                        ctx.ellipse(
                            this.x + this.width/2,
                            this.y + this.height/2 + wobbleOffset,
                            this.width/2,
                            this.height/2,
                            0, 0, Math.PI * 2
                        );
                        ctx.fill();
                        
                        // Ø§Ù„Ø°ÙŠÙ„
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y + this.height/2 + wobbleOffset);
                        ctx.lineTo(this.x - this.width/3, this.y + wobbleOffset);
                        ctx.lineTo(this.x - this.width/3, this.y + this.height + wobbleOffset);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Ø§Ù„Ø¹ÙŠÙ†
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(
                            this.x + this.width * 0.7,
                            this.y + this.height/3 + wobbleOffset,
                            4, 0, Math.PI * 2
                        );
                        ctx.fill();
                        
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(
                            this.x + this.width * 0.7,
                            this.y + this.height/3 + wobbleOffset,
                            2, 0, Math.PI * 2
                        );
                        ctx.fill();
                        
                        // Ø§Ù„Ø²Ø¹Ø§Ù†Ù
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.moveTo(this.x + this.width/3, this.y + this.height/2 + wobbleOffset);
                        ctx.lineTo(this.x + this.width/2, this.y - 5 + wobbleOffset);
                        ctx.lineTo(this.x + this.width/2, this.y + this.height/2 + wobbleOffset);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Ø§Ù„Ø­Ø±Ù
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 20px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(
                            this.letter,
                            this.x + this.width/2,
                            this.y + this.height/2 + wobbleOffset
                        );
                        
                        // ÙÙ‚Ø§Ø¹Ø§Øª
                        if (Math.random() > 0.9) {
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                            ctx.beginPath();
                            ctx.arc(
                                this.x + this.width + 5,
                                this.y + this.height/3,
                                3, 0, Math.PI * 2
                            );
                            ctx.fill();
                        }
                        
                        ctx.restore();
                    }
                    
                    drawHook(ctx, hookX, hookY) {
                        ctx.save();
                        
                        // Ø¬Ø³Ù… Ø§Ù„Ø³Ù…ÙƒØ© Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø·Ø§Ù
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.ellipse(
                            hookX,
                            hookY,
                            this.width/2,
                            this.height/2,
                            Math.PI/4, 0, Math.PI * 2
                        );
                        ctx.fill();
                        
                        // Ø§Ù„Ø°ÙŠÙ„
                        ctx.beginPath();
                        ctx.moveTo(hookX - this.width/2, hookY);
                        ctx.lineTo(hookX - this.width, hookY - this.height/3);
                        ctx.lineTo(hookX - this.width, hookY + this.height/3);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Ø§Ù„Ø­Ø±Ù
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(this.letter, hookX, hookY);
                        
                        ctx.restore();
                    }
                    
                    update(deltaTime) {
                        if (this.isCaught) return;
                        
                        this.wobble += this.wobbleSpeed;
                        
                        // Ø­Ø±ÙƒØ© Ø§Ù„Ø³Ù…ÙƒØ©
                        this.x += this.speedX;
                        this.y += this.speedY;
                        
                        // Ø§Ø±ØªØ¯Ø§Ø¯ Ù…Ù† Ø§Ù„Ø­ÙˆØ§Ù
                        if (this.x < 0 || this.x > canvas.width - this.width) {
                            this.speedX = -this.speedX;
                        }
                        if (this.y < 150 || this.y > canvas.height - 50) {
                            this.speedY = -this.speedY;
                        }
                        
                        // ØªØºÙŠÙŠØ± Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø¨Ø´ÙƒÙ„ Ø¹Ø´ÙˆØ§Ø¦ÙŠ
                        if (Math.random() < 0.01) {
                            this.speedX = (Math.random() - 0.5) * 2;
                            this.speedY = (Math.random() - 0.5) * 1;
                        }
                    }
                    
                    checkCollision(hookX, hookY, hookRadius) {
                        if (this.isCaught) return false;
                        
                        const dx = (this.x + this.width/2) - hookX;
                        const dy = (this.y + this.height/2) - hookY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        return distance < (this.width/2 + hookRadius);
                    }
                }

                // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø³Ù…Ø§Ùƒ
                const fishes = [];
                for (let i = 0; i < gameSettings.fishCount; i++) {
                    fishes.push(new Fish());
                }

                // Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø£Ø®Ø±Ù‰ ÙÙŠ Ø§Ù„Ø¨Ø­Ø±
                const seaElements = [];
                for (let i = 0; i < 10; i++) {
                    seaElements.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        type: Math.random() > 0.5 ? 'plant' : 'rock',
                        size: 20 + Math.random() * 30,
                        sway: Math.random() * Math.PI * 2
                    });
                }

                let gameTime = gameSettings.gameTime * 1000;
                let lastTime = 0;
                let gameActive = true;

                const gameLoop = (timestamp) => {
                    if (!gameActive) return;
                    
                    const deltaTime = timestamp - lastTime;
                    lastTime = timestamp;
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆÙ‚Øª
                    gameTime -= deltaTime;
                    if (gameTime <= 0) {
                        gameActive = false;
                        this.showGameOver(canvas, ctx, fishingRod.score);
                        return;
                    }
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙ†Ø§Ø±Ø©
                    fishingRod.update(deltaTime);
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ø³Ù…Ø§Ùƒ
                    fishes.forEach(fish => fish.update(deltaTime));
                    
                    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·ÙŠØ§Ø¯
                    if (!fishingRod.hook.hasFish) {
                        fishes.forEach(fish => {
                            if (fish.checkCollision(fishingRod.hook.x, fishingRod.hook.y, fishingRod.hook.radius)) {
                                fishingRod.catchFish(fish);
                                this.gameManager.soundManager.playSound('click');
                            }
                        });
                    }
                    
                    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø±ÙØ¹ Ø§Ù„ØµÙ†Ø§Ø±Ø©
                    if (fishingRod.hook.hasFish && fishingRod.hook.y < 100) {
                        const caughtFish = fishingRod.releaseHook();
                        if (caughtFish) {
                            if (caughtFish.isCorrect) {
                                this.gameManager.gameScore += 10 + fishingRod.combo * 2;
                                this.gameManager.soundManager.playSound('success');
                                this.createExplosion(
                                    fishingRod.hook.x,
                                    fishingRod.hook.y,
                                    caughtFish.color
                                );
                                this.addCombo();
                            } else {
                                this.gameManager.soundManager.playSound('error');
                                fishingRod.score = Math.max(0, fishingRod.score - 5);
                            }
                        }
                    }
                    
                    // ØªØ­Ø¯ÙŠØ« Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø¨Ø­Ø±
                    seaElements.forEach(element => {
                        element.sway += 0.02;
                    });
                    
                    // Ø§Ù„Ø±Ø³Ù…
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Ø®Ù„ÙÙŠØ© Ø§Ù„Ø¨Ø­Ø±
                    const seaGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    seaGradient.addColorStop(0, '#4cc9f0');
                    seaGradient.addColorStop(0.5, '#4895ef');
                    seaGradient.addColorStop(1, '#3a0ca3');
                    ctx.fillStyle = seaGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Ø³Ø·Ø­ Ø§Ù„Ù…Ø§Ø¡ Ù…Ø¹ Ø­Ø±ÙƒØ© Ø§Ù„Ù…ÙˆØ¬
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    for (let x = 0; x < canvas.width; x += 20) {
                        const waveHeight = Math.sin(Date.now()/1000 + x/100) * 10;
                        ctx.beginPath();
                        ctx.arc(x, 50 + waveHeight, 10, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Ø±Ø³Ù… Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø¨Ø­Ø±
                    seaElements.forEach(element => {
                        ctx.save();
                        if (element.type === 'plant') {
                            ctx.fillStyle = '#22c55e';
                            const swayOffset = Math.sin(element.sway) * 5;
                            for (let i = 0; i < 3; i++) {
                                ctx.beginPath();
                                ctx.moveTo(element.x, element.y);
                                ctx.quadraticCurveTo(
                                    element.x - 20 + swayOffset,
                                    element.y - element.size/2,
                                    element.x,
                                    element.y - element.size
                                );
                                ctx.stroke();
                            }
                        } else {
                            ctx.fillStyle = '#64748b';
                            ctx.beginPath();
                            ctx.arc(element.x, element.y, element.size/2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.restore();
                    });
                    
                    // Ø±Ø³Ù… Ø§Ù„Ø£Ø³Ù…Ø§Ùƒ
                    fishes.forEach(fish => fish.draw(ctx));
                    
                    // Ø±Ø³Ù… Ø§Ù„ØµÙ†Ø§Ø±Ø©
                    fishingRod.draw(ctx);
                    
                    // Ø±Ø³Ù… Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª
                    this.drawFishingInfo(ctx, canvas, fishingRod.score, gameTime, fishingRod.combo);
                    
                    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙÙˆØ²
                    if (fishingRod.score >= gameSettings.targetScore) {
                        gameActive = false;
                        this.showWinScreen(canvas, ctx, fishingRod.score);
                        return;
                    }
                    
                    requestAnimationFrame(gameLoop);
                };

                lastTime = 0;
                requestAnimationFrame(gameLoop);

                // Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙ…Ø¹ÙŠ Ø§Ù„ØªØ­ÙƒÙ…
                this.setupFishingControls();
            }

            setupFishingControls() {
                const keyHandler = (e) => {
                    switch(e.key) {
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            this.gameManager.touchControls.left = true;
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            this.gameManager.touchControls.right = true;
                            break;
                    }
                };

                const keyUpHandler = (e) => {
                    switch(e.key) {
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            this.gameManager.touchControls.left = false;
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            this.gameManager.touchControls.right = false;
                            break;
                    }
                };

                document.addEventListener('keydown', keyHandler);
                document.addEventListener('keyup', keyUpHandler);
                
                this.gameManager.currentKeyHandlers = {
                    keydown: keyHandler,
                    keyup: keyUpHandler
                };
            }

            // ØªØ­Ø³ÙŠÙ† Ù„Ø¹Ø¨Ø© Ø§Ù„Ù…Ø¶Ø±Ø¨
            initEnhancedRacket(ctx, canvas) {
                const currentLetter = this.gameManager.currentLetter;
                
                // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©
                const gameSettings = {
                    paddleSpeed: 8,
                    ballSpeed: 5,
                    gameTime: 60,
                    targetScore: 40,
                    difficultyFactor: this.gameDifficulty
                };

                // Ø§Ù„Ù…Ø¶Ø±Ø¨ Ø§Ù„Ù…Ø­Ø³Ù†
                const paddle = {
                    x: canvas.width / 2 - 60,
                    y: canvas.height - 40,
                    width: 120,
                    height: 25,
                    speed: gameSettings.paddleSpeed,
                    color: '#f72585',
                    score: 0,
                    lives: 3,
                    power: 1,
                    
                    draw: function(ctx) {
                        // Ø§Ù„Ù…Ø¶Ø±Ø¨ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
                        ctx.fillStyle = this.color;
                        ctx.fillRect(this.x, this.y, this.width, this.height);
                        
                        // ÙˆØ³Ø· Ø§Ù„Ù…Ø¶Ø±Ø¨
                        ctx.fillStyle = '#4cc9f0';
                        ctx.fillRect(this.x + 10, this.y + 5, this.width - 20, 15);
                        
                        // Ø­ÙˆØ§Ù Ø§Ù„Ù…Ø¶Ø±Ø¨
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(this.x, this.y, this.width, this.height);
                    },
                    
                    moveLeft: function() {
                        this.x = Math.max(0, this.x - this.speed);
                    },
                    
                    moveRight: function() {
                        this.x = Math.min(canvas.width - this.width, this.x + this.speed);
                    },
                    
                    increasePower: function() {
                        this.power = Math.min(3, this.power + 0.5);
                        this.width = 120 * this.power;
                    },
                    
                    decreasePower: function() {
                        this.power = Math.max(0.5, this.power - 0.5);
                        this.width = 120 * this.power;
                    }
                };

                // Ø§Ù„ÙƒØ±Ø© Ø§Ù„Ù…Ø­Ø³Ù†Ø©
                class Ball {
                    constructor() {
                        this.reset();
                        this.letter = currentLetter;
                        this.isCorrect = true;
                        this.size = 25;
                        this.color = '#4361ee';
                        this.trail = [];
                        this.maxTrail = 10;
                    }
                    
                    reset() {
                        this.x = canvas.width / 2;
                        this.y = canvas.height / 2;
                        this.speedX = (Math.random() > 0.5 ? 1 : -1) * gameSettings.ballSpeed;
                        this.speedY = -gameSettings.ballSpeed;
                        this.letter = this.getRandomLetter();
                        this.color = this.isCorrect ? '#4361ee' : '#ef4444';
                    }
                    
                    getRandomLetter() {
                        const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                        this.isCorrect = Math.random() > 0.3;
                        return this.isCorrect ? currentLetter : 
                               letters.filter(l => l !== currentLetter)[
                                   Math.floor(Math.random() * 25)
                               ];
                    }
                    
                    draw(ctx) {
                        // Ø±Ø³Ù… Ø§Ù„Ø£Ø«Ø±
                        this.trail.forEach((pos, index) => {
                            const alpha = index / this.maxTrail;
                            ctx.fillStyle = `rgba(67, 97, 238, ${alpha})`;
                            ctx.beginPath();
                            ctx.arc(pos.x, pos.y, this.size * alpha, 0, Math.PI * 2);
                            ctx.fill();
                        });
                        
                        // Ø±Ø³Ù… Ø§Ù„ÙƒØ±Ø©
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Ø§Ù„Ø­Ø±Ù
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 18px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(this.letter, this.x, this.y);
                        
                        // ØªØ£Ø«ÙŠØ± Ù„Ù„ÙƒØ±Ø§Øª Ø§Ù„ØµØ­ÙŠØ­Ø©
                        if (this.isCorrect) {
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.size + 3, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    }
                    
                    update() {
                        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ø«Ø±
                        this.trail.push({ x: this.x, y: this.y });
                        if (this.trail.length > this.maxTrail) {
                            this.trail.shift();
                        }
                        
                        // Ø­Ø±ÙƒØ© Ø§Ù„ÙƒØ±Ø©
                        this.x += this.speedX;
                        this.y += this.speedY;
                        
                        // Ø§Ø±ØªØ¯Ø§Ø¯ Ù…Ù† Ø§Ù„Ø¬Ø¯Ø±Ø§Ù†
                        if (this.x - this.size < 0 || this.x + this.size > canvas.width) {
                            this.speedX = -this.speedX;
                            this.gameManager.soundManager.playSound('click');
                        }
                        
                        if (this.y - this.size < 0) {
                            this.speedY = -this.speedY;
                            this.gameManager.soundManager.playSound('click');
                        }
                        
                        // Ø§Ø±ØªØ¯Ø§Ø¯ Ù…Ù† Ø§Ù„Ù…Ø¶Ø±Ø¨
                        if (this.y + this.size > paddle.y &&
                            this.y - this.size < paddle.y + paddle.height &&
                            this.x + this.size > paddle.x &&
                            this.x - this.size < paddle.x + paddle.width) {
                            
                            // Ø­Ø³Ø§Ø¨ Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø§Ø±ØªØ¯Ø§Ø¯ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…ÙƒØ§Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø¨Ø§Ù„Ù…Ø¶Ø±Ø¨
                            const hitPos = (this.x - paddle.x) / paddle.width;
                            const angle = hitPos * Math.PI - Math.PI / 2;
                            
                            this.speedX = Math.sin(angle) * gameSettings.ballSpeed * paddle.power;
                            this.speedY = -Math.abs(Math.cos(angle) * gameSettings.ballSpeed * paddle.power);
                            
                            // ØªØ£Ø«ÙŠØ±Ø§Øª Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„ÙƒØ±Ø©
                            if (this.isCorrect) {
                                paddle.score += 10;
                                this.gameManager.gameScore += 10;
                                this.gameManager.soundManager.playSound('success');
                                this.createExplosion(this.x, this.y, this.color);
                                this.addCombo();
                            } else {
                                paddle.lives--;
                                this.gameManager.soundManager.playSound('error');
                                paddle.decreasePower();
                                if (paddle.lives <= 0) {
                                    return 'gameover';
                                }
                            }
                            
                            // ØªØºÙŠÙŠØ± Ø§Ù„Ø­Ø±Ù Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ø±ØªØ¯Ø§Ø¯
                            this.letter = this.getRandomLetter();
                            this.color = this.isCorrect ? '#4361ee' : '#ef4444';
                            
                            return 'hit';
                        }
                        
                        // ÙÙ‚Ø¯Ø§Ù† Ø§Ù„ÙƒØ±Ø©
                        if (this.y - this.size > canvas.height) {
                            paddle.lives--;
                            this.gameManager.soundManager.playSound('error');
                            paddle.decreasePower();
                            this.reset();
                            
                            if (paddle.lives <= 0) {
                                return 'gameover';
                            }
                            return 'lost';
                        }
                        
                        return 'playing';
                    }
                }

                // Ø§Ù„ÙƒØ±Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©
                const balls = [new Ball()];
                let gameTime = gameSettings.gameTime;
                let lastTime = 0;
                let gameActive = true;
                let combo = 0;
                let lastHitTime = 0;

                // Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…ÙŠØ¯Ø§Ù†
                const fieldElements = [];
                for (let i = 0; i < 5; i++) {
                    fieldElements.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * (canvas.height - 200) + 100,
                        size: 5 + Math.random() * 10,
                        speed: 0.5 + Math.random() * 1
                    });
                }

                const gameLoop = (timestamp) => {
                    if (!gameActive) return;
                    
                    const deltaTime = timestamp - lastTime;
                    lastTime = timestamp;
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø¶Ø±Ø¨
                    if (this.gameManager.touchControls.left) paddle.moveLeft();
                    if (this.gameManager.touchControls.right) paddle.moveRight();
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙƒØ±Ø§Øª
                    balls.forEach((ball, index) => {
                        const result = ball.update();
                        
                        if (result === 'gameover') {
                            gameActive = false;
                            this.showGameOver(canvas, ctx, paddle.score);
                            return;
                        } else if (result === 'hit') {
                            lastHitTime = Date.now();
                            combo++;
                            
                            // Ø¥Ø¶Ø§ÙØ© ÙƒØ±Ø§Øª Ø¬Ø¯ÙŠØ¯Ø© Ø¹Ù†Ø¯ Ø§Ù„ÙƒÙˆÙ…Ø¨Ùˆ Ø§Ù„Ø¹Ø§Ù„ÙŠ
                            if (combo % 5 === 0 && balls.length < 3) {
                                balls.push(new Ball());
                            }
                            
                            // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ù‚ÙˆØ© Ø¹Ù†Ø¯ Ø§Ù„ÙƒÙˆÙ…Ø¨Ùˆ Ø§Ù„Ø¹Ø§Ù„ÙŠ
                            if (combo % 3 === 0) {
                                paddle.increasePower();
                            }
                        }
                    });
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙƒÙˆÙ…Ø¨Ùˆ
                    if (Date.now() - lastHitTime > 2000) {
                        combo = 0;
                    }
                    
                    // ØªØ­Ø¯ÙŠØ« Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…ÙŠØ¯Ø§Ù†
                    fieldElements.forEach(element => {
                        element.y += element.speed;
                        if (element.y > canvas.height) {
                            element.y = 100;
                            element.x = Math.random() * canvas.width;
                        }
                    });
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆÙ‚Øª
                    gameTime -= deltaTime / 1000;
                    if (gameTime <= 0) {
                        gameActive = false;
                        this.showGameOver(canvas, ctx, paddle.score);
                        return;
                    }
                    
                    // Ø§Ù„Ø±Ø³Ù…
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Ø®Ù„ÙÙŠØ© Ø§Ù„Ù…ÙŠØ¯Ø§Ù†
                    const fieldGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    fieldGradient.addColorStop(0, '#1e293b');
                    fieldGradient.addColorStop(1, '#0f172a');
                    ctx.fillStyle = fieldGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Ø´Ø¨ÙƒØ© Ø§Ù„Ù…Ù†ØªØµÙ
                    ctx.strokeStyle = '#475569';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10, 10]);
                    ctx.beginPath();
                    ctx.moveTo(canvas.width/2, 0);
                    ctx.lineTo(canvas.width/2, canvas.height);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…ÙŠØ¯Ø§Ù†
                    ctx.fillStyle = '#334155';
                    fieldElements.forEach(element => {
                        ctx.beginPath();
                        ctx.arc(element.x, element.y, element.size, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Ø±Ø³Ù… Ø§Ù„ÙƒØ±Ø§Øª
                    balls.forEach(ball => ball.draw(ctx));
                    
                    // Ø±Ø³Ù… Ø§Ù„Ù…Ø¶Ø±Ø¨
                    paddle.draw(ctx);
                    
                    // Ø±Ø³Ù… Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª
                    this.drawRacketInfo(ctx, canvas, paddle.score, paddle.lives, gameTime, combo);
                    
                    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙÙˆØ²
                    if (paddle.score >= gameSettings.targetScore) {
                        gameActive = false;
                        this.showWinScreen(canvas, ctx, paddle.score);
                        return;
                    }
                    
                    requestAnimationFrame(gameLoop);
                };

                lastTime = 0;
                requestAnimationFrame(gameLoop);

                // Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙ…Ø¹ÙŠ Ø§Ù„ØªØ­ÙƒÙ…
                this.setupRacketControls();
            }

            // ØªØ­Ø³ÙŠÙ† Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¨Ø§Ù„ÙˆÙ†Ø§Øª
            initEnhancedBalloons(ctx, canvas) {
                const currentLetter = this.gameManager.currentLetter;
                
                // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©
                const gameSettings = {
                    balloonSpeed: 1.5,
                    balloonCount: 25,
                    gameTime: 60,
                    targetScore: 50,
                    difficultyFactor: this.gameDifficulty,
                    colors: ['#f72585', '#4361ee', '#4cc9f0', '#4ade80', '#f59e0b']
                };

                // Ø§Ù„Ø¨Ø§Ù„ÙˆÙ†Ø§Øª Ø§Ù„Ù…Ø­Ø³Ù†Ø©
                class Balloon {
                    constructor() {
                        this.reset();
                        this.wobble = Math.random() * Math.PI * 2;
                        this.wobbleSpeed = 0.05 + Math.random() * 0.05;
                        this.pulse = 0;
                        this.pulseSpeed = 0.1;
                    }
                    
                    reset() {
                        this.radius = 25 + Math.random() * 25;
                        this.x = Math.random() * (canvas.width - this.radius * 2) + this.radius;
                        this.y = canvas.height + this.radius;
                        this.speed = gameSettings.balloonSpeed + Math.random() * 2;
                        this.isCorrect = Math.random() > 0.4;
                        this.letter = this.isCorrect ? currentLetter : 
                                     this.getRandomDifferentLetter(currentLetter);
                        this.color = gameSettings.colors[Math.floor(Math.random() * gameSettings.colors.length)];
                        this.popped = false;
                        this.popProgress = 0;
                        this.stringLength = 60 + Math.random() * 40;
                        this.stringAngle = Math.random() * Math.PI * 2;
                    }
                    
                    getRandomDifferentLetter(currentLetter) {
                        const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
                        const differentLetters = letters.filter(l => l !== currentLetter);
                        return differentLetters[Math.floor(Math.random() * differentLetters.length)];
                    }
                    
                    draw(ctx) {
                        if (this.popped) {
                            // ØªØ£Ø«ÙŠØ± Ø§Ù„ÙØ±Ù‚Ø¹Ø©
                            this.drawPopEffect(ctx);
                            return;
                        }
                        
                        ctx.save();
                        
                        // Ø­Ø±ÙƒØ© Ø§Ù„ØªÙ…Ø§ÙŠÙ„
                        const wobbleOffset = Math.sin(this.wobble) * 5;
                        const pulseScale = 1 + Math.sin(this.pulse) * 0.1;
                        
                        // Ø®ÙŠØ· Ø§Ù„Ø¨Ø§Ù„ÙˆÙ†
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y + this.radius);
                        
                        const stringEndX = this.x + Math.sin(this.stringAngle) * this.stringLength;
                        const stringEndY = this.y + this.radius + Math.cos(this.stringAngle) * this.stringLength;
                        
                        ctx.quadraticCurveTo(
                            this.x,
                            this.y + this.radius + this.stringLength/2,
                            stringEndX,
                            stringEndY
                        );
                        ctx.stroke();
                        
                        // Ø§Ù„Ø¨Ø§Ù„ÙˆÙ†
                        ctx.translate(this.x, this.y + wobbleOffset);
                        ctx.scale(pulseScale, pulseScale);
                        
                        // Ø¬Ø³Ù… Ø§Ù„Ø¨Ø§Ù„ÙˆÙ†
                        const gradient = ctx.createRadialGradient(
                            0, 0, 0,
                            0, 0, this.radius
                        );
                        gradient.addColorStop(0, this.color);
                        gradient.addColorStop(1, this.darkenColor(this.color, 30));
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ØªØ³Ù„ÙŠØ· Ø§Ù„Ø¶ÙˆØ¡
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.beginPath();
                        ctx.arc(-this.radius/3, -this.radius/3, this.radius/4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Ø¹Ù‚Ø¯Ø© Ø§Ù„Ø¨Ø§Ù„ÙˆÙ†
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(0, this.radius, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Ø§Ù„Ø­Ø±Ù
                        ctx.fillStyle = 'white';
                        ctx.font = `bold ${this.radius/2}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(this.letter, 0, 0);
                        
                        // ØªØ£Ø«ÙŠØ± Ù„Ù„Ø¨Ø§Ù„ÙˆÙ†Ø§Øª Ø§Ù„ØµØ­ÙŠØ­Ø©
                        if (this.isCorrect) {
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius + 5, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        
                        ctx.restore();
                    }
                    
                    drawPopEffect(ctx) {
                        ctx.save();
                        ctx.translate(this.x, this.y);
                        
                        // Ù‚Ø·Ø¹ Ø§Ù„Ø¨Ø§Ù„ÙˆÙ† Ø§Ù„Ù…ØªÙØ¬Ø±Ø©
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            const distance = this.radius * (1 + this.popProgress);
                            
                            ctx.fillStyle = this.color;
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(
                                Math.cos(angle) * this.radius/2,
                                Math.sin(angle) * this.radius/2
                            );
                            ctx.lineTo(
                                Math.cos(angle) * distance,
                                Math.sin(angle) * distance
                            );
                            ctx.closePath();
                            ctx.fill();
                        }
                        
                        ctx.restore();
                    }
                    
                    darkenColor(color, percent) {
                        const num = parseInt(color.slice(1), 16);
                        const amt = Math.round(2.55 * percent);
                        const R = (num >> 16) - amt;
                        const G = (num >> 8 & 0x00FF) - amt;
                        const B = (num & 0x0000FF) - amt;
                        return `#${(0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                                (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1)}`;
                    }
                    
                    update(deltaTime) {
                        if (this.popped) {
                            this.popProgress += deltaTime / 500;
                            return this.popProgress >= 1;
                        }
                        
                        this.wobble += this.wobbleSpeed;
                        this.pulse += this.pulseSpeed;
                        
                        this.y -= this.speed;
                        
                        // Ø­Ø±ÙƒØ© Ø®ÙŠØ· Ø§Ù„Ø¨Ø§Ù„ÙˆÙ†
                        this.stringAngle += 0.02;
                        
                        return this.y < -this.radius;
                    }
                    
                    checkClick(mouseX, mouseY) {
                        if (this.popped) return false;
                        
                        const dx = mouseX - this.x;
                        const dy = mouseY - (this.y + Math.sin(this.wobble) * 5);
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        return distance < this.radius;
                    }
                    
                    pop() {
                        this.popped = true;
                        this.popProgress = 0;
                        return this.isCorrect;
                    }
                }

                // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨Ø§Ù„ÙˆÙ†Ø§Øª
                const balloons = [];
                for (let i = 0; i < gameSettings.balloonCount; i++) {
                    const balloon = new Balloon();
                    balloon.y = -Math.random() * canvas.height;
                    balloons.push(balloon);
                }

                // Ø§Ù„Ø³Ø­Ø¨ Ø§Ù„Ù…ØªØ­Ø±ÙƒØ©
                const clouds = [];
                for (let i = 0; i < 5; i++) {
                    clouds.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * 100,
                        size: 40 + Math.random() * 40,
                        speed: 0.2 + Math.random() * 0.3
                    });
                }

                let score = 0;
                let gameTime = gameSettings.gameTime;
                let lastTime = 0;
                let gameActive = true;
                let combo = 0;
                let lastPopTime = 0;

                const gameLoop = (timestamp) => {
                    if (!gameActive) return;
                    
                    const deltaTime = timestamp - lastTime;
                    lastTime = timestamp;
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨Ø§Ù„ÙˆÙ†Ø§Øª
                    balloons.forEach((balloon, index) => {
                        const shouldRemove = balloon.update(deltaTime);
                        
                        if (shouldRemove) {
                            if (!balloon.popped) {
                                // ÙÙ‚Ø¯Ø§Ù† Ø­ÙŠØ§Ø© Ø¥Ø°Ø§ Ø®Ø±Ø¬ Ø¨Ø§Ù„ÙˆÙ† ØµØ­ÙŠØ­
                                if (balloon.isCorrect) {
                                    combo = 0;
                                }
                            }
                            balloon.reset();
                            balloon.y = canvas.height + balloon.radius;
                        }
                    });
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ø­Ø¨
                    clouds.forEach(cloud => {
                        cloud.x += cloud.speed;
                        if (cloud.x > canvas.width + cloud.size) {
                            cloud.x = -cloud.size;
                            cloud.y = Math.random() * 100;
                        }
                    });
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆÙ‚Øª
                    gameTime -= deltaTime / 1000;
                    if (gameTime <= 0) {
                        gameActive = false;
                        this.showGameOver(canvas, ctx, score);
                        return;
                    }
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙƒÙˆÙ…Ø¨Ùˆ
                    if (Date.now() - lastPopTime > 2000) {
                        combo = 0;
                    }
                    
                    // Ø§Ù„Ø±Ø³Ù…
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Ø®Ù„ÙÙŠØ© Ø§Ù„Ø³Ù…Ø§Ø¡
                    const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    skyGradient.addColorStop(0, '#4cc9f0');
                    skyGradient.addColorStop(1, '#4895ef');
                    ctx.fillStyle = skyGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Ø§Ù„Ø³Ø­Ø¨
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    clouds.forEach(cloud => {
                        ctx.beginPath();
                        ctx.arc(cloud.x, cloud.y, cloud.size, 0, Math.PI * 2);
                        ctx.arc(cloud.x + cloud.size/2, cloud.y - cloud.size/3, cloud.size/1.5, 0, Math.PI * 2);
                        ctx.arc(cloud.x - cloud.size/2, cloud.y - cloud.size/4, cloud.size/1.8, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Ø±Ø³Ù… Ø§Ù„Ø¨Ø§Ù„ÙˆÙ†Ø§Øª
                    balloons.forEach(balloon => balloon.draw(ctx));
                    
                    // Ø±Ø³Ù… Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª
                    this.drawBalloonsInfo(ctx, canvas, score, gameTime, combo);
                    
                    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙÙˆØ²
                    if (score >= gameSettings.targetScore) {
                        gameActive = false;
                        this.showWinScreen(canvas, ctx, score);
                        return;
                    }
                    
                    requestAnimationFrame(gameLoop);
                };

                lastTime = 0;
                requestAnimationFrame(gameLoop);

                // Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙ…Ø¹ÙŠ Ø§Ù„Ù†Ù‚Ø±
                const clickHandler = (e) => {
                    if (!gameActive) return;
                    
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    balloons.forEach(balloon => {
                        if (balloon.checkClick(mouseX, mouseY)) {
                            const isCorrect = balloon.pop();
                            
                            if (isCorrect) {
                                score += 10 + combo * 2;
                                this.gameManager.gameScore += 10 + combo * 2;
                                this.gameManager.soundManager.playSound('success');
                                this.addCombo();
                                combo++;
                                lastPopTime = Date.now();
                                
                                // ØªØ£Ø«ÙŠØ±Ø§Øª Ø®Ø§ØµØ© Ù„Ù„ÙƒÙˆÙ…Ø¨Ùˆ
                                if (combo >= 5) {
                                    this.createExplosion(balloon.x, balloon.y, '#f59e0b');
                                }
                            } else {
                                this.gameManager.soundManager.playSound('error');
                                combo = 0;
                                score = Math.max(0, score - 5);
                            }
                            
                            this.createExplosion(balloon.x, balloon.y, balloon.color);
                        }
                    });
                };

                canvas.addEventListener('click', clickHandler);
                this.gameManager.currentClickHandler = clickHandler;

                // Ù„Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„ØªÙŠ ØªØ¹Ù…Ù„ Ø¨Ø§Ù„Ù„Ù…Ø³
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    clickHandler(e.touches[0]);
                });
            }

            // ØªØ­Ø³ÙŠÙ† Ù„Ø¹Ø¨Ø© Ø§Ù„Ø°Ø§ÙƒØ±Ø©
            initEnhancedMemory(ctx, canvas) {
                const currentLetter = this.gameManager.currentLetter;
                const letterData = this.gameManager.letterData;
                
                // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©
                const gameSettings = {
                    rows: 4,
                    cols: 4,
                    gameTime: 90,
                    cardFlipSpeed: 0.6,
                    difficultyFactor: this.gameDifficulty
                };

                // Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ù…Ø­Ø³Ù†Ø©
                class MemoryCard {
                    constructor(row, col, pairId, type, value) {
                        this.row = row;
                        this.col = col;
                        this.pairId = pairId;
                        this.type = type; // 'letter' Ø£Ùˆ 'word'
                        this.value = value;
                        this.width = 80;
                        this.height = 100;
                        this.x = col * (this.width + 10) + (canvas.width - (gameSettings.cols * (this.width + 10) - 10)) / 2;
                        this.y = row * (this.height + 10) + 80;
                        this.flipped = false;
                        this.matched = false;
                        this.flipProgress = 0;
                        this.flipSpeed = gameSettings.cardFlipSpeed;
                        this.hover = false;
                        this.pulse = 0;
                    }
                    
                    draw(ctx) {
                        ctx.save();
                        ctx.translate(this.x + this.width/2, this.y + this.height/2);
                        
                        // ØªØ£Ø«ÙŠØ± Ø§Ù„ØªÙ‚Ù„ÙŠØ¨
                        if (this.flipProgress < 1) {
                            const scale = Math.abs(this.flipProgress - 0.5) * 2;
                            ctx.scale(scale, 1);
                        }
                        
                        // ØªØ£Ø«ÙŠØ± Ø§Ù„Ù†Ø¨Ø¶ Ù„Ù„Ø¨Ø·Ø§Ù‚Ø§Øª ØºÙŠØ± Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚Ø©
                        if (!this.matched && this.hover) {
                            this.pulse += 0.1;
                            const pulseScale = 1 + Math.sin(this.pulse) * 0.05;
                            ctx.scale(pulseScale, pulseScale);
                        }
                        
                        // Ø®Ù„ÙÙŠØ© Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©
                        if (this.matched) {
                            // Ø¨Ø·Ø§Ù‚Ø© Ù…Ø·Ø§Ø¨Ù‚Ø©
                            const gradient = ctx.createLinearGradient(
                                -this.width/2, -this.height/2,
                                this.width/2, this.height/2
                            );
                            gradient.addColorStop(0, '#4ade80');
                            gradient.addColorStop(1, '#22c55e');
                            ctx.fillStyle = gradient;
                        } else if (this.flipped || this.flipProgress > 0.5) {
                            // Ø¨Ø·Ø§Ù‚Ø© Ù…Ù‚Ù„ÙˆØ¨Ø©
                            ctx.fillStyle = '#ffffff';
                        } else {
                            // Ø¸Ù‡Ø± Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©
                            const gradient = ctx.createLinearGradient(
                                -this.width/2, -this.height/2,
                                this.width/2, this.height/2
                            );
                            gradient.addColorStop(0, '#4361ee');
                            gradient.addColorStop(1, '#3a0ca3');
                            ctx.fillStyle = gradient;
                        }
                        
                        // Ø´ÙƒÙ„ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ù…Ø¹ Ø²ÙˆØ§ÙŠØ§ Ù…Ø¯ÙˆØ±Ø©
                        const radius = 10;
                        ctx.beginPath();
                        ctx.moveTo(-this.width/2 + radius, -this.height/2);
                        ctx.lineTo(this.width/2 - radius, -this.height/2);
                        ctx.quadraticCurveTo(this.width/2, -this.height/2, this.width/2, -this.height/2 + radius);
                        ctx.lineTo(this.width/2, this.height/2 - radius);
                        ctx.quadraticCurveTo(this.width/2, this.height/2, this.width/2 - radius, this.height/2);
                        ctx.lineTo(-this.width/2 + radius, this.height/2);
                        ctx.quadraticCurveTo(-this.width/2, this.height/2, -this.width/2, this.height/2 - radius);
                        ctx.lineTo(-this.width/2, -this.height/2 + radius);
                        ctx.quadraticCurveTo(-this.width/2, -this.height/2, -this.width/2 + radius, -this.height/2);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©
                        ctx.strokeStyle = this.matched ? '#166534' : '#1e293b';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©
                        if (this.flipped || this.flipProgress > 0.5 || this.matched) {
                            // Ù†ÙˆØ¹ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©
                            ctx.fillStyle = '#475569';
                            ctx.font = 'bold 12px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'top';
                            ctx.fillText(
                                this.type === 'letter' ? 'Ø§Ù„Ø­Ø±Ù' : 'Ø§Ù„ÙƒÙ„Ù…Ø©',
                                0, -this.height/2 + 10
                            );
                            
                            // Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
                            ctx.fillStyle = '#1e293b';
                            if (this.type === 'letter') {
                                ctx.font = 'bold 40px Arial';
                                ctx.fillText(this.value, 0, -15);
                            } else {
                                ctx.font = 'bold 16px Arial';
                                this.wrapText(ctx, this.value, this.width - 20).forEach((line, i) => {
                                    ctx.fillText(line, 0, -20 + i * 20);
                                });
                            }
                            
                            // Ø±Ù…Ø² Ø§Ù„ØªØ·Ø§Ø¨Ù‚
                            if (this.matched) {
                                ctx.fillStyle = '#ffffff';
                                ctx.font = 'bold 24px Arial';
                                ctx.fillText('âœ“', 0, this.height/2 - 30);
                            }
                        } else {
                            // Ø¸Ù‡Ø± Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©
                            ctx.fillStyle = '#ffffff';
                            ctx.font = 'bold 24px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('?', 0, 0);
                            
                            // Ù†Ù…Ø· Ø²Ø®Ø±ÙÙŠ
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                            ctx.lineWidth = 1;
                            for (let i = 0; i < 4; i++) {
                                ctx.beginPath();
                                ctx.arc(0, 0, 20 + i * 5, 0, Math.PI * 2);
                                ctx.stroke();
                            }
                        }
                        
                        ctx.restore();
                    }
                    
                    wrapText(ctx, text, maxWidth) {
                        const words = text.split(' ');
                        const lines = [];
                        let currentLine = words[0];
                        
                        for (let i = 1; i < words.length; i++) {
                            const word = words[i];
                            const width = ctx.measureText(currentLine + " " + word).width;
                            if (width < maxWidth) {
                                currentLine += " " + word;
                            } else {
                                lines.push(currentLine);
                                currentLine = word;
                            }
                        }
                        lines.push(currentLine);
                        return lines;
                    }
                    
                    update(deltaTime) {
                        // ØªØ­Ø¯ÙŠØ« ØªØ£Ø«ÙŠØ± Ø§Ù„ØªÙ‚Ù„ÙŠØ¨
                        if (this.flipped && this.flipProgress < 1) {
                            this.flipProgress += this.flipSpeed * deltaTime / 16;
                            if (this.flipProgress > 1) this.flipProgress = 1;
                        } else if (!this.flipped && this.flipProgress > 0) {
                            this.flipProgress -= this.flipSpeed * deltaTime / 16;
                            if (this.flipProgress < 0) this.flipProgress = 0;
                        }
                        
                        // ØªØ­Ø¯ÙŠØ« ØªØ£Ø«ÙŠØ± Ø§Ù„Ù†Ø¨Ø¶
                        if (this.hover && !this.matched) {
                            this.pulse += 0.1;
                        }
                    }
                    
                    contains(x, y) {
                        return x >= this.x && x <= this.x + this.width &&
                               y >= this.y && y <= this.y + this.height;
                    }
                    
                    flip() {
                        this.flipped = !this.flipped;
                        this.gameManager.soundManager.playSound('click');
                    }
                }

                // Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø²ÙˆØ§Ø¬ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª
                const pairs = [];
                const totalPairs = (gameSettings.rows * gameSettings.cols) / 2;
                
                // Ø¥Ø¶Ø§ÙØ© Ø£Ø²ÙˆØ§Ø¬ Ø§Ù„Ø­Ø±Ù ÙˆØ§Ù„ÙƒÙ„Ù…Ø§Øª
                for (let i = 0; i < Math.min(totalPairs, letterData.words.length); i++) {
                    pairs.push({
                        id: i,
                        letter: currentLetter,
                        word: letterData.words[i].word
                    });
                }
                
                // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª
                const cards = [];
                const cardPairs = [];
                
                pairs.forEach(pair => {
                    cardPairs.push(
                        new MemoryCard(0, 0, pair.id, 'letter', pair.letter),
                        new MemoryCard(0, 0, pair.id, 'word', pair.word)
                    );
                });
                
                // Ø®Ù„Ø· Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª ÙˆØªØ¹ÙŠÙŠÙ† Ù…ÙˆØ§Ù‚Ø¹Ù‡Ø§
                this.shuffleArray(cardPairs);
                
                for (let i = 0; i < gameSettings.rows; i++) {
                    for (let j = 0; j < gameSettings.cols; j++) {
                        const index = i * gameSettings.cols + j;
                        if (index < cardPairs.length) {
                            const card = cardPairs[index];
                            card.row = i;
                            card.col = j;
                            card.x = j * (card.width + 10) + (canvas.width - (gameSettings.cols * (card.width + 10) - 10)) / 2;
                            card.y = i * (card.height + 10) + 80;
                            cards.push(card);
                        }
                    }
                }

                // Ø­Ø§Ù„Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©
                let firstCard = null;
                let secondCard = null;
                let canFlip = true;
                let matchedPairs = 0;
                let moves = 0;
                let gameTime = gameSettings.gameTime;
                let lastTime = 0;
                let gameActive = true;
                let score = 0;

                const gameLoop = (timestamp) => {
                    if (!gameActive) return;
                    
                    const deltaTime = timestamp - lastTime;
                    lastTime = timestamp;
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª
                    cards.forEach(card => {
                        card.update(deltaTime);
                        
                        // ØªØ­Ø¯ÙŠØ« ØªØ£Ø«ÙŠØ± Ø§Ù„ØªØ­ÙˆÙŠÙ…
                        card.hover = false;
                    });
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆÙ‚Øª
                    gameTime -= deltaTime / 1000;
                    if (gameTime <= 0) {
                        gameActive = false;
                        this.showGameOver(canvas, ctx, score);
                        return;
                    }
                    
                    // Ø§Ù„Ø±Ø³Ù…
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Ø®Ù„ÙÙŠØ©
                    const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    bgGradient.addColorStop(0, '#f8fafc');
                    bgGradient.addColorStop(1, '#e2e8f0');
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Ø§Ù„Ø¹Ù†ÙˆØ§Ù†
                    ctx.fillStyle = '#1e293b';
                    ctx.font = 'bold 28px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText(`Ù„Ø¹Ø¨Ø© Ø§Ù„Ø°Ø§ÙƒØ±Ø© - Ø§Ù„Ø­Ø±Ù ${currentLetter}`, canvas.width/2, 20);
                    
                    // Ø±Ø³Ù… Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª
                    cards.forEach(card => card.draw(ctx));
                    
                    // Ø±Ø³Ù… Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª
                    this.drawMemoryInfo(ctx, canvas, matchedPairs, pairs.length, moves, gameTime, score);
                    
                    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙÙˆØ²
                    if (matchedPairs === pairs.length) {
                        gameActive = false;
                        score += Math.max(0, Math.floor(gameTime)) * 10;
                        this.showWinScreen(canvas, ctx, score);
                        return;
                    }
                    
                    requestAnimationFrame(gameLoop);
                };

                lastTime = 0;
                requestAnimationFrame(gameLoop);

                // Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙ…Ø¹ÙŠ Ø§Ù„Ù†Ù‚Ø±
                const clickHandler = (e) => {
                    if (!gameActive || !canFlip) return;
                    
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    const clickedCard = cards.find(card => 
                        !card.matched && card.contains(mouseX, mouseY)
                    );
                    
                    if (!clickedCard || clickedCard.flipped) return;
                    
                    // Ø¥Ø¸Ù‡Ø§Ø± ØªØ£Ø«ÙŠØ± Ø§Ù„ØªØ­ÙˆÙŠÙ…
                    clickedCard.hover = true;
                    
                    clickedCard.flip();
                    moves++;
                    
                    if (!firstCard) {
                        firstCard = clickedCard;
                    } else if (!secondCard) {
                        secondCard = clickedCard;
                        canFlip = false;
                        
                        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ·Ø§Ø¨Ù‚
                        setTimeout(() => {
                            if (firstCard.pairId === secondCard.pairId) {
                                // ØªØ·Ø§Ø¨Ù‚ ØµØ­ÙŠØ­
                                firstCard.matched = true;
                                secondCard.matched = true;
                                matchedPairs++;
                                score += 20;
                                
                                this.gameManager.soundManager.playSound('success');
                                this.createExplosion(
                                    firstCard.x + firstCard.width/2,
                                    firstCard.y + firstCard.height/2,
                                    '#4ade80'
                                );
                                this.createExplosion(
                                    secondCard.x + secondCard.width/2,
                                    secondCard.y + secondCard.height/2,
                                    '#4ade80'
                                );
                            } else {
                                // ØªØ·Ø§Ø¨Ù‚ Ø®Ø§Ø·Ø¦
                                firstCard.flip();
                                secondCard.flip();
                                score = Math.max(0, score - 5);
                                this.gameManager.soundManager.playSound('error');
                            }
                            
                            firstCard = null;
                            secondCard = null;
                            canFlip = true;
                        }, 1000);
                    }
                };

                canvas.addEventListener('click', clickHandler);
                this.gameManager.currentClickHandler = clickHandler;

                // Ù„Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„ØªÙŠ ØªØ¹Ù…Ù„ Ø¨Ø§Ù„Ù„Ù…Ø³
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    clickHandler(e.touches[0]);
                });
            }

            // ØªØ­Ø³ÙŠÙ† Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙƒÙ„Ù…Ø§Øª
            initEnhancedWordSearch(ctx, canvas) {
                const currentLetter = this.gameManager.currentLetter;
                const letterData = this.gameManager.letterData;
                
                // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©
                const gameSettings = {
                    gridSize: 12,
                    cellSize: 30,
                    wordCount: 8,
                    gameTime: 120,
                    difficultyFactor: this.gameDifficulty
                };

                // Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ù…Ø­Ø³Ù†Ø©
                class WordSearchGrid {
                    constructor() {
                        this.size = gameSettings.gridSize;
                        this.cellSize = gameSettings.cellSize;
                        this.grid = [];
                        this.words = [];
                        this.foundWords = [];
                        this.selectedCells = [];
                        this.isSelecting = false;
                        this.startCell = null;
                        this.highlightedCells = [];
                        
                        this.initGrid();
                        this.placeWords();
                        this.fillEmptyCells();
                    }
                    
                    initGrid() {
                        for (let i = 0; i < this.size; i++) {
                            this.grid[i] = [];
                            for (let j = 0; j < this.size; j++) {
                                this.grid[i][j] = {
                                    letter: '',
                                    row: i,
                                    col: j,
                                    x: j * this.cellSize + 50,
                                    y: i * this.cellSize + 50,
                                    selected: false,
                                    partOfWord: false,
                                    wordId: -1
                                };
                            }
                        }
                    }
                    
                    placeWords() {
                        const directions = [
                            { dr: 0, dc: 1 },   // Ø£ÙÙ‚ÙŠ
                            { dr: 1, dc: 0 },   // Ø¹Ù…ÙˆØ¯ÙŠ
                            { dr: 1, dc: 1 },   // Ù‚Ø·Ø±ÙŠ
                            { dr: 1, dc: -1 }   // Ù‚Ø·Ø±ÙŠ Ù…Ø¹ÙƒÙˆØ³
                        ];
                        
                        // Ø§Ø®ØªØ± Ø§Ù„ÙƒÙ„Ù…Ø§Øª
                        const availableWords = letterData.words.map(w => w.word.toUpperCase());
                        const wordsToPlace = availableWords.slice(0, Math.min(gameSettings.wordCount, availableWords.length));
                        
                        wordsToPlace.forEach((word, wordId) => {
                            let placed = false;
                            let attempts = 0;
                            
                            while (!placed && attempts < 100) {
                                const direction = directions[Math.floor(Math.random() * directions.length)];
                                const row = Math.floor(Math.random() * this.size);
                                const col = Math.floor(Math.random() * this.size);
                                
                                if (this.canPlaceWord(word, row, col, direction)) {
                                    this.placeWord(word, row, col, direction, wordId);
                                    this.words.push({
                                        id: wordId,
                                        word: word,
                                        row: row,
                                        col: col,
                                        direction: direction,
                                        found: false
                                    });
                                    placed = true;
                                }
                                attempts++;
                            }
                        });
                    }
                    
                    canPlaceWord(word, row, col, direction) {
                        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø¯ÙˆØ¯
                        const endRow = row + direction.dr * (word.length - 1);
                        const endCol = col + direction.dc * (word.length - 1);
                        
                        if (endRow < 0 || endRow >= this.size || endCol < 0 || endCol >= this.size) {
                            return false;
                        }
                        
                        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ¹Ø§Ø±Ø¶
                        for (let i = 0; i < word.length; i++) {
                            const r = row + direction.dr * i;
                            const c = col + direction.dc * i;
                            
                            if (this.grid[r][c].letter !== '' && this.grid[r][c].letter !== word[i]) {
                                return false;
                            }
                        }
                        
                        return true;
                    }
                    
                    placeWord(word, row, col, direction, wordId) {
                        for (let i = 0; i < word.length; i++) {
                            const r = row + direction.dr * i;
                            const c = col + direction.dc * i;
                            
                            this.grid[r][c].letter = word[i];
                            this.grid[r][c].partOfWord = true;
                            this.grid[r][c].wordId = wordId;
                        }
                    }
                    
                    fillEmptyCells() {
                        const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                        for (let i = 0; i < this.size; i++) {
                            for (let j = 0; j < this.size; j++) {
                                if (this.grid[i][j].letter === '') {
                                    this.grid[i][j].letter = letters[Math.floor(Math.random() * letters.length)];
                                }
                            }
                        }
                    }
                    
                    draw(ctx) {
                        // Ø±Ø³Ù… Ø§Ù„Ø®Ù„Ø§ÙŠØ§
                        for (let i = 0; i < this.size; i++) {
                            for (let j = 0; j < this.size; j++) {
                                const cell = this.grid[i][j];
                                
                                // Ø®Ù„ÙÙŠØ© Ø§Ù„Ø®Ù„ÙŠØ©
                                if (cell.selected) {
                                    ctx.fillStyle = '#4cc9f0';
                                } else if (this.highlightedCells.some(c => c.row === i && c.col === j)) {
                                    ctx.fillStyle = '#4ade80';
                                } else {
                                    ctx.fillStyle = cell.partOfWord ? '#f8fafc' : '#ffffff';
                                }
                                
                                ctx.fillRect(cell.x, cell.y, this.cellSize, this.cellSize);
                                
                                // Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø®Ù„ÙŠØ©
                                ctx.strokeStyle = cell.partOfWord ? '#3a0ca3' : '#cbd5e1';
                                ctx.lineWidth = cell.partOfWord ? 2 : 1;
                                ctx.strokeRect(cell.x, cell.y, this.cellSize, this.cellSize);
                                
                                // Ø§Ù„Ø­Ø±Ù
                                ctx.fillStyle = cell.partOfWord ? '#1e293b' : '#475569';
                                ctx.font = 'bold 18px Arial';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(
                                    cell.letter,
                                    cell.x + this.cellSize/2,
                                    cell.y + this.cellSize/2
                                );
                            }
                        }
                        
                        // Ø±Ø³Ù… Ø§Ù„ØªØ­Ø¯ÙŠØ¯
                        if (this.selectedCells.length > 1) {
                            ctx.strokeStyle = '#f72585';
                            ctx.lineWidth = 3;
                            ctx.lineCap = 'round';
                            ctx.beginPath();
                            
                            this.selectedCells.forEach((cell, index) => {
                                const x = cell.x + this.cellSize/2;
                                const y = cell.y + this.cellSize/2;
                                
                                if (index === 0) {
                                    ctx.moveTo(x, y);
                                } else {
                                    ctx.lineTo(x, y);
                                }
                            });
                            
                            ctx.stroke();
                        }
                    }
                    
                    startSelection(row, col) {
                        this.isSelecting = true;
                        this.startCell = this.grid[row][col];
                        this.selectedCells = [this.startCell];
                        this.startCell.selected = true;
                    }
                    
                    updateSelection(row, col) {
                        if (!this.isSelecting || !this.startCell) return;
                        
                        const currentCell = this.grid[row][col];
                        this.selectedCells = this.getCellsBetween(this.startCell, currentCell);
                        
                        // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„ØªØ­Ø¯ÙŠØ¯
                        for (let i = 0; i < this.size; i++) {
                            for (let j = 0; j < this.size; j++) {
                                this.grid[i][j].selected = this.selectedCells.some(
                                    cell => cell.row === i && cell.col === j
                                );
                            }
                        }
                    }
                    
                    endSelection() {
                        if (!this.isSelecting || this.selectedCells.length < 2) {
                            this.clearSelection();
                            return null;
                        }
                        
                        this.isSelecting = false;
                        const selectedWord = this.selectedCells.map(cell => cell.letter).join('');
                        const selectedCellsCopy = [...this.selectedCells];
                        
                        setTimeout(() => this.clearSelection(), 1000);
                        
                        return { word: selectedWord, cells: selectedCellsCopy };
                    }
                    
                    clearSelection() {
                        this.isSelecting = false;
                        this.startCell = null;
                        this.selectedCells = [];
                        
                        for (let i = 0; i < this.size; i++) {
                            for (let j = 0; j < this.size; j++) {
                                this.grid[i][j].selected = false;
                            }
                        }
                    }
                    
                    getCellsBetween(startCell, endCell) {
                        const cells = [startCell];
                        
                        const rowDiff = endCell.row - startCell.row;
                        const colDiff = endCell.col - startCell.col;
                        
                        // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø®Ù„Ø§ÙŠØ§ Ø¹Ù„Ù‰ Ø®Ø· Ù…Ø³ØªÙ‚ÙŠÙ…
                        if (rowDiff !== 0 && colDiff !== 0 && Math.abs(rowDiff) !== Math.abs(colDiff)) {
                            return cells;
                        }
                        
                        const rowStep = rowDiff === 0 ? 0 : rowDiff / Math.abs(rowDiff);
                        const colStep = colDiff === 0 ? 0 : colDiff / Math.abs(colDiff);
                        
                        let currentRow = startCell.row + rowStep;
                        let currentCol = startCell.col + colStep;
                        
                        while ((rowStep === 0 || (rowStep > 0 ? currentRow <= endCell.row : currentRow >= endCell.row)) &&
                               (colStep === 0 || (colStep > 0 ? currentCol <= endCell.col : currentCol >= endCell.col))) {
                            
                            const cell = this.grid[currentRow][currentCol];
                            if (cell) {
                                cells.push(cell);
                            }
                            
                            currentRow += rowStep;
                            currentCol += colStep;
                        }
                        
                        return cells;
                    }
                    
                    checkWord(selectedWord, selectedCells) {
                        for (const word of this.words) {
                            if (!word.found && selectedWord === word.word) {
                                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ø®Ù„Ø§ÙŠØ§ Ø§Ù„Ù…Ø­Ø¯Ø¯Ø© ØªØ·Ø§Ø¨Ù‚ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„ÙƒÙ„Ù…Ø©
                                const cellsMatch = this.checkCellsMatchWord(selectedCells, word);
                                if (cellsMatch) {
                                    word.found = true;
                                    this.highlightedCells.push(...selectedCells);
                                    return { success: true, word: word };
                                }
                            }
                        }
                        return { success: false };
                    }
                    
                    checkCellsMatchWord(selectedCells, word) {
                        if (selectedCells.length !== word.word.length) return false;
                        
                        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØªØ¬Ø§Ù‡
                        const firstCell = selectedCells[0];
                        const lastCell = selectedCells[selectedCells.length - 1];
                        
                        const rowDiff = lastCell.row - firstCell.row;
                        const colDiff = lastCell.col - firstCell.col;
                        
                        const expectedRowStep = word.direction.dr;
                        const expectedColStep = word.direction.dc;
                        
                        const actualRowStep = rowDiff === 0 ? 0 : rowDiff / Math.abs(rowDiff);
                        const actualColStep = colDiff === 0 ? 0 : colDiff / Math.abs(colDiff);
                        
                        return actualRowStep === expectedRowStep && actualColStep === expectedColStep;
                    }
                    
                    allWordsFound() {
                        return this.words.every(word => word.found);
                    }
                }

                // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø´Ø¨ÙƒØ©
                const grid = new WordSearchGrid();
                
                // Ø­Ø§Ù„Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©
                let score = 0;
                let gameTime = gameSettings.gameTime;
                let lastTime = 0;
                let gameActive = true;
                let hintTime = 10000; // ØªÙ„Ù…ÙŠØ­ ÙƒÙ„ 10 Ø«ÙˆØ§Ù†ÙŠ
                let lastHintTime = 0;

                const gameLoop = (timestamp) => {
                    if (!gameActive) return;
                    
                    const deltaTime = timestamp - lastTime;
                    lastTime = timestamp;
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆÙ‚Øª
                    gameTime -= deltaTime / 1000;
                    if (gameTime <= 0) {
                        gameActive = false;
                        this.showGameOver(canvas, ctx, score);
                        return;
                    }
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ„Ù…ÙŠØ­Ø§Øª
                    hintTime -= deltaTime;
                    if (hintTime <= 0) {
                        this.showHint(grid);
                        hintTime = 10000;
                        lastHintTime = timestamp;
                    }
                    
                    // Ø§Ù„Ø±Ø³Ù…
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Ø®Ù„ÙÙŠØ©
                    const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    bgGradient.addColorStop(0, '#f1f5f9');
                    bgGradient.addColorStop(1, '#e2e8f0');
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Ø§Ù„Ø¹Ù†ÙˆØ§Ù†
                    ctx.fillStyle = '#1e293b';
                    ctx.font = 'bold 28px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText(`Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ÙƒÙ„Ù…Ø§Øª - Ø§Ù„Ø­Ø±Ù ${currentLetter}`, canvas.width/2, 15);
                    
                    // Ø±Ø³Ù… Ø§Ù„Ø´Ø¨ÙƒØ©
                    grid.draw(ctx);
                    
                    // Ø±Ø³Ù… Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙƒÙ„Ù…Ø§Øª
                    this.drawWordList(ctx, canvas, grid.words);
                    
                    // Ø±Ø³Ù… Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª
                    this.drawWordSearchInfo(ctx, canvas, score, gameTime, 
                                          grid.words.filter(w => w.found).length,
                                          grid.words.length);
                    
                    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙÙˆØ²
                    if (grid.allWordsFound()) {
                        gameActive = false;
                        score += Math.max(0, Math.floor(gameTime)) * 5;
                        this.showWinScreen(canvas, ctx, score);
                        return;
                    }
                    
                    requestAnimationFrame(gameLoop);
                };

                lastTime = 0;
                requestAnimationFrame(gameLoop);

                // Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙ…Ø¹ÙŠ Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
                this.setupWordSearchControls(grid);
            }

            setupWordSearchControls(grid) {
                let isMouseDown = false;
                
                const getCellFromMouse = (x, y) => {
                    for (let i = 0; i < grid.size; i++) {
                        for (let j = 0; j < grid.size; j++) {
                            const cell = grid.grid[i][j];
                            if (x >= cell.x && x <= cell.x + grid.cellSize &&
                                y >= cell.y && y <= cell.y + grid.cellSize) {
                                return { row: i, col: j };
                            }
                        }
                    }
                    return null;
                };
                
                const mouseDownHandler = (e) => {
                    if (!this.gameManager.gameActive) return;
                    
                    const rect = this.gameManager.gameCanvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    const cellPos = getCellFromMouse(mouseX, mouseY);
                    if (cellPos) {
                        isMouseDown = true;
                        grid.startSelection(cellPos.row, cellPos.col);
                    }
                };
                
                const mouseMoveHandler = (e) => {
                    if (!isMouseDown || !this.gameManager.gameActive) return;
                    
                    const rect = this.gameManager.gameCanvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    const cellPos = getCellFromMouse(mouseX, mouseY);
                    if (cellPos) {
                        grid.updateSelection(cellPos.row, cellPos.col);
                    }
                };
                
                const mouseUpHandler = (e) => {
                    if (!isMouseDown || !this.gameManager.gameActive) return;
                    
                    isMouseDown = false;
                    const selection = grid.endSelection();
                    
                    if (selection) {
                        const result = grid.checkWord(selection.word, selection.cells);
                        
                        if (result.success) {
                            score += 15;
                            this.gameManager.gameScore += 15;
                            this.gameManager.soundManager.playSound('success');
                            
                            // ØªØ£Ø«ÙŠØ±Ø§Øª Ù„Ù„Ø®Ù„Ø§ÙŠØ§ Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙ„Ù…Ø©
                            selection.cells.forEach(cell => {
                                this.createExplosion(
                                    cell.x + grid.cellSize/2,
                                    cell.y + grid.cellSize/2,
                                    '#4ade80'
                                );
                            });
                        } else {
                            this.gameManager.soundManager.playSound('error');
                            score = Math.max(0, score - 5);
                        }
                    }
                };
                
                const canvas = this.gameManager.gameCanvas;
                canvas.addEventListener('mousedown', mouseDownHandler);
                canvas.addEventListener('mousemove', mouseMoveHandler);
                canvas.addEventListener('mouseup', mouseUpHandler);
                
                // Ù„Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„ØªÙŠ ØªØ¹Ù…Ù„ Ø¨Ø§Ù„Ù„Ù…Ø³
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    mouseDownHandler(e.touches[0]);
                });
                
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    mouseMoveHandler(e.touches[0]);
                });
                
                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    mouseUpHandler(e.changedTouches[0]);
                });
                
                this.gameManager.currentMouseHandlers = {
                    mousedown: mouseDownHandler,
                    mousemove: mouseMoveHandler,
                    mouseup: mouseUpHandler
                };
            }

            // ØªØ­Ø³ÙŠÙ† Ù„Ø¹Ø¨Ø© Ø§Ù„ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø³Ø±ÙŠØ¹Ø©
            initEnhancedTyping(ctx, canvas) {
                const currentLetter = this.gameManager.currentLetter;
                const letterData = this.gameManager.letterData;
                
                // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©
                const gameSettings = {
                    wordSpeed: 1,
                    wordSpawnRate: 2000,
                    gameTime: 90,
                    targetScore: 60,
                    difficultyFactor: this.gameDifficulty
                };

                // Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø­Ø³Ù†Ø©
                class FallingWord {
                    constructor() {
                        this.word = this.getRandomWord();
                        this.x = Math.random() * (canvas.width - 200) + 100;
                        this.y = -50;
                        this.speed = gameSettings.wordSpeed + Math.random() * 1.5;
                        this.typed = '';
                        this.completed = false;
                        this.wobble = Math.random() * Math.PI * 2;
                        this.wobbleSpeed = 0.05;
                        this.pulse = 0;
                        this.pulseSpeed = 0.1;
                        this.glow = 0;
                        this.glowSpeed = 0.2;
                    }
                    
                    getRandomWord() {
                        const words = letterData.words.map(w => w.word);
                        return words[Math.floor(Math.random() * words.length)];
                    }
                    
                    draw(ctx) {
                        ctx.save();
                        
                        // Ø­Ø±ÙƒØ© Ø§Ù„ØªÙ…Ø§ÙŠÙ„
                        const wobbleOffset = Math.sin(this.wobble) * 3;
                        const pulseScale = 1 + Math.sin(this.pulse) * 0.1;
                        const glowAlpha = 0.3 + Math.sin(this.glow) * 0.2;
                        
                        ctx.translate(this.x, this.y + wobbleOffset);
                        ctx.scale(pulseScale, pulseScale);
                        
                        // ØªØ£Ø«ÙŠØ± Ø§Ù„ØªÙˆÙ‡Ø¬ Ù„Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©
                        if (this.completed) {
                            ctx.shadowColor = '#4ade80';
                            ctx.shadowBlur = 20;
                        }
                        
                        // Ø®Ù„ÙÙŠØ© Ø§Ù„ÙƒÙ„Ù…Ø©
                        const gradient = ctx.createLinearGradient(-100, -30, 100, 30);
                        
                        if (this.completed) {
                            gradient.addColorStop(0, '#4ade80');
                            gradient.addColorStop(1, '#22c55e');
                        } else if (this.typed.length > 0) {
                            gradient.addColorStop(0, '#4cc9f0');
                            gradient.addColorStop(1, '#4361ee');
                        } else {
                            gradient.addColorStop(0, '#f72585');
                            gradient.addColorStop(1, '#d946ef');
                        }
                        
                        ctx.fillStyle = gradient;
                        
                        // Ø´ÙƒÙ„ Ø§Ù„ÙƒÙ„Ù…Ø© Ù…Ø¹ Ø²ÙˆØ§ÙŠØ§ Ù…Ø¯ÙˆØ±Ø©
                        const width = ctx.measureText(this.word).width + 40;
                        const height = 50;
                        const radius = 15;
                        
                        ctx.beginPath();
                        ctx.moveTo(-width/2 + radius, -height/2);
                        ctx.lineTo(width/2 - radius, -height/2);
                        ctx.quadraticCurveTo(width/2, -height/2, width/2, -height/2 + radius);
                        ctx.lineTo(width/2, height/2 - radius);
                        ctx.quadraticCurveTo(width/2, height/2, width/2 - radius, height/2);
                        ctx.lineTo(-width/2 + radius, height/2);
                        ctx.quadraticCurveTo(-width/2, height/2, -width/2, height/2 - radius);
                        ctx.lineTo(-width/2, -height/2 + radius);
                        ctx.quadraticCurveTo(-width/2, -height/2, -width/2 + radius, -height/2);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Ø­Ø¯ÙˆØ¯ Ø§Ù„ÙƒÙ„Ù…Ø©
                        ctx.strokeStyle = this.completed ? '#166534' : '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Ø§Ù„ÙƒÙ„Ù…Ø©
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 24px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        // Ø¹Ø±Ø¶ Ø§Ù„ÙƒÙ„Ù…Ø© Ù…Ø¹ Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ù…Ø·Ø¨ÙˆØ¹ Ù…Ù„ÙˆÙ†
                        const wordText = this.word;
                        const typedText = this.typed;
                        
                        // Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ù…Ø·Ø¨ÙˆØ¹
                        if (typedText.length > 0) {
                            ctx.fillStyle = '#4cc9f0';
                            ctx.fillText(typedText, 0, 0);
                            
                            // Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ
                            const remainingText = wordText.substring(typedText.length);
                            const typedWidth = ctx.measureText(typedText).width;
                            
                            ctx.fillStyle = '#ffffff';
                            ctx.fillText(remainingText, typedWidth/2, 0);
                        } else {
                            ctx.fillText(wordText, 0, 0);
                        }
                        
                        // Ù…Ø¤Ø´Ø± Ø§Ù„ÙƒØªØ§Ø¨Ø©
                        if (!this.completed && typedText.length < wordText.length) {
                            const typedWidth = ctx.measureText(typedText).width;
                            const charWidth = ctx.measureText(wordText[typedText.length]).width;
                            
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(
                                typedWidth - charWidth/2,
                                -10,
                                3,
                                20
                            );
                        }
                        
                        ctx.restore();
                    }
                    
                    update(deltaTime) {
                        this.wobble += this.wobbleSpeed;
                        this.pulse += this.pulseSpeed;
                        this.glow += this.glowSpeed;
                        
                        this.y += this.speed;
                        
                        return this.y > canvas.height;
                    }
                    
                    typeCharacter(char) {
                        if (this.completed) return false;
                        
                        const expectedChar = this.word[this.typed.length].toLowerCase();
                        if (char.toLowerCase() === expectedChar) {
                            this.typed += this.word[this.typed.length];
                            
                            if (this.typed === this.word) {
                                this.completed = true;
                                return 'completed';
                            }
                            return 'correct';
                        }
                        return 'incorrect';
                    }
                }

                // Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù†Ø´Ø·Ø©
                const fallingWords = [];
                let score = 0;
                let gameTime = gameSettings.gameTime;
                let lastTime = 0;
                let lastSpawnTime = 0;
                let gameActive = true;
                let combo = 0;
                let lastCorrectTime = 0;
                let currentInput = '';

                const gameLoop = (timestamp) => {
                    if (!gameActive) return;
                    
                    const deltaTime = timestamp - lastTime;
                    lastTime = timestamp;
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆÙ‚Øª
                    gameTime -= deltaTime / 1000;
                    if (gameTime <= 0) {
                        gameActive = false;
                        this.showGameOver(canvas, ctx, score);
                        return;
                    }
                    
                    // Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙ„Ù…Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©
                    if (timestamp - lastSpawnTime > gameSettings.wordSpawnRate - (this.gameDifficulty * 200)) {
                        fallingWords.push(new FallingWord());
                        lastSpawnTime = timestamp;
                    }
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙƒÙ„Ù…Ø§Øª
                    fallingWords.forEach((word, index) => {
                        const shouldRemove = word.update(deltaTime);
                        
                        if (shouldRemove) {
                            if (!word.completed) {
                                // Ø¹Ù‚ÙˆØ¨Ø© Ù„ÙÙ‚Ø¯Ø§Ù† Ø§Ù„ÙƒÙ„Ù…Ø©
                                combo = 0;
                                score = Math.max(0, score - 5);
                            }
                            fallingWords.splice(index, 1);
                        }
                    });
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙƒÙˆÙ…Ø¨Ùˆ
                    if (timestamp - lastCorrectTime > 2000) {
                        combo = 0;
                    }
                    
                    // Ø§Ù„Ø±Ø³Ù…
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Ø®Ù„ÙÙŠØ©
                    const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    bgGradient.addColorStop(0, '#0f172a');
                    bgGradient.addColorStop(1, '#1e293b');
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Ø§Ù„Ù†Ø¬ÙˆÙ… Ø§Ù„Ø®Ù„ÙÙŠØ©
                    ctx.fillStyle = '#ffffff';
                    for (let i = 0; i < 50; i++) {
                        const alpha = 0.1 + Math.random() * 0.3;
                        const size = 1 + Math.random() * 2;
                        const x = Math.random() * canvas.width;
                        const y = (Math.random() * canvas.height + timestamp/100) % canvas.height;
                        
                        ctx.globalAlpha = alpha;
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                    
                    // Ø±Ø³Ù… Ø§Ù„ÙƒÙ„Ù…Ø§Øª
                    fallingWords.forEach(word => word.draw(ctx));
                    
                    // Ø±Ø³Ù… Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª
                    this.drawTypingInfo(ctx, canvas, score, gameTime, combo, currentInput);
                    
                    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙÙˆØ²
                    if (score >= gameSettings.targetScore) {
                        gameActive = false;
                        this.showWinScreen(canvas, ctx, score);
                        return;
                    }
                    
                    requestAnimationFrame(gameLoop);
                };

                lastTime = 0;
                requestAnimationFrame(gameLoop);

                // Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙ…Ø¹ÙŠ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
                const keyHandler = (e) => {
                    if (!gameActive) return;
                    
                    if (e.key.length === 1 && e.key.match(/[a-zA-Z]/)) {
                        currentInput += e.key;
                        
                        let typedAny = false;
                        fallingWords.forEach(word => {
                            const result = word.typeCharacter(e.key);
                            
                            if (result === 'correct' || result === 'completed') {
                                typedAny = true;
                                this.gameManager.soundManager.playSound('click');
                                
                                if (result === 'completed') {
                                    score += 10 + combo * 2;
                                    this.gameManager.gameScore += 10 + combo * 2;
                                    this.gameManager.soundManager.playSound('success');
                                    this.createExplosion(word.x, word.y, '#4ade80');
                                    combo++;
                                    lastCorrectTime = Date.now();
                                    currentInput = '';
                                }
                            }
                        });
                        
                        if (!typedAny) {
                            this.gameManager.soundManager.playSound('error');
                            combo = 0;
                            currentInput = '';
                        }
                    } else if (e.key === 'Backspace') {
                        currentInput = currentInput.slice(0, -1);
                    } else if (e.key === 'Escape') {
                        currentInput = '';
                    }
                };

                document.addEventListener('keydown', keyHandler);
                this.gameManager.currentKeyHandler = keyHandler;
            }

            // ØªØ­Ø³ÙŠÙ† Ù„Ø¹Ø¨Ø© Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚Ø©
            initEnhancedMatch(ctx, canvas) {
                const currentLetter = this.gameManager.currentLetter;
                const letterData = this.gameManager.letterData;
                
                // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©
                const gameSettings = {
                    itemCount: 6,
                    gameTime: 90,
                    targetScore: 50,
                    difficultyFactor: this.gameDifficulty
                };

                // Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…Ø­Ø³Ù†Ø©
                class MatchItem {
                    constructor(id, type, value, translation, x, y) {
                        this.id = id;
                        this.type = type; // 'letter' Ø£Ùˆ 'word'
                        this.value = value;
                        this.translation = translation;
                        this.x = x;
                        this.y = y;
                        this.width = type === 'letter' ? 80 : 160;
                        this.height = 60;
                        this.dragging = false;
                        this.matched = false;
                        this.targetX = x;
                        this.targetY = y;
                        this.speed = 5;
                        this.wobble = Math.random() * Math.PI * 2;
                        this.wobbleSpeed = 0.05;
                        this.hover = false;
                        this.returning = false;
                    }
                    
                    draw(ctx) {
                        ctx.save();
                        
                        // Ø­Ø±ÙƒØ© Ø§Ù„ØªÙ…Ø§ÙŠÙ„
                        const wobbleOffset = this.dragging ? 0 : Math.sin(this.wobble) * 3;
                        
                        ctx.translate(this.x, this.y + wobbleOffset);
                        
                        // ØªØ£Ø«ÙŠØ± Ø§Ù„Ø³Ø­Ø¨
                        if (this.dragging) {
                            ctx.shadowColor = '#4cc9f0';
                            ctx.shadowBlur = 20;
                            ctx.globalAlpha = 0.9;
                        }
                        
                        // ØªØ£Ø«ÙŠØ± Ø§Ù„ØªØ­ÙˆÙŠÙ…
                        if (this.hover && !this.dragging && !this.matched) {
                            ctx.scale(1.05, 1.05);
                        }
                        
                        // ØªØ£Ø«ÙŠØ± Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚Ø©
                        if (this.matched) {
                            ctx.globalAlpha = 0.7;
                        }
                        
                        // Ø®Ù„ÙÙŠØ© Ø§Ù„Ø¹Ù†ØµØ±
                        const gradient = ctx.createLinearGradient(
                            -this.width/2, -this.height/2,
                            this.width/2, this.height/2
                        );
                        
                        if (this.matched) {
                            gradient.addColorStop(0, '#4ade80');
                            gradient.addColorStop(1, '#22c55e');
                        } else if (this.type === 'letter') {
                            gradient.addColorStop(0, '#4361ee');
                            gradient.addColorStop(1, '#3a0ca3');
                        } else {
                            gradient.addColorStop(0, '#f72585');
                            gradient.addColorStop(1, '#d946ef');
                        }
                        
                        ctx.fillStyle = gradient;
                        
                        // Ø´ÙƒÙ„ Ø§Ù„Ø¹Ù†ØµØ± Ù…Ø¹ Ø²ÙˆØ§ÙŠØ§ Ù…Ø¯ÙˆØ±Ø©
                        const radius = 10;
                        ctx.beginPath();
                        ctx.moveTo(-this.width/2 + radius, -this.height/2);
                        ctx.lineTo(this.width/2 - radius, -this.height/2);
                        ctx.quadraticCurveTo(this.width/2, -this.height/2, this.width/2, -this.height/2 + radius);
                        ctx.lineTo(this.width/2, this.height/2 - radius);
                        ctx.quadraticCurveTo(this.width/2, this.height/2, this.width/2 - radius, this.height/2);
                        ctx.lineTo(-this.width/2 + radius, this.height/2);
                        ctx.quadraticCurveTo(-this.width/2, this.height/2, -this.width/2, this.height/2 - radius);
                        ctx.lineTo(-this.width/2, -this.height/2 + radius);
                        ctx.quadraticCurveTo(-this.width/2, -this.height/2, -this.width/2 + radius, -this.height/2);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø¹Ù†ØµØ±
                        ctx.strokeStyle = this.matched ? '#166534' : '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Ø§Ù„Ù…Ø­ØªÙˆÙ‰
                        ctx.fillStyle = '#ffffff';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        if (this.type === 'letter') {
                            ctx.font = 'bold 32px Arial';
                            ctx.fillText(this.value, 0, 0);
                            
                            ctx.font = '12px Arial';
                            ctx.fillText('Ø§Ù„Ø­Ø±Ù', 0, -this.height/2 + 15);
                        } else {
                            ctx.font = 'bold 18px Arial';
                            const lines = this.wrapText(ctx, this.value, this.width - 20);
                            lines.forEach((line, i) => {
                                ctx.fillText(line, 0, -10 + i * 20);
                            });
                            
                            ctx.font = '12px Arial';
                            ctx.fillText(this.translation, 0, this.height/2 - 15);
                        }
                        
                        ctx.restore();
                    }
                    
                    wrapText(ctx, text, maxWidth) {
                        const words = text.split(' ');
                        const lines = [];
                        let currentLine = words[0];
                        
                        for (let i = 1; i < words.length; i++) {
                            const word = words[i];
                            const width = ctx.measureText(currentLine + " " + word).width;
                            if (width < maxWidth) {
                                currentLine += " " + word;
                            } else {
                                lines.push(currentLine);
                                currentLine = word;
                            }
                        }
                        lines.push(currentLine);
                        return lines;
                    }
                    
                    update() {
                        // ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ…Ø§ÙŠÙ„
                        if (!this.dragging) {
                            this.wobble += this.wobbleSpeed;
                        }
                        
                        // Ø§Ù„Ø­Ø±ÙƒØ© Ù†Ø­Ùˆ Ø§Ù„Ù‡Ø¯Ù
                        if (!this.dragging && (this.x !== this.targetX || this.y !== this.targetY)) {
                            const dx = this.targetX - this.x;
                            const dy = this.targetY - this.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < this.speed) {
                                this.x = this.targetX;
                                this.y = this.targetY;
                                this.returning = false;
                            } else {
                                this.x += (dx / distance) * this.speed;
                                this.y += (dy / distance) * this.speed;
                            }
                        }
                    }
                    
                    contains(x, y) {
                        return x >= this.x - this.width/2 && x <= this.x + this.width/2 &&
                               y >= this.y - this.height/2 && y <= this.y + this.height/2;
                    }
                    
                    startDrag(offsetX, offsetY) {
                        this.dragging = true;
                        this.dragOffsetX = offsetX;
                        this.dragOffsetY = offsetY;
                        this.originalX = this.x;
                        this.originalY = this.y;
                    }
                    
                    updateDrag(mouseX, mouseY) {
                        if (this.dragging) {
                            this.x = mouseX - this.dragOffsetX;
                            this.y = mouseY - this.dragOffsetY;
                        }
                    }
                    
                    endDrag() {
                        this.dragging = false;
                        this.returning = true;
                        this.targetX = this.originalX;
                        this.targetY = this.originalY;
                    }
                    
                    snapTo(targetX, targetY) {
                        this.matched = true;
                        this.dragging = false;
                        this.targetX = targetX;
                        this.targetY = targetY;
                    }
                }

                // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø±ÙˆÙ ÙˆØ§Ù„ÙƒÙ„Ù…Ø§Øª
                const letters = [];
                const words = [];
                const matches = [];
                
                for (let i = 0; i < Math.min(gameSettings.itemCount, letterData.words.length); i++) {
                    const wordData = letterData.words[i];
                    
                    // Ø§Ù„Ø­Ø±Ù
                    letters.push(new MatchItem(
                        i,
                        'letter',
                        currentLetter,
                        'Ø§Ù„Ø­Ø±Ù',
                        100,
                        100 + i * 80
                    ));
                    
                    // Ø§Ù„ÙƒÙ„Ù…Ø©
                    words.push(new MatchItem(
                        i,
                        'word',
                        wordData.word,
                        wordData.translation,
                        canvas.width - 200,
                        100 + i * 80
                    ));
                }

                // Ø®Ù„Ø· Ø§Ù„ÙƒÙ„Ù…Ø§Øª
                this.shuffleArray(words);
                
                let score = 0;
                let gameTime = gameSettings.gameTime;
                let lastTime = 0;
                let gameActive = true;
                let draggedItem = null;
                let offsetX = 0, offsetY = 0;

                const gameLoop = (timestamp) => {
                    if (!gameActive) return;
                    
                    const deltaTime = timestamp - lastTime;
                    lastTime = timestamp;
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆÙ‚Øª
                    gameTime -= deltaTime / 1000;
                    if (gameTime <= 0) {
                        gameActive = false;
                        this.showGameOver(canvas, ctx, score);
                        return;
                    }
                    
                    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¹Ù†Ø§ØµØ±
                    letters.forEach(letter => letter.update());
                    words.forEach(word => word.update());
                    
                    // ØªØ­Ø¯ÙŠØ« Ø®Ø·ÙˆØ· Ø§Ù„ØªÙˆØµÙŠÙ„
                    matches.forEach(match => {
                        // Ø®Ø·ÙˆØ· Ø§Ù„ØªÙˆØµÙŠÙ„ ØªØªØ¨Ø¹ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚Ø©
                        const letter = letters.find(l => l.id === match.letterId);
                        const word = words.find(w => w.id === match.wordId);
                        
                        if (letter && word) {
                            match.fromX = letter.x;
                            match.fromY = letter.y;
                            match.toX = word.x;
                            match.toY = word.y;
                        }
                    });
                    
                    // Ø§Ù„Ø±Ø³Ù…
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Ø®Ù„ÙÙŠØ©
                    const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    bgGradient.addColorStop(0, '#f8fafc');
                    bgGradient.addColorStop(1, '#e2e8f0');
                    ctx.fillStyle = bgGradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Ø§Ù„Ø¹Ù†ÙˆØ§Ù†
                    ctx.fillStyle = '#1e293b';
                    ctx.font = 'bold 28px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText(`Ù„Ø¹Ø¨Ø© Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚Ø© - Ø§Ù„Ø­Ø±Ù ${currentLetter}`, canvas.width/2, 15);
                    
                    // ØªØ¹Ù„ÙŠÙ…Ø§Øª
                    ctx.fillStyle = '#475569';
                    ctx.font = '16px Arial';
                    ctx.fillText('Ø§Ø³Ø­Ø¨ Ø§Ù„Ø­Ø±Ù Ø¥Ù„Ù‰ Ø§Ù„ÙƒÙ„Ù…Ø© Ø§Ù„ØªÙŠ ØªØ¨Ø¯Ø£ Ø¨Ù‡', canvas.width/2, 50);
                    
                    // Ø±Ø³Ù… Ø®Ø·ÙˆØ· Ø§Ù„ØªÙˆØµÙŠÙ„
                    ctx.strokeStyle = '#4cc9f0';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    matches.forEach(match => {
                        ctx.beginPath();
                        ctx.moveTo(match.fromX, match.fromY);
                        ctx.lineTo(match.toX, match.toY);
                        ctx.stroke();
                    });
                    
                    // Ø±Ø³Ù… Ø§Ù„ÙƒÙ„Ù…Ø§Øª
                    words.forEach(word => word.draw(ctx));
                    
                    // Ø±Ø³Ù… Ø§Ù„Ø­Ø±ÙˆÙ
                    letters.forEach(letter => letter.draw(ctx));
                    
                    // Ø±Ø³Ù… Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª
                    this.drawMatchInfo(ctx, canvas, score, gameTime, matches.length, letters.length);
                    
                    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙÙˆØ²
                    if (matches.length === letters.length) {
                        gameActive = false;
                        score += Math.max(0, Math.floor(gameTime)) * 10;
                        this.showWinScreen(canvas, ctx, score);
                        return;
                    }
                    
                    requestAnimationFrame(gameLoop);
                };

                lastTime = 0;
                requestAnimationFrame(gameLoop);

                // Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙ…Ø¹ÙŠ Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
                this.setupMatchControls(letters, words, matches);
            }

            setupMatchControls(letters, words, matches) {
                let draggedItem = null;
                let offsetX = 0, offsetY = 0;
                
                const mouseDownHandler = (e) => {
                    if (!this.gameManager.gameActive) return;
                    
                    const rect = this.gameManager.gameCanvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø­Ø±Ù ØºÙŠØ± Ù…Ø·Ø§Ø¨Ù‚ ÙŠØªÙ… Ø³Ø­Ø¨Ù‡
                    for (const letter of letters) {
                        if (!letter.matched && letter.contains(mouseX, mouseY)) {
                            draggedItem = letter;
                            offsetX = mouseX - letter.x;
                            offsetY = mouseY - letter.y;
                            draggedItem.startDrag(offsetX, offsetY);
                            this.gameManager.soundManager.playSound('click');
                            break;
                        }
                    }
                };
                
                const mouseMoveHandler = (e) => {
                    if (!draggedItem) return;
                    
                    const rect = this.gameManager.gameCanvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    draggedItem.updateDrag(mouseX, mouseY);
                    
                    // ØªØ­Ø¯ÙŠØ« ØªØ£Ø«ÙŠØ± Ø§Ù„ØªØ­ÙˆÙŠÙ… Ù„Ù„ÙƒÙ„Ù…Ø§Øª
                    words.forEach(word => {
                        word.hover = !word.matched && word.contains(mouseX, mouseY);
                    });
                };
                
                const mouseUpHandler = (e) => {
                    if (!draggedItem) return;
                    
                    const rect = this.gameManager.gameCanvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† ØªØ·Ø§Ø¨Ù‚
                    let matchedWord = null;
                    for (const word of words) {
                        if (!word.matched && word.contains(mouseX, mouseY)) {
                            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„ÙƒÙ„Ù…Ø© ØªØ¨Ø¯Ø£ Ø¨Ø§Ù„Ø­Ø±Ù
                            if (word.value.startsWith(draggedItem.value)) {
                                matchedWord = word;
                                break;
                            }
                        }
                    }
                    
                    if (matchedWord) {
                        // ØªØ·Ø§Ø¨Ù‚ Ù†Ø§Ø¬Ø­
                        draggedItem.snapTo(matchedWord.x - 120, matchedWord.y);
                        matchedWord.matched = true;
                        
                        // Ø¥Ø¶Ø§ÙØ© Ø®Ø· Ù„Ù„ØªÙˆØµÙŠÙ„
                        matches.push({
                            letterId: draggedItem.id,
                            wordId: matchedWord.id,
                            fromX: draggedItem.x,
                            fromY: draggedItem.y,
                            toX: matchedWord.x,
                            toY: matchedWord.y
                        });
                        
                        score += 10;
                        this.gameManager.gameScore += 10;
                        this.gameManager.soundManager.playSound('success');
                        this.createExplosion(draggedItem.x, draggedItem.y, '#4ade80');
                        this.createExplosion(matchedWord.x, matchedWord.y, '#4ade80');
                    } else {
                        // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø­Ø±Ù Ù„Ù…ÙƒØ§Ù†Ù‡
                        draggedItem.endDrag();
                        this.gameManager.soundManager.playSound('error');
                    }
                    
                    draggedItem = null;
                };
                
                const canvas = this.gameManager.gameCanvas;
                canvas.addEventListener('mousedown', mouseDownHandler);
                canvas.addEventListener('mousemove', mouseMoveHandler);
                canvas.addEventListener('mouseup', mouseUpHandler);
                
                // Ù„Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„ØªÙŠ ØªØ¹Ù…Ù„ Ø¨Ø§Ù„Ù„Ù…Ø³
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    mouseDownHandler(e.touches[0]);
                });
                
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    mouseMoveHandler(e.touches[0]);
                });
                
                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    mouseUpHandler(e.changedTouches[0]);
                });
                
                this.gameManager.currentMouseHandlers = {
                    mousedown: mouseDownHandler,
                    mousemove: mouseMoveHandler,
                    mouseup: mouseUpHandler
                };
            }

            // ============ Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© ============
            
            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
            
            addCombo() {
                this.combo++;
                if (this.comboTimer) clearTimeout(this.comboTimer);
                this.comboTimer = setTimeout(() => {
                    this.combo = 0;
                }, 3000);
            }
            
            createExplosion(x, y, color) {
                for (let i = 0; i < 15; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 3;
                    const size = 3 + Math.random() * 4;
                    const life = 0.5 + Math.random() * 0.5;
                    
                    this.effects.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: size,
                        color: color,
                        life: life,
                        maxLife: life
                    });
                }
            }
            
            updateEffects(deltaTime) {
                for (let i = this.effects.length - 1; i >= 0; i--) {
                    const effect = this.effects[i];
                    effect.x += effect.vx;
                    effect.y += effect.vy;
                    effect.life -= deltaTime / 1000;
                    
                    if (effect.life <= 0) {
                        this.effects.splice(i, 1);
                    }
                }
            }
            
            drawEffects(ctx) {
                this.effects.forEach(effect => {
                    const alpha = effect.life / effect.maxLife;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = effect.color;
                    ctx.beginPath();
                    ctx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
            }
            
            showHint(grid) {
                // Ø¥Ø¸Ù‡Ø§Ø± ØªÙ„Ù…ÙŠØ­ Ù„Ù„ÙƒÙ„Ù…Ø§Øª ØºÙŠØ± Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©
                const unfoundWords = grid.words.filter(word => !word.found);
                if (unfoundWords.length > 0) {
                    const randomWord = unfoundWords[Math.floor(Math.random() * unfoundWords.length)];
                    const cells = [];
                    
                    for (let i = 0; i < randomWord.word.length; i++) {
                        const r = randomWord.row + randomWord.direction.dr * i;
                        const c = randomWord.col + randomWord.direction.dc * i;
                        cells.push(grid.grid[r][c]);
                    }
                    
                    // ÙˆÙ…ÙŠØ¶ Ø§Ù„Ø®Ù„Ø§ÙŠØ§
                    cells.forEach(cell => {
                        cell.highlighted = true;
                        setTimeout(() => {
                            cell.highlighted = false;
                        }, 1000);
                    });
                }
            }
            
            drawGameInfo(ctx, canvas, score, lives, nitro, shield) {
                // Ø§Ù„Ù†Ù‚Ø§Ø·
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(`Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`, 20, 20);
                
                // Ø§Ù„ÙˆÙ‚Øª
                ctx.textAlign = 'right';
                ctx.fillText(`Ø§Ù„ÙˆÙ‚Øª: ${Math.ceil(this.gameManager.gameTimeLeft)}`, canvas.width - 20, 20);
                
                // Ø§Ù„Ø£Ø±ÙˆØ§Ø­
                ctx.textAlign = 'left';
                ctx.fillText(`â¤ï¸ ${lives}`, 20, 50);
                
                // Ø§Ù„Ø¨Ø§ÙˆØ± Ø£Ø¨
                if (nitro) {
                    ctx.fillStyle = '#f59e0b';
                    ctx.fillText('âš¡ Ù†ÙŠØªØ±Ùˆ Ù†Ø´Ø·', 100, 50);
                }
                
                if (shield) {
                    ctx.fillStyle = '#4cc9f0';
                    ctx.fillText('ğŸ›¡ï¸ Ø¯Ø±Ø¹ Ù†Ø´Ø·', 220, 50);
                }
                
                // Ø§Ù„ÙƒÙˆÙ…Ø¨Ùˆ
                if (this.combo > 1) {
                    ctx.fillStyle = '#f72585';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`ÙƒÙˆÙ…Ø¨Ùˆ x${this.combo}!`, canvas.width/2, 20);
                }
            }
            
            drawFishingInfo(ctx, canvas, score, timeLeft, combo) {
                // Ø§Ù„Ù†Ù‚Ø§Ø·
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(`Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`, 20, 20);
                
                // Ø§Ù„ÙˆÙ‚Øª
                const seconds = Math.ceil(timeLeft / 1000);
                ctx.textAlign = 'right';
                ctx.fillText(`Ø§Ù„ÙˆÙ‚Øª: ${seconds}`, canvas.width - 20, 20);
                
                // Ø§Ù„ÙƒÙˆÙ…Ø¨Ùˆ
                if (combo > 1) {
                    ctx.fillStyle = '#f72585';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`ÙƒÙˆÙ…Ø¨Ùˆ ØµÙŠØ¯ x${combo}!`, canvas.width/2, 20);
                }
                
                // Ø§Ù„Ù‡Ø¯Ù
                ctx.fillStyle = '#4cc9f0';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Ø§Ù„Ù‡Ø¯Ù: 30 Ù†Ù‚Ø·Ø©', canvas.width/2, 50);
            }
            
            drawRacketInfo(ctx, canvas, score, lives, timeLeft, combo) {
                // Ø§Ù„Ù†Ù‚Ø§Ø·
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(`Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`, 20, 20);
                
                // Ø§Ù„Ø£Ø±ÙˆØ§Ø­
                ctx.fillText(`â¤ï¸ ${lives}`, 20, 50);
                
                // Ø§Ù„ÙˆÙ‚Øª
                ctx.textAlign = 'right';
                ctx.fillText(`Ø§Ù„ÙˆÙ‚Øª: ${Math.ceil(timeLeft)}`, canvas.width - 20, 20);
                
                // Ø§Ù„ÙƒÙˆÙ…Ø¨Ùˆ
                if (combo > 0) {
                    ctx.fillStyle = '#f72585';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`ÙƒÙˆÙ…Ø¨Ùˆ x${combo}!`, canvas.width/2, 20);
                }
                
                // Ø§Ù„Ù‡Ø¯Ù
                ctx.fillStyle = '#4cc9f0';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Ø§Ù„Ù‡Ø¯Ù: 40 Ù†Ù‚Ø·Ø©', canvas.width/2, 50);
            }
            
            drawBalloonsInfo(ctx, canvas, score, timeLeft, combo) {
                // Ø§Ù„Ù†Ù‚Ø§Ø·
                ctx.fillStyle = '#1e293b';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(`Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`, 20, 20);
                
                // Ø§Ù„ÙˆÙ‚Øª
                ctx.textAlign = 'right';
                ctx.fillText(`Ø§Ù„ÙˆÙ‚Øª: ${Math.ceil(timeLeft)}`, canvas.width - 20, 20);
                
                // Ø§Ù„ÙƒÙˆÙ…Ø¨Ùˆ
                if (combo > 1) {
                    ctx.fillStyle = '#f72585';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`ÙƒÙˆÙ…Ø¨Ùˆ x${combo}!`, canvas.width/2, 20);
                }
                
                // Ø§Ù„Ù‡Ø¯Ù
                ctx.fillStyle = '#3a0ca3';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Ø§Ù„Ù‡Ø¯Ù: 50 Ù†Ù‚Ø·Ø©', canvas.width/2, 50);
            }
            
            drawMemoryInfo(ctx, canvas, matched, total, moves, timeLeft, score) {
                // Ø§Ù„Ø£Ø²ÙˆØ§Ø¬
                ctx.fillStyle = '#1e293b';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(`Ø§Ù„Ø£Ø²ÙˆØ§Ø¬: ${matched}/${total}`, 20, 20);
                
                // Ø§Ù„Ø­Ø±ÙƒØ§Øª
                ctx.fillText(`Ø§Ù„Ø­Ø±ÙƒØ§Øª: ${moves}`, 20, 50);
                
                // Ø§Ù„ÙˆÙ‚Øª
                ctx.textAlign = 'right';
                ctx.fillText(`Ø§Ù„ÙˆÙ‚Øª: ${Math.ceil(timeLeft)}`, canvas.width - 20, 20);
                
                // Ø§Ù„Ù†Ù‚Ø§Ø·
                ctx.fillText(`Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`, canvas.width - 20, 50);
            }
            
            drawWordList(ctx, canvas, words) {
                const startX = 50;
                const startY = canvas.height - 150;
                
                ctx.fillStyle = '#1e293b';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText('Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:', startX, startY);
                
                words.forEach((word, i) => {
                    const status = word.found ? 'âœ…' : 'ğŸ”';
                    const color = word.found ? '#166534' : '#475569';
                    
                    ctx.fillStyle = color;
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText(`${status} ${word.word}`, startX, startY + 30 + i * 25);
                });
            }
            
            drawWordSearchInfo(ctx, canvas, score, timeLeft, found, total) {
                // Ø§Ù„Ù†Ù‚Ø§Ø·
                ctx.fillStyle = '#1e293b';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(`Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`, 20, canvas.height - 80);
                
                // Ø§Ù„ÙƒÙ„Ù…Ø§Øª
                ctx.fillText(`Ø§Ù„ÙƒÙ„Ù…Ø§Øª: ${found}/${total}`, 20, canvas.height - 50);
                
                // Ø§Ù„ÙˆÙ‚Øª
                ctx.textAlign = 'right';
                ctx.fillText(`Ø§Ù„ÙˆÙ‚Øª: ${Math.ceil(timeLeft)}`, canvas.width - 20, canvas.height - 80);
            }
            
            drawTypingInfo(ctx, canvas, score, timeLeft, combo, input) {
                // Ø§Ù„Ù†Ù‚Ø§Ø·
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(`Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`, 20, 20);
                
                // Ø§Ù„ÙˆÙ‚Øª
                ctx.textAlign = 'right';
                ctx.fillText(`Ø§Ù„ÙˆÙ‚Øª: ${Math.ceil(timeLeft)}`, canvas.width - 20, 20);
                
                // Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„
                ctx.textAlign = 'center';
                ctx.fillText(`Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„: ${input}`, canvas.width/2, 50);
                
                // Ø§Ù„ÙƒÙˆÙ…Ø¨Ùˆ
                if (combo > 1) {
                    ctx.fillStyle = '#f72585';
                    ctx.font = 'bold 24px Arial';
                    ctx.fillText(`ÙƒÙˆÙ…Ø¨Ùˆ ÙƒØªØ§Ø¨Ø© x${combo}!`, canvas.width/2, 80);
                }
                
                // Ø§Ù„Ù‡Ø¯Ù
                ctx.fillStyle = '#4cc9f0';
                ctx.font = '16px Arial';
                ctx.fillText('Ø§Ù„Ù‡Ø¯Ù: 60 Ù†Ù‚Ø·Ø©', canvas.width/2, canvas.height - 30);
            }
            
            drawMatchInfo(ctx, canvas, score, timeLeft, matched, total) {
                // Ø§Ù„Ù†Ù‚Ø§Ø·
                ctx.fillStyle = '#1e293b';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(`Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`, 20, canvas.height - 50);
                
                // Ø§Ù„ØªØ·Ø§Ø¨Ù‚Ø§Øª
                ctx.fillText(`Ø§Ù„ØªØ·Ø§Ø¨Ù‚Ø§Øª: ${matched}/${total}`, 20, canvas.height - 80);
                
                // Ø§Ù„ÙˆÙ‚Øª
                ctx.textAlign = 'right';
                ctx.fillText(`Ø§Ù„ÙˆÙ‚Øª: ${Math.ceil(timeLeft)}`, canvas.width - 20, canvas.height - 50);
            }
            
            showGameOver(canvas, ctx, score) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©!', canvas.width/2, canvas.height/2 - 50);
                
                ctx.font = 'bold 28px Arial';
                ctx.fillText(`Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©: ${score}`, canvas.width/2, canvas.height/2);
                
                ctx.font = '24px Arial';
                ctx.fillText('Ø§Ù†Ù‚Ø± Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø¹Ø¨', canvas.width/2, canvas.height/2 + 50);
                
                // Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙ…Ø¹ Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø¹Ø¨
                const restartHandler = () => {
                    this.gameManager.restartGame();
                };
                
                canvas.addEventListener('click', restartHandler);
                this.gameManager.currentRestartHandler = restartHandler;
            }
            
            showWinScreen(canvas, ctx, score) {
                // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©
                this.gameManager.gameScore += score;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ÙÙˆØ²
                const winMessages = [
                    "Ø³Ù„Ù…Øª ÙŠØ§Ø¨Ø·Ù„! ğŸ†",
                    "Ù…Ø°Ù‡Ù„! Ø¥ØªÙ‚Ø§Ù† Ø±Ø§Ø¦Ø¹! â­",
                    "Ø£Ù†Øª Ù†Ø¬Ù… Ø§Ù„Ø­Ø±ÙˆÙ! âœ¨",
                    "ÙÙˆØ² Ù…Ø¯Ù‡Ø´! ğŸ‘‘",
                    "Ø¨Ø±Ø§Ø¹Ø© ÙØ§Ø¦Ù‚Ø©! ğŸ’«"
                ];
                
                const randomMessage = winMessages[Math.floor(Math.random() * winMessages.length)];
                
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(randomMessage, canvas.width/2, canvas.height/2 - 50);
                
                ctx.font = 'bold 28px Arial';
                ctx.fillText(`Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©: ${score}`, canvas.width/2, canvas.height/2);
                
                // ØªØ£Ø«ÙŠØ±Ø§Øª Ø§Ù„ÙÙˆØ²
                this.createFireworks(canvas);
                
                // Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¨Ø¹Ø¯ 3 Ø«ÙˆØ§Ù†ÙŠ
                setTimeout(() => {
                    this.gameManager.showWinModal(score);
                }, 3000);
            }
            
            createFireworks(canvas) {
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => {
                        const x = Math.random() * canvas.width;
                        const y = Math.random() * canvas.height * 0.7;
                        this.createFireworkExplosion(x, y);
                    }, i * 300);
                }
            }
            
            createFireworkExplosion(x, y) {
                const colors = ['#f72585', '#4361ee', '#4cc9f0', '#4ade80', '#f59e0b'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                for (let i = 0; i < 30; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 3 + Math.random() * 4;
                    const size = 4 + Math.random() * 4;
                    const life = 1 + Math.random() * 0.5;
                    
                    this.effects.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: size,
                        color: color,
                        life: life,
                        maxLife: life
                    });
                }
            }
        }

        // ØªØ­Ø¯ÙŠØ« ÙØ¦Ø© PhonicsGameLab Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†Ø¸Ø§Ù… Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨ Ø§Ù„Ù…Ø­Ø³Ù†
        class EnhancedPhonicsGameLab extends PhonicsGameLab {
            constructor() {
                super();
                this.enhancedGameSystem = new EnhancedGameSystem(this);
            }
            
            startGame(gameType) {
                // ... Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚ ÙŠØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡Ùˆ ...
                
                // Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ initGame Ø¨Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ù†Ø¸Ø§Ù… Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨ Ø§Ù„Ù…Ø­Ø³Ù†
                this.enhancedGameSystem.initEnhancedGame(gameType);
            }
            
            initEnhancedGame(gameType) {
                const canvas = this.gameCanvas;
                const ctx = canvas.getContext('2d');
                
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                
                switch(gameType) {
                    case 'carRace':
                        this.enhancedGameSystem.initEnhancedCarRace(ctx, canvas);
                        break;
                    case 'racket':
                        this.enhancedGameSystem.initEnhancedRacket(ctx, canvas);
                        break;
                    case 'fishing':
                        this.enhancedGameSystem.initEnhancedFishing(ctx, canvas);
                        break;
                    case 'balloons':
                        this.enhancedGameSystem.initEnhancedBalloons(ctx, canvas);
                        break;
                    case 'memory':
                        this.enhancedGameSystem.initEnhancedMemory(ctx, canvas);
                        break;
                    case 'wordsearch':
                        this.enhancedGameSystem.initEnhancedWordSearch(ctx, canvas);
                        break;
                    case 'typing':
                        this.enhancedGameSystem.initEnhancedTyping(ctx, canvas);
                        break;
                    case 'match':
                        this.enhancedGameSystem.initEnhancedMatch(ctx, canvas);
                        break;
                    default:
                        this.enhancedGameSystem.initEnhancedCarRace(ctx, canvas);
                }
            }
        }

        // Ø¨Ø¯Ø¡ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…Ø­Ø³Ù†
        document.addEventListener('DOMContentLoaded', () => {
            new EnhancedPhonicsGameLab();
        });
    </script>
</body>
</html>