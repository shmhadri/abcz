<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>ŸÖŸÜÿµÿ© ÿ£ŸÑÿπÿßÿ® ÿßŸÑÿ≠ÿ±ŸàŸÅ ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ© - Phonics Game Lab</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'><rect width='32' height='32' fill='%234361ee' rx='6'/><text x='16' y='22' fill='white' font-size='18' font-weight='bold' text-anchor='middle' font-family='Arial'>A</text></svg>">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <style>
        :root {
            --primary: #4361ee;
            --primary-light: #4895ef;
            --primary-dark: #3a0ca3;
            --secondary: #f72585;
            --accent: #4cc9f0;
            --success: #4ade80;
            --warning: #f59e0b;
            --error: #ef4444;
            --background: #ffffff;
            --surface: #ffffff;
            --surface-light: #f8fafc;
            --text: #1e293b;
            --text-secondary: #475569;
            --border: #e2e8f0;
            --radius-lg: 20px;
            --radius-md: 12px;
            --radius-sm: 8px;
            --shadow: 0 10px 25px rgba(0, 0, 0, 0.08);
            --shadow-light: 0 5px 15px rgba(0, 0, 0, 0.05);
            --gradient-primary: linear-gradient(135deg, var(--primary), var(--primary-light));
            --gradient-accent: linear-gradient(135deg, var(--accent), var(--primary-light));
            --gradient-success: linear-gradient(135deg, var(--success), #22c55e);
            --gradient-surface: linear-gradient(135deg, #ffffff, #f8fafc);
            
            --night-bg: #0f172a;
            --night-surface: #1e293b;
            --night-text: #f1f5f9;
            --night-text-secondary: #cbd5e1;
            --night-border: #475569;
            --night-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }

        .night-mode {
            --background: var(--night-bg);
            --surface: var(--night-surface);
            --surface-light: #334155;
            --text: var(--night-text);
            --text-secondary: var(--night-text-secondary);
            --border: var(--night-border);
            --shadow: var(--night-shadow);
            --shadow-light: 0 5px 15px rgba(0, 0, 0, 0.2);
            --gradient-surface: linear-gradient(135deg, var(--surface), #1e293b);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            touch-action: manipulation;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Touch feedback for buttons */
        button:active, .btn-touch-active, .control-btn:active, .game-card:active {
            transform: scale(0.92);
            transition: transform 0.1s cubic-bezier(0.34, 1.56, 0.64, 1); /* Bouncy effect */
        }

        /* Animation for buttons */
        @keyframes buttonPop {
            0% { transform: scale(0.95); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .btn-animate {
            animation: buttonPop 0.3s ease-out;
        }

        input, textarea {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        body {
            min-height: 100vh;
            background: var(--background);
            font-family: 'Segoe UI', 'Tajawal', Tahoma, Geneva, Verdana, sans-serif;
            color: var(--text);
            line-height: 1.6;
            padding: 20px 15px;
            background-image: 
                radial-gradient(circle at 15% 50%, rgba(67, 97, 238, 0.08) 0%, transparent 40%),
                radial-gradient(circle at 85% 30%, rgba(244, 114, 182, 0.05) 0%, transparent 40%);
            transition: all 0.3s ease;
            font-weight: 600;
            -webkit-tap-highlight-color: transparent;
        }

        .night-mode body {
            background-image: 
                radial-gradient(circle at 15% 50%, rgba(67, 97, 238, 0.15) 0%, transparent 40%),
                radial-gradient(circle at 85% 30%, rgba(244, 114, 182, 0.1) 0%, transparent 40%);
        }

        .app-container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--surface);
            border-radius: var(--radius-lg);
            overflow: hidden;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
            position: relative;
            transition: all 0.3s ease;
        }

        .app-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--gradient-primary);
            z-index: 10;
        }

        /* Header Styles */
        .app-header {
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.95);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .night-mode .app-header {
            background: rgba(30, 41, 59, 0.95);
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo {
            width: 45px;
            height: 45px;
            border-radius: 12px;
            background: var(--gradient-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            font-weight: bold;
            box-shadow: var(--shadow-light);
        }

        .logo-text h1 {
            font-size: 18px;
            margin: 0;
            background: linear-gradient(90deg, var(--primary), var(--primary-light));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 800;
            line-height: 1.2;
        }

        .logo-text p {
            font-size: 11px;
            color: var(--text-secondary);
            font-weight: 600;
            margin: 0;
        }

        .hamburger-btn {
            display: none;
            background: none;
            border: none;
            font-size: 28px;
            color: var(--text);
            cursor: pointer;
            padding: 5px;
            margin-left: 15px; /* Space between hamburger and logo in RTL */
        }
        
        /* Mobile Header Layout */
        @media (max-width: 768px) {
            .app-header {
                justify-content: flex-start; /* Align specifically for mobile customization */
            }
            
            .hamburger-btn {
                display: block;
                order: -1; /* Ensure it's first */
            }
            
            .logo-section {
                margin-right: 0;
            }
            
            .user-controls {
                margin-right: auto; /* Push to the left */
            }
        }



        /* User Menu & Dropdown */
        .user-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .user-menu-container {
            position: relative;
        }

        .user-menu-btn {
            display: flex;
            align-items: center;
            gap: 10px;
            background: var(--surface-light);
            border: 1px solid var(--border);
            padding: 6px 12px;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .user-menu-btn:hover {
            background: var(--border);
        }

        .user-avatar {
            width: 32px;
            height: 32px;
            background: var(--accent);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
        }

        .user-name-display {
            font-size: 14px;
            font-weight: 600;
            color: var(--text);
            display: none; /* Hidden on very small screens */
        }

        @media (min-width: 600px) {
            .user-name-display { display: block; }
        }

        .dropdown-menu {
            position: fixed;
            top: 0;
            right: -280px; /* Start off-screen */
            width: 280px;
            height: 100vh;
            background: var(--surface);
            border-left: 1px solid var(--border);
            padding: 20px;
            transition: right 0.3s ease;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 2000;
            box-shadow: -5px 0 15px rgba(0,0,0,0.1);
        }

        .dropdown-menu.show {
            right: 0 !important;
            visibility: visible !important;
            opacity: 1 !important;
            bottom: 0;
            display: flex !important; /* Ensure flex is maintained */
        }

        .night-mode .dropdown-menu {
            background: var(--surface);
            border-color: var(--border);
        }

        .night-mode .dropdown-menu {
            background: rgba(30, 41, 59, 0.95);
            border-color: rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 40px rgba(0,0,0,0.4);
        }

        /* .dropdown-menu.show is handled above */

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        @media (max-width: 768px) {
            .hamburger-btn {
                display: block;
            }
            
            .user-menu-btn {
                display: none;
            }
            
            .dropdown-menu {
                position: fixed;
                top: 0;
                right: -280px; 
                width: 280px;
                height: 100vh;
                background: var(--surface);
                border-radius: 0;
                border: none;
                border-left: 1px solid var(--border);
                padding: 20px;
                transition: right 0.3s ease;
                display: flex; /* Always flex */
                z-index: 2000;
                box-shadow: -5px 0 15px rgba(0,0,0,0.1);
                animation: none;
                transform: none;
                flex-direction: column;
                gap: 5px;
            }
            
            .dropdown-menu.show {
                right: 0;
                display: flex;
            }
            
            .mobile-only {
                display: flex !important;
            }
        }

        .menu-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 14px 18px;
            border-radius: 12px;
            color: var(--text);
            text-decoration: none;
            font-size: 15px;
            font-weight: 600;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid transparent;
            background: transparent;
            width: 100%;
            text-align: right;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .menu-item:hover {
            background: var(--surface-light);
            color: var(--primary);
            transform: translateX(-5px);
            border-color: var(--border);
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }

        .night-mode .menu-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .menu-item:active {
            transform: translateX(-2px) scale(0.98);
        }

        .menu-item i {
            width: 24px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 18px;
            transition: color 0.2s;
        }

        .menu-item:hover i {
            color: var(--primary);
            text-shadow: 0 0 10px rgba(67, 97, 238, 0.3);
        }

        .menu-divider {
            height: 1px;
            background: var(--border);
            margin: 4px 0;
        }

        /* Mobile Overlay */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
        }
        .menu-overlay.active { display: block; }

        /* Theme Toggle (Small) */
        .theme-toggle-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: background 0.2s;
        }
        .theme-toggle-btn:hover {
            background: var(--surface-light);
            color: var(--warning);
        }


        /* Letters Navigation */
        .letters-nav {
            padding: 15px 20px;
            background: rgba(248, 250, 252, 0.9);
            border-bottom: 1px solid var(--border);
            overflow-x: auto;
            display: flex;
            gap: 10px;
            transition: all 0.3s ease;
            scrollbar-width: thin;
            scrollbar-color: var(--primary-light) transparent;
        }

        .letters-nav::-webkit-scrollbar {
            height: 6px;
        }

        .letters-nav::-webkit-scrollbar-track {
            background: transparent;
        }

        .letters-nav::-webkit-scrollbar-thumb {
            background-color: var(--primary-light);
            border-radius: 3px;
        }

        .night-mode .letters-nav {
            background: rgba(30, 41, 59, 0.9);
        }

        .letter-tab {
            min-width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid var(--border);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            font-weight: 700;
            flex-shrink: 0;
        }

        .night-mode .letter-tab {
            background: rgba(30, 41, 59, 0.9);
        }

        .letter-tab.active {
            background: var(--gradient-primary);
            border-color: var(--primary-light);
            color: white;
            transform: scale(1.1);
            box-shadow: var(--shadow-light);
        }

        .letter-tab.completed::after {
            content: '‚úì';
            position: absolute;
            top: -5px;
            left: -5px;
            background: var(--success);
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
        }

        .letter-tab.locked {
            opacity: 0.5;
            cursor: not-allowed;
            background: rgba(248, 250, 252, 0.9);
        }

        .night-mode .letter-tab.locked {
            background: rgba(30, 41, 59, 0.9);
        }

        .letter-tab.locked::before {
            content: 'üîí';
            position: absolute;
            font-size: 12px;
            top: -5px;
            right: -5px;
        }

        /* Main Content */
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 25px;
        }

        @media (max-width: 900px) {
            .main-content {
                display: flex;
                flex-direction: column;
                gap: 20px;
            }

            .main-content > * {
                width: 100%;
                display: block !important; /* Ensure no section is hidden */
            }
        }

        .panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: var(--radius-lg);
            padding: 20px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-light);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .night-mode .panel {
            background: rgba(30, 41, 59, 0.95);
        }

        /* Improved Touch Targets for Mobile */
        @media (max-width: 768px) {
            .btn, .modal-btn, .control-btn {
                min-height: 48px; /* Recommended touch target size */
                min-width: 48px;
                padding: 12px 20px;
                font-size: 16px;
            }
            
            .game-controls {
                gap: 15px;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .game-controls .btn {
                flex: 1;
                min-width: 120px;
            }
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border);
        }

        .panel-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--primary);
        }

        .panel-badge {
            background: rgba(67, 97, 238, 0.1);
            color: var(--primary);
            padding: 5px 12px;
            border-radius: 50px;
            font-size: 12px;
            border: 1px solid rgba(67, 97, 238, 0.2);
            font-weight: 600;
        }

        .night-mode .panel-badge {
            background: rgba(67, 97, 238, 0.2);
        }

        /* Letter Display */
        .letter-display {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 25px;
        }

        .letter-visual {
            width: 100px;
            height: 100px;
            border-radius: var(--radius-lg);
            background: var(--gradient-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 800;
            box-shadow: var(--shadow);
            position: relative;
            overflow: hidden;
        }

        .letter-visual::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.1) 50%, transparent 70%);
            animation: shimmer 3s infinite linear;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .letter-uppercase {
            font-size: 42px;
            line-height: 1;
        }

        .letter-lowercase {
            font-size: 32px;
            line-height: 1;
            opacity: 0.9;
        }

        .letter-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .btn {
            padding: 10px 18px;
            border-radius: 50px;
            border: none;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            font-size: 14px;
            user-select: none;
        }

        .btn-primary {
            background: var(--gradient-primary);
            color: white;
            box-shadow: var(--shadow-light);
        }

        .btn-secondary {
            background: rgba(15, 23, 42, 0.05);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .night-mode .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-special-animation {
            position: relative;
            overflow: hidden;
            z-index: 1;
            background: linear-gradient(135deg, #f72585, #b5179e);
            box-shadow: 0 4px 15px rgba(247, 37, 133, 0.4);
        }

        .btn-special-animation::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300%;
            height: 300%;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
            transition: transform 0.8s ease;
        }

        .btn-special-animation:hover::before {
            transform: translate(-50%, -50%) scale(1);
        }


        /* Words Grid */
        .words-section {
            margin-bottom: 25px;
        }

        .section-title {
            font-size: 16px;
            margin-bottom: 15px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 700;
        }

        .words-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
        }

        .word-card {
            background: rgba(248, 250, 252, 0.9);
            border-radius: var(--radius-md);
            padding: 15px;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            position: relative;
        }

        .night-mode .word-card {
            background: rgba(30, 41, 59, 0.9);
        }

        .word-card:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-light);
            border-color: var(--primary-light);
        }

        .word-emoji {
            font-size: 32px;
        }

        .word-text {
            font-size: 16px;
            font-weight: 700;
            direction: ltr;
            text-align: center;
            color: var(--text);
        }

        .word-ar {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 600;
        }

        .word-actions {
            display: flex;
            gap: 8px;
            margin-top: 5px;
        }

        .icon-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(15, 23, 42, 0.05);
            border: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.3s ease;
            color: var(--text);
            user-select: none;
        }

        .night-mode .icon-btn {
            background: rgba(255, 255, 255, 0.1);
        }

        .icon-btn:hover {
            background: var(--primary);
            color: white;
            transform: scale(1.1);
        }

        .icon-btn.mic-active {
            background: var(--secondary);
            color: white;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(247, 37, 133, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(247, 37, 133, 0); }
            100% { box-shadow: 0 0 0 0 rgba(247, 37, 133, 0); }
        }

        /* Writing Section */
        .writing-section {
            margin-bottom: 25px;
        }

        .writing-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .writing-label {
            min-width: 120px;
            font-size: 14px;
            color: var(--text-secondary);
            font-weight: 600;
        }

        .writing-boxes {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .writing-box {
            width: 40px;
            height: 40px;
            border-radius: var(--radius-sm);
            border: 1px solid var(--border);
            background: rgba(248, 250, 252, 0.9);
            color: var(--text);
            text-align: center;
            font-size: 18px;
            font-weight: 700;
            direction: ltr;
            transition: all 0.3s ease;
            font-family: 'Arial', sans-serif;
        }

        .night-mode .writing-box {
            background: rgba(30, 41, 59, 0.9);
        }

        .writing-box:focus {
            outline: none;
            border-color: var(--primary-light);
            box-shadow: 0 0 0 2px rgba(67, 97, 238, 0.3);
        }

        .writing-box.correct {
            border-color: var(--success);
            background: rgba(74, 222, 128, 0.1);
            color: var(--success);
        }

        .writing-box.incorrect {
            border-color: var(--error);
            background: rgba(239, 68, 68, 0.1);
            color: var(--error);
        }

        /* Word Writing */
        .word-writing-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .word-writing-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(248, 250, 252, 0.9);
            padding: 12px 15px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            transition: all 0.3s ease;
        }

        .night-mode .word-writing-item {
            background: rgba(30, 41, 59, 0.9);
        }

        .word-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .word-input-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .word-input {
            padding: 8px 12px;
            border-radius: var(--radius-sm);
            border: 1px solid var(--border);
            background: rgba(248, 250, 252, 0.9);
            color: var(--text);
            direction: ltr;
            min-width: 150px;
            transition: all 0.3s ease;
            font-weight: 600;
            font-family: 'Arial', sans-serif;
        }

        .night-mode .word-input {
            background: rgba(30, 41, 59, 0.9);
        }

        .word-input:focus {
            outline: none;
            border-color: var(--primary-light);
            box-shadow: 0 0 0 2px rgba(67, 97, 238, 0.3);
        }

        .word-input.correct {
            border-color: var(--success);
            background: rgba(74, 222, 128, 0.1);
            color: var(--success);
        }

        .word-input.incorrect {
            border-color: var(--error);
            background: rgba(239, 68, 68, 0.1);
            color: var(--error);
        }

        /* Quiz Section */
        .quiz-container {
            background: rgba(248, 250, 252, 0.9);
            border-radius: var(--radius-md);
            padding: 15px;
            border: 1px solid var(--border);
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .night-mode .quiz-container {
            background: rgba(30, 41, 59, 0.9);
        }

        .quiz-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            font-size: 14px;
            color: var(--text-secondary);
            font-weight: 600;
        }

        .quiz-question {
            font-size: 16px;
            margin-bottom: 15px;
            direction: ltr;
            font-weight: 600;
        }

        .quiz-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .quiz-option {
            padding: 10px 15px;
            border-radius: 50px;
            border: 1px solid var(--border);
            background: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 600;
            user-select: none;
            flex: 1;
            min-width: 120px;
            text-align: center;
        }

        .night-mode .quiz-option {
            background: rgba(30, 41, 59, 0.9);
        }

        .quiz-option:hover {
            background: rgba(67, 97, 238, 0.1);
            border-color: var(--primary-light);
        }

        .quiz-option.correct {
            background: rgba(74, 222, 128, 0.1);
            border-color: var(--success);
            color: var(--success);
        }

        .quiz-option.incorrect {
            background: rgba(239, 68, 68, 0.1);
            border-color: var(--error);
            color: var(--error);
        }

        .quiz-option.disabled {
            pointer-events: none;
            opacity: 0.7;
        }

        /* Quiz Navigation */
        .quiz-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid var(--border);
        }

        .quiz-next-btn {
            padding: 10px 20px;
            border-radius: 50px;
            border: none;
            background: var(--gradient-primary);
            color: white;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .quiz-next-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .quiz-next-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        /* Score Panel */
        .score-panel {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .score-card {
            background: rgba(248, 250, 252, 0.9);
            border-radius: var(--radius-md);
            padding: 15px;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 5px;
            transition: all 0.3s ease;
        }

        .night-mode .score-card {
            background: rgba(30, 41, 59, 0.9);
        }

        .score-label {
            font-size: 13px;
            color: var(--text-secondary);
            font-weight: 600;
        }

        .score-value {
            font-size: 20px;
            font-weight: 700;
        }

        .score-value.high {
            color: var(--success);
        }

        .score-value.medium {
            color: var(--warning);
        }

        .score-value.low {
            color: var(--error);
        }

        /* Footer Actions */
        .footer-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
            overflow-y: auto;
            padding: 20px;
        }

        .night-mode .modal {
            background: rgba(15, 23, 42, 0.95);
        }

        .modal-content {
            background: rgba(255, 255, 255, 0.98);
            border-radius: var(--radius-lg);
            padding: 25px;
            max-width: 500px;
            width: 90%;
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
            position: relative;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            max-height: 90vh;
            overflow-y: auto;
        }

        .night-mode .modal-content {
            background: rgba(30, 41, 59, 0.98);
        }

        .modal-close {
            position: absolute;
            top: 15px;
            left: 15px;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 1;
        }

        .modal-close:hover {
            background: rgba(15, 23, 42, 0.05);
            color: var(--text);
        }

        .night-mode .modal-close:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .modal-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .modal-badge {
            display: inline-block;
            background: var(--gradient-primary);
            color: white;
            padding: 5px 15px;
            border-radius: 50px;
            font-size: 14px;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .modal-title {
            font-size: 24px;
            margin-bottom: 10px;
            color: var(--primary);
            font-weight: 700;
        }

        .modal-subtitle {
            color: var(--text-secondary);
            margin-bottom: 20px;
            font-weight: 600;
        }

        .modal-quote {
            background: rgba(248, 250, 252, 0.9);
            padding: 15px;
            border-radius: var(--radius-md);
            border-left: 4px solid var(--accent);
            margin-bottom: 20px;
            font-style: italic;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .night-mode .modal-quote {
            background: rgba(30, 41, 59, 0.9);
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .modal-btn {
            padding: 12px 20px;
            border-radius: 50px;
            border: none;
            font-weight: 700;
            cursor: pointer;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.3s ease;
            min-width: 140px;
            user-select: none;
        }

        .modal-btn.game {
            background: var(--gradient-accent);
            color: white;
        }

        .modal-btn.next {
            background: var(--gradient-success);
            color: white;
        }

        /* Game Modal */
        .game-modal {
            max-width: 800px;
            padding: 20px;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .game-title {
            font-size: 18px;
            font-weight: 700;
        }

        .game-score {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(248, 250, 252, 0.9);
            padding: 8px 15px;
            border-radius: 50px;
            border: 1px solid var(--border);
            transition: all 0.3s ease;
            font-weight: 600;
            flex-wrap: wrap;
        }

        .night-mode .game-score {
            background: rgba(30, 41, 59, 0.9);
        }

        .game-area {
            background: rgba(248, 250, 252, 0.9);
            border-radius: var(--radius-md);
            height: 400px;
            position: relative;
            overflow: hidden;
            border: 1px solid var(--border);
            transition: all 0.3s ease;
            touch-action: none;
        }

        .night-mode .game-area {
            background: rgba(30, 41, 59, 0.9);
        }

        .game-canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        /* New Game Styles */
        .games-container-wrapper {
            position: relative;
            margin-top: 20px;
        }
        
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 10px;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            scroll-behavior: smooth;
            padding: 10px;
            scrollbar-width: thin;
            scrollbar-color: var(--primary) transparent;
        }
        
        .games-grid::-webkit-scrollbar {
            width: 6px;
        }
        
        .games-grid::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .games-grid::-webkit-scrollbar-thumb {
            background-color: var(--primary);
            border-radius: 3px;
        }
        
        /* Scroll Arrows for Mobile */
        .games-scroll-arrows {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
        }
        
        .scroll-arrow {
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: var(--shadow-light);
        }
        
        .scroll-arrow:hover {
            transform: scale(1.1);
            box-shadow: var(--shadow);
        }
        
        .scroll-arrow:active {
            transform: scale(0.9);
        }
        
        .scroll-arrow:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        @media (min-width: 769px) {
            .games-scroll-arrows {
                display: none;
            }
            .games-grid {
                max-height: none;
                overflow-y: visible;
            }
        }

        .game-card {
            background: rgba(248, 250, 252, 0.9);
            border-radius: var(--radius-md);
            padding: 20px;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            transition: all 0.3s ease;
            cursor: pointer;
            user-select: none;
            position: relative;
            /* ÿßŸÑÿ≥ŸÖÿßÿ≠ ÿ®ÿßŸÑÿ™ŸÖÿ±Ÿäÿ± ÿßŸÑÿπŸÖŸàÿØŸä ŸÅŸÇÿ∑ ŸÑŸÖŸÜÿπ ŸÅÿ™ÿ≠ ÿßŸÑŸÑÿπÿ®ÿ© ÿπŸÜÿØ ÿßŸÑÿ™ŸÖÿ±Ÿäÿ± */
            touch-action: pan-y;
            /* Minimum touch target size for accessibility */
            min-height: 120px;
            min-width: 120px;
        }

        .night-mode .game-card {
            background: rgba(30, 41, 59, 0.9);
        }

        .game-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-light);
            border-color: var(--primary-light);
        }

        .game-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .mandatory-badge {
            position: absolute;
            top: -10px;
            right: -10px;
            background: #ef4444;
            color: white;
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 10;
        }

        .game-card.completed .mandatory-badge {
            background: #22c55e;
            content: '‚úì';
        }

        .game-icon {
            font-size: 40px;
        }

        .game-name {
            font-size: 16px;
            font-weight: 700;
            text-align: center;
        }

        /* Certificate Styles */
        .certificate-container {
            background: linear-gradient(135deg, #f8f9ff 0%, #e8f0ff 100%);
            color: #1e293b;
            padding: 50px;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
            max-width: 800px;
            width: 90%;
            text-align: center;
            position: relative;
            border: 12px solid #3a0ca3;
            font-family: 'Arial', serif;
        }

        .certificate-container::before {
            content: '';
            position: absolute;
            top: 25px;
            left: 25px;
            right: 25px;
            bottom: 25px;
            border: 3px double #4361ee;
            pointer-events: none;
            border-radius: 10px;
        }

        .certificate-header {
            margin-bottom: 30px;
        }

        .certificate-title {
            font-size: 42px;
            color: #3a0ca3;
            margin-bottom: 10px;
            font-weight: 800;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .certificate-subtitle {
            font-size: 20px;
            color: #4361ee;
            margin-bottom: 20px;
            font-weight: 600;
            font-style: italic;
        }

        .certificate-body {
            margin: 30px 0;
        }

        .certificate-student-name {
            font-size: 38px;
            color: #f72585;
            margin: 20px 0;
            padding: 15px 30px;
            border-bottom: 3px solid #4cc9f0;
            display: inline-block;
            font-weight: 700;
            background: rgba(247, 37, 133, 0.1);
            border-radius: 10px;
        }

        .certificate-message {
            font-size: 20px;
            line-height: 1.8;
            margin-bottom: 30px;
            font-weight: 600;
            color: #2d3748;
        }

        .certificate-date {
            font-size: 18px;
            margin-top: 30px;
            font-weight: 600;
            color: #4a5568;
        }

        .certificate-stamp {
            position: absolute;
            bottom: 50px;
            right: 50px;
            width: 140px;
            height: 140px;
            border: 4px solid #f72585;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 16px;
            background: rgba(247, 37, 133, 0.1);
            text-align: center;
            transform: rotate(-15deg);
            color: #f72585;
        }

        /* Print styles for certificate */
        @media print {
            .certificate-container {
                background: white !important;
                border: 8px solid #000 !important;
                box-shadow: none !important;
                max-width: none !important;
                width: 100% !important;
                margin: 0 !important;
                border-radius: 0 !important;
            }
            
            .certificate-container::before {
                border: 2px solid #000 !important;
                top: 15px !important;
                left: 15px !important;
                right: 15px !important;
                bottom: 15px !important;
            }
            
            .certificate-title, .certificate-student-name {
                color: #000 !important;
                text-shadow: none !important;
            }
            
            .certificate-stamp {
                border-color: #000 !important;
                color: #000 !important;
                background: white !important;
            }
        }

        /* Completion Animation */
        .completion-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 999;
            pointer-events: none;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--accent);
            opacity: 0.8;
            animation: fall linear forwards;
        }

        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(360deg);
            }
        }

        /* Progress Bar */
        .progress-container {
            width: 100%;
            height: 8px;
            background: rgba(248, 250, 252, 0.9);
            border-radius: 4px;
            margin: 15px 0;
            overflow: hidden;
        }

        .night-mode .progress-container {
            background: rgba(30, 41, 59, 0.9);
        }

        .progress-bar {
            height: 100%;
            background: var(--gradient-primary);
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        /* Achievement Badges */
        .achievements-container {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .achievement-badge {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--gradient-primary);
            color: white;
            font-size: 24px;
            position: relative;
            box-shadow: var(--shadow-light);
            font-weight: 600;
        }

        .achievement-badge.locked {
            background: rgba(248, 250, 252, 0.9);
            color: var(--text-secondary);
        }

        .night-mode .achievement-badge.locked {
            background: rgba(30, 41, 59, 0.9);
        }

        .achievement-badge .tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.98);
            color: var(--text);
            padding: 8px 12px;
            border-radius: var(--radius-sm);
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-light);
            font-weight: 600;
        }

        .night-mode .achievement-badge .tooltip {
            background: rgba(30, 41, 59, 0.98);
        }

        .achievement-badge:hover .tooltip {
            opacity: 1;
        }

        /* Microphone Permission Status */
        .mic-status {
            position: fixed;
            bottom: 80px;
            left: 20px;
            background: var(--gradient-primary);
            color: white;
            padding: 10px 15px;
            border-radius: 50px;
            font-size: 14px;
            display: none;
            align-items: center;
            gap: 8px;
            z-index: 100;
            box-shadow: var(--shadow);
            font-weight: 600;
        }

        .mic-status.show {
            display: flex;
        }

        .mic-status.error {
            background: var(--gradient-accent);
        }

        /* Game Controls */
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .control-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--gradient-primary);
            color: white;
            border: none;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            user-select: none;
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        /* Touch Controls for Mobile */
        .touch-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            display: none; /* Hidden by default, shown via JS */
            justify-content: space-between;
            padding: 0 30px;
            pointer-events: none;
            z-index: 100;
        }

        .touch-controls .control-btn {
            pointer-events: auto;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid var(--primary);
            color: var(--primary);
            font-size: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.1s;
            backdrop-filter: blur(5px);
        }

        .touch-controls .control-btn:active {
            transform: scale(0.9);
            background: var(--primary);
            color: white;
        }

        /* Game Canvas Responsive */
        .game-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            border-radius: var(--radius-lg);
            overflow: hidden;
            box-shadow: var(--shadow);
        }

        canvas {
            width: 100% !important;
            height: auto !important;
            display: block;
            touch-action: none; /* Prevent scrolling while playing */
        }

        /* Game Instructions */
        .game-instructions {
            background: rgba(248, 250, 252, 0.9);
            border-radius: var(--radius-md);
            padding: 15px;
            margin-top: 15px;
            border: 1px solid var(--border);
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .night-mode .game-instructions {
            background: rgba(30, 41, 59, 0.9);
        }

        /* Letter Jump Menu */
        .letter-jump-menu {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: var(--surface);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow);
            border: 1px solid var(--border);
            z-index: 100;
            display: none;
            flex-direction: column;
            max-height: 300px;
            overflow-y: auto;
        }

        .letter-jump-menu.show {
            display: flex;
        }

        .letter-jump-item {
            padding: 10px 15px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
        }

        .letter-jump-item:hover {
            background: var(--primary);
            color: white;
        }

        /* Game Win Modal */
        .win-modal .modal-content {
            max-width: 400px;
        }

        .win-animation {
            font-size: 60px;
            text-align: center;
            margin: 20px 0;
            animation: bounce 1s infinite alternate;
        }

        @keyframes bounce {
            from { transform: translateY(0); }
            to { transform: translateY(-20px); }
        }

        /* Scroll to Top Button */
        .scroll-top {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--gradient-primary);
            color: white;
            border: none;
            font-size: 20px;
            cursor: pointer;
            box-shadow: var(--shadow);
            display: none;
            z-index: 99;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .scroll-top.visible {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .scroll-top:hover {
            transform: translateY(-5px);
        }

        /* Difficulty Indicator */
        .difficulty-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            margin-left: 10px;
        }

        .difficulty-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--border);
        }

        .difficulty-dot.active {
            background: var(--primary);
        }

        /* Game Stats */
        .game-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
            padding: 10px;
            background: rgba(248, 250, 252, 0.9);
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
        }

        .night-mode .game-stats {
            background: rgba(30, 41, 59, 0.9);
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 700;
            color: var(--primary);
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--gradient-primary);
            color: white;
            padding: 12px 24px;
            border-radius: 50px;
            box-shadow: var(--shadow);
            z-index: 1001;
            font-weight: 600;
            text-align: center;
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            min-width: 250px;
            max-width: 90%;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Quiz Completion Effect */
        .quiz-completed {
            border-color: var(--success) !important;
            box-shadow: 0 0 15px rgba(74, 222, 128, 0.4) !important;
            animation: pulse 2s infinite;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .app-header {
                flex-direction: column;
                align-items: flex-start;
                padding: 15px;
            }
            
            .student-info {
                width: 100%;
                justify-content: space-between;
            }
            
            .main-content {
                padding: 15px;
                gap: 15px;
            }
            
            .letter-display {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .footer-actions {
                flex-direction: column;
                gap: 15px;
            }
            
            .modal-actions {
                flex-direction: column;
            }
            
            .writing-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            .writing-label {
                min-width: auto;
            }
            
            .word-writing-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            .word-input-container {
                width: 100%;
                justify-content: space-between;
            }
            
            .word-input {
                flex: 1;
                min-width: auto;
            }
            
            .certificate-container {
                padding: 20px;
            }
            
            .certificate-title {
                font-size: 28px;
            }
            
            .certificate-student-name {
                font-size: 24px;
            }

            .theme-toggle {
                position: relative;
                top: auto;
                left: auto;
                margin-top: 10px;
                order: 3;
                width: 100%;
                justify-content: center;
            }

            .mobile-menu {
                display: block;
                position: absolute;
                top: 20px;
                left: 25px;
            }
            
            .theme-toggle {
                top: 20px;
                right: 25px;
                left: auto;
                width: auto;
            }

            .mic-status {
                bottom: 100px;
                left: 10px;
                right: 10px;
                justify-content: center;
            }

            .game-area {
                height: 300px;
            }

            .control-btn {
                width: 60px;
                height: 60px;
                font-size: 24px;
            }

            .modal-content {
                padding: 20px;
            }

            .games-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .letter-jump-menu {
                right: 10px;
                max-height: 200px;
            }

            .quiz-option {
                min-width: 100px;
                font-size: 13px;
                padding: 8px 12px;
            }

            .quiz-navigation {
                flex-direction: column;
                gap: 10px;
            }

            .quiz-next-btn {
                width: 100%;
                justify-content: center;
            }

            .toast {
                bottom: 120px;
                min-width: 200px;
            }
        }

        @media (max-width: 480px) {
            .app-header {
                padding: 15px;
            }
            
            .logo-section {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .logo-text h1 {
                font-size: 18px;
            }
            
            .student-info {
                flex-direction: column;
                align-items: flex-start;
                width: 100%;
                gap: 10px;
            }
            
            .student-name {
                width: 100%;
            }
            
            .student-name input {
                width: 100%;
            }
            
            .progress-chip {
                width: 100%;
                justify-content: center;
            }
            
            .letter-tab {
                min-width: 40px;
                height: 40px;
                font-size: 14px;
            }
            
            .words-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            }
            
            .writing-box {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }
            
            .score-panel {
                grid-template-columns: 1fr;
            }
            
            .games-grid {
                grid-template-columns: 1fr;
            }

            .game-modal .modal-content {
                padding: 15px;
            }

            .game-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .game-score {
                width: 100%;
                justify-content: center;
            }

            .control-btn {
                width: 50px;
                height: 50px;
            }

            .quiz-option {
                min-width: 80px;
                font-size: 12px;
                padding: 6px 10px;
            }

            .toast {
                bottom: 150px;
                min-width: 180px;
                font-size: 14px;
                padding: 10px 16px;
            }
        }

        @media (max-width: 360px) {
            .letter-tab {
                min-width: 35px;
                height: 35px;
                font-size: 12px;
            }

            .words-grid {
                grid-template-columns: 1fr;
            }

            .writing-box {
                width: 30px;
                height: 30px;
                font-size: 14px;
            }

            .game-area {
                height: 250px;
            }

            .quiz-option {
                min-width: 70px;
                font-size: 11px;
            }
        }

        /* Landscape orientation for mobile */
        @media (max-height: 600px) and (orientation: landscape) {
            .game-area {
                height: 250px;
            }

            .modal-content {
                max-height: 80vh;
                padding: 15px;
            }
        }

        /* Prevent text selection on game elements */
        .no-select {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* Game button active state */
        .game-card:active {
            transform: translateY(-2px);
        }

        /* Loading animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Copy protection */
        .no-copy {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Canvas Touch Fix */
        canvas {
            touch-action: none;
        }

        /* Celebration Animations */
        .celebrate-balloon {
            position: fixed;
            bottom: -100px;
            font-size: 40px;
            animation: floatUp linear forwards;
            z-index: 9999;
            pointer-events: none;
        }

        .mini-celebrate-balloon {
            position: fixed;
            bottom: -50px;
            font-size: 25px;
            animation: miniFloatUp 2s ease-out forwards;
            z-index: 10000;
            pointer-events: none;
        }

        @keyframes floatUp {
            0% { bottom: -100px; transform: translateX(0) rotate(0deg); }
            50% { transform: translateX(20px) rotate(10deg); }
            100% { bottom: 120vh; transform: translateX(-20px) rotate(-10deg); }
        }

        @keyframes miniFloatUp {
            0% { 
                bottom: -50px; 
                transform: translateX(0) rotate(0deg) scale(1); 
                opacity: 1; 
            }
            50% { 
                transform: translateX(10px) rotate(5deg) scale(1.2); 
                opacity: 0.8; 
            }
            100% { 
                bottom: 80vh; 
                transform: translateX(-10px) rotate(-5deg) scale(0.8); 
                opacity: 0; 
            }
        }

        .confetti {
            position: fixed;
            top: -20px;
            width: 10px;
            height: 10px;
            animation: fallDown linear forwards;
            z-index: 9998;
            pointer-events: none;
        }

        @keyframes fallDown {
            0% { top: -20px; transform: rotate(0deg); }
            100% { top: 100vh; transform: rotate(720deg); }
        }

        /* Mobile Optimizations */
        @media (max-width: 600px) {
            .app-header {
                padding: 10px 15px;
            }
            
            .logo-text h1 {
                font-size: 16px;
            }
            
            .logo-text p {
                font-size: 0.9rem !important;
            }
            
            .main-content {
                padding: 15px;
                gap: 15px;
            }
            
            .panel {
                padding: 15px;
            }
            
            .game-area {
                height: 60vh; /* Dynamic height for mobile games */
                max-height: 400px;
            }
            
            .control-btn {
                width: 60px;
                height: 60px;
                font-size: 24px;
            }
            
            .modal-content {
                width: 95%;
                padding: 15px;
                margin: 10px;
            }
            
            .letters-nav {
                padding: 10px;
            }
            
            .letter-tab {
                min-width: 40px;
                height: 40px;
                font-size: 14px;
            }
            
            /* Improve touch targets */
            button, .btn, .letter-tab, .game-card {
                cursor: pointer;
                touch-action: manipulation;
            }
            
            /* Prevent text selection during games */
            .game-modal {
                user-select: none;
                -webkit-user-select: none;
            }
        }

        /* ===== FIX: Standard Sidebar Drawer (Mobile + Desktop) ===== */
        #userDropdown {
            position: fixed;
            top: 0;
            right: -280px; /* Start off-screen */
            width: 280px;
            height: 100vh;
            background: var(--surface);
            border-left: 1px solid var(--border);
            z-index: 2005; /* Above overlay */
            
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-shadow: -5px 0 15px rgba(0,0,0,0.1);
            
            transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            visibility: visible;
            opacity: 1;
        }

        /* Open State */
        #userDropdown.show {
            right: 0 !important;
        }

        /* Night Mode */
        .night-mode #userDropdown {
            background: #0f172a;
            border-color: rgba(255,255,255,.12);
        }
                max-width: none; /* Full width on mobile */
            }
        }
    </style>
</head>
<body data-phonics-user-id="" data-phonics-user-email="">
    <div class="app-container">
        <!-- Header -->
        <header class="app-header">
            <!-- Mobile Hamburger Menu (Moved here for positioning) -->
            <button class="hamburger-btn" id="mobileMenuBtn">
                <i class="fas fa-bars"></i>
            </button>

            <div class="logo-section">
                <div class="logo">PGL</div>
                <div class="logo-text">
                    <h1 style="font-size: 1.2rem; margin-bottom: 2px;">Phonics Game Lab</h1>
                    <p style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 2px;">ŸÖÿ®ÿßÿØÿ±ÿ© ÿßŸÑÿ™ÿπŸÑŸÖ ÿ®ÿßŸÑŸÑÿπÿ® (ÿßŸÑÿ≠ÿ±ŸàŸÅ ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ©) - ÿ™ÿ£ÿ≥Ÿäÿ≥ - ÿ™ŸÖÿßÿ±ŸäŸÜ Ÿàÿ£Ÿàÿ±ÿßŸÇ ÿπŸÖŸÑ</p>
                </div>
            </div>

            <div class="user-controls">
                <!-- Theme Toggle -->
                <button class="theme-toggle-btn" id="themeToggle" title="Toggle Theme">
                    <i class="fas fa-moon"></i>
                </button>

                <!-- User Menu (Desktop) -->
                <div class="user-menu-container">
                    <div class="user-menu-btn" id="userMenuBtn">
                        <div class="user-avatar"><i class="fas fa-user"></i></div>
                        <span class="user-name-display" id="studentNameDisplay">Guest</span>
                        <i class="fas fa-chevron-down" style="font-size: 12px; color: var(--text-secondary);"></i>
                    </div>
                </div>
            </div>
        </header>
        
        <!-- Mobile Menu Overlay -->
        <div class="menu-overlay" id="menuOverlay"></div>

    <!-- Instructions Modal -->
    <div class="modal" id="instructionsModal" style="display: none;">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h2 class="modal-title">ÿ™ÿπŸÑŸäŸÖÿßÿ™ ÿßŸÑŸÖŸàŸÇÿπ</h2>
                <button class="modal-close" id="closeInstructionsModal">‚úï</button>
            </div>
            <div class="modal-body" style="line-height: 1.8; color: var(--text);">
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 3rem; margin-bottom: 10px;">üéì</div>
                    <h3 style="color: var(--primary); margin-bottom: 5px;">ŸÖÿ±ÿ≠ÿ®ÿßŸã ÿ®ŸÉ ŸÅŸä ÿ±ÿ≠ŸÑÿ© ÿßŸÑÿ™ÿπŸÑŸÖ ÿßŸÑŸÖŸÖÿ™ÿπÿ©!</h3>
                    <p style="color: var(--text-secondary); font-size: 0.9rem;">ÿØŸÑŸäŸÑŸÉ ÿßŸÑÿ≥ÿ±Ÿäÿπ ŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÖŸÜÿµÿ© Phonics Game Lab</p>
                </div>
                
                <div style="display: grid; gap: 15px;">
                    <div style="background: var(--surface-light); padding: 15px; border-radius: 12px; border-right: 4px solid var(--primary);">
                        <h4 style="margin-bottom: 5px; color: var(--primary-dark); display: flex; align-items: center; gap: 8px;">
                            <span style="background: var(--primary); color: white; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.8rem;">1</span>
                            ÿßÿÆÿ™ÿ± ÿßŸÑÿ≠ÿ±ŸÅ
                        </h4>
                        <p style="font-size: 0.9rem; margin: 0;">ÿßÿ®ÿØÿ£ ÿ®ÿßÿÆÿ™Ÿäÿßÿ± ÿ≠ÿ±ŸÅ ŸÖŸÜ ÿßŸÑŸÇÿßÿ¶ŸÖÿ©. ŸÉŸÑ ÿ≠ÿ±ŸÅ ŸáŸà ÿ®Ÿàÿßÿ®ÿ© ŸÑÿπÿßŸÑŸÖ ÿ¨ÿØŸäÿØ ŸÖŸÜ ÿßŸÑŸÉŸÑŸÖÿßÿ™ ŸàÿßŸÑÿ£ÿµŸàÿßÿ™.</p>
                    </div>

                    <div style="background: var(--surface-light); padding: 15px; border-radius: 12px; border-right: 4px solid var(--secondary);">
                        <h4 style="margin-bottom: 5px; color: var(--secondary); display: flex; align-items: center; gap: 8px;">
                            <span style="background: var(--secondary); color: white; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.8rem;">2</span>
                            ÿßÿ≥ÿ™ŸÖÿπ Ÿàÿ¥ÿßŸáÿØ
                        </h4>
                        <p style="font-size: 0.9rem; margin: 0;">ÿßÿ≥ÿ™ŸÖÿπ ŸÑŸÑŸÜÿ∑ŸÇ ÿßŸÑÿµÿ≠Ÿäÿ≠ (ÿ®ÿ±Ÿäÿ∑ÿßŸÜŸä/ÿ£ŸÖÿ±ŸäŸÉŸä)ÿå ÿ¥ÿßŸáÿØ ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑŸÉÿ™ÿßÿ®ÿ©ÿå Ÿàÿ™ÿπŸÑŸÖ ŸÉŸÑŸÖÿßÿ™ ÿ¨ÿØŸäÿØÿ© ŸÖÿπ ÿßŸÑÿµŸàÿ±.</p>
                    </div>

                    <div style="background: var(--surface-light); padding: 15px; border-radius: 12px; border-right: 4px solid var(--success);">
                        <h4 style="margin-bottom: 5px; color: var(--success); display: flex; align-items: center; gap: 8px;">
                            <span style="background: var(--success); color: white; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.8rem;">3</span>
                            ÿßŸÑÿπÿ® Ÿàÿ™ÿπŸÑŸÖ
                        </h4>
                        <p style="font-size: 0.9rem; margin: 0;">ÿ®ÿπÿØ ÿ™ÿπŸÑŸÖ ÿßŸÑÿ≠ÿ±ŸÅÿå ÿßÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ ÿ≤ÿ± <strong>"ÿ•ŸÜŸáÿßÿ° ÿßŸÑÿ≠ÿ±ŸÅ"</strong> ŸÑŸÅÿ™ÿ≠ ÿßŸÑÿ£ŸÑÿπÿßÿ® ÿßŸÑŸÖŸÖÿ™ÿπÿ© (ÿßŸÑÿ∞ÿßŸÉÿ±ÿ©ÿå ÿßŸÑŸÖÿ∑ÿßÿ®ŸÇÿ©ÿå ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑŸÉŸÑŸÖÿßÿ™).</p>
                    </div>

                    <div style="background: var(--surface-light); padding: 15px; border-radius: 12px; border-right: 4px solid var(--warning);">
                        <h4 style="margin-bottom: 5px; color: var(--warning); display: flex; align-items: center; gap: 8px;">
                            <span style="background: var(--warning); color: white; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.8rem;">4</span>
                            ÿßÿ¨ŸÖÿπ ÿßŸÑŸÜŸÇÿßÿ∑ ŸàÿßŸÑÿ¥ŸáÿßÿØÿßÿ™
                        </h4>
                        <p style="font-size: 0.9rem; margin: 0;">ŸÉŸÑŸÖÿß ŸÑÿπÿ®ÿ™ ÿ£ŸÉÿ´ÿ±ÿå ÿ¨ŸÖÿπÿ™ ŸÜŸÇÿßÿ∑ÿßŸã ÿ£ŸÉÿ´ÿ±! ÿ£ŸÉŸÖŸÑ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ≠ÿ±ŸàŸÅ ŸÑÿ™ÿ≠ÿµŸÑ ÿπŸÑŸâ ÿ¥ŸáÿßÿØÿ© ÿ•ÿ™ŸÖÿßŸÖ ŸÖŸÖŸäÿ≤ÿ©.</p>
                    </div>
                </div>
                
                <div style="margin-top: 20px; text-align: center;">
                    <p style="font-weight: bold; color: var(--primary);">ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ≥ÿ™ÿπÿØÿü ŸÑŸÜÿ®ÿØÿ£ ÿßŸÑŸÖÿ∫ÿßŸÖÿ±ÿ©! üöÄ</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Login/Profile Modal -->
    <div class="modal" id="profileModal" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2 class="modal-title">ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ¥ÿÆÿµŸä ŸÑŸÑÿ∑ÿßŸÑÿ®</h2>
                <p class="modal-subtitle">ÿ≥ÿ¨ŸÑ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ŸÑÿ≠ŸÅÿ∏ ÿ™ŸÇÿØŸÖŸÉ ŸàÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑÿ¥ŸáÿßÿØÿ©</p>
            </div>
            
            <div class="login-options">
                <!-- Google Login Simulation -->
                <button class="btn" id="googleLoginBtn" style="width: 100%; background: white; color: #444; border: 1px solid #ddd; margin-bottom: 20px; display: flex; align-items: center; justify-content: center; gap: 10px;">
                    <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" width="20" height="20" alt="Google">
                    <span>ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Google</span>
                </button>
                
                <div style="display: flex; align-items: center; margin: 20px 0;">
                    <div style="flex: 1; height: 1px; background: #ddd;"></div>
                    <span style="padding: 0 10px; color: #666;">ÿ£Ÿà ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑ ŸäÿØŸàŸäÿßŸã</span>
                    <div style="flex: 1; height: 1px; background: #ddd;"></div>
                </div>

                <form id="profileForm" style="display: flex; flex-direction: column; gap: 15px;">
                    <div class="form-group">
                        <label>ÿßÿ≥ŸÖ ÿßŸÑÿ∑ÿßŸÑÿ® (ÿ´ŸÑÿßÿ´Ÿä)</label>
                        <input type="text" id="profileName" class="form-control" placeholder="ŸÖÿ´ÿßŸÑ: ŸÖÿ≠ŸÖÿØ ÿ£ÿ≠ŸÖÿØ ÿπŸÑŸä" required style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px;">
                    </div>
                    
                    <div class="form-group">
                        <label>ÿßŸÑŸÖÿØÿ±ÿ≥ÿ©</label>
                        <input type="text" id="profileSchool" class="form-control" placeholder="ÿßÿ≥ŸÖ ÿßŸÑŸÖÿØÿ±ÿ≥ÿ©" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px;">
                    </div>
                    
                    <div class="form-group">
                        <label>ÿ±ŸÇŸÖ ÿ¨ŸàÿßŸÑ ÿßŸÑÿ∑ÿßŸÑÿ® (ÿßÿÆÿ™Ÿäÿßÿ±Ÿä)</label>
                        <input type="tel" id="profilePhone" class="form-control" placeholder="05xxxxxxxx" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px;">
                    </div>
                    
                    <div class="form-group">
                        <label>ÿ±ŸÇŸÖ ÿ¨ŸàÿßŸÑ ŸàŸÑŸä ÿßŸÑÿ£ŸÖÿ± (ŸÑÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ¥ŸáÿßÿØÿ©)</label>
                        <input type="tel" id="profileParentPhone" class="form-control" placeholder="05xxxxxxxx" required style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px;">
                    </div>

                    <button type="submit" class="btn btn-primary" style="margin-top: 10px;">ÿ≠ŸÅÿ∏ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™</button>
                </form>
            </div>
            <button class="modal-close" id="closeProfileModal">‚úï</button>
        </div>
    </div>

        <!-- Letters Navigation -->
        <div class="letters-nav" id="lettersNav">
            <!-- Letters will be generated here by JavaScript -->
        </div>

        <!-- Progress Bar -->
        <div class="progress-container">
            <div class="progress-bar" id="progressBar" style="width: 0%"></div>
        </div>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Left Panel -->
            <section class="panel">
                <div class="panel-header">
                    <h2 class="panel-title">ÿ™ÿπŸÑŸÖ ÿßŸÑÿ≠ÿ±ŸÅ <span id="currentLetter">A</span></h2>
                    <span class="panel-badge">ÿßŸÑÿÆÿ∑Ÿàÿ© 1-2: ÿßÿ≥ÿ™ŸÖÿπÿå ÿßŸÜÿ∑ŸÇÿå ÿßŸÉÿ™ÿ®</span>
                </div>

                <!-- Letter Display -->
                <div class="letter-display">
                    <div class="letter-visual">
                        <div class="letter-uppercase" id="letterUpper">A</div>
                        <div class="letter-lowercase" id="letterLower">a</div>
                    </div>
                    <div class="letter-actions">
                        <button class="btn btn-primary" id="playLetter">
                            <span>üîä</span> ŸÜÿ∑ŸÇ ÿßŸÑÿ≠ÿ±ŸÅ
                        </button>
                        <button class="btn btn-secondary" id="letterInfo">
                            <span>‚ÑπÔ∏è</span> ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ≠ÿ±ŸÅ
                        </button>
                        <button class="btn btn-secondary" id="resetLetter">
                            <span>üîÑ</span> ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©
                        </button>
                    </div>
                </div>

                <!-- Words Section -->
                <div class="words-section">
                    <h3 class="section-title">
                        <span>üî§</span> ŸÉŸÑŸÖÿßÿ™ ÿ™ÿ®ÿØÿ£ ÿ®ÿßŸÑÿ≠ÿ±ŸÅ <span id="letterForWords">A</span>
                    </h3>
                    <div class="words-grid" id="wordsGrid">
                        <!-- Words will be generated here by JavaScript -->
                    </div>
                </div>

                <!-- Writing Section -->
                <div class="writing-section">
                    <h3 class="section-title">
                        <span>‚úçÔ∏è</span> ÿ™ÿØÿ±ÿ® ÿπŸÑŸâ ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿ≠ÿ±ŸÅ
                    </h3>
                    <div class="writing-row">
                        <div class="writing-label">ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑŸÉÿ®Ÿäÿ± (A) 10 ŸÖÿ±ÿßÿ™</div>
                        <div class="writing-boxes" id="capitalWriting">
                            <!-- Writing boxes will be generated here by JavaScript -->
                        </div>
                    </div>
                    <div class="writing-row">
                        <div class="writing-label">ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿµÿ∫Ÿäÿ± (a) 10 ŸÖÿ±ÿßÿ™</div>
                        <div class="writing-boxes" id="smallWriting">
                            <!-- Writing boxes will be generated here by JavaScript -->
                        </div>
                    </div>
                </div>
            </section>

            <!-- Right Panel -->
            <section class="panel">
                <div class="panel-header">
                    <h2 class="panel-title">ÿ™ŸÖÿßÿ±ŸäŸÜ ÿßŸÑÿ≠ÿ±ŸÅ</h2>
                    <span class="panel-badge">ÿßŸÑÿÆÿ∑Ÿàÿ© 3-4: ŸÉÿ™ÿßÿ®ÿ© ŸÉŸÑŸÖÿßÿ™ ŸàÿßÿÆÿ™ÿ®ÿßÿ±</span>
                </div>

                <!-- Word Writing -->
                <div class="words-section">
                    <h3 class="section-title">
                        <span>üìù</span> ÿßŸÉÿ™ÿ® ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿßŸÑÿ™ÿßŸÑŸäÿ©
                    </h3>
                    <div class="word-writing-list" id="wordWritingList">
                        <!-- Word writing items will be generated here by JavaScript -->
                    </div>
                </div>

                <!-- Quiz Section -->
                <div class="words-section">
                    <h3 class="section-title">
                        <span>‚ùì</span> ÿßÿÆÿ™ÿ®ÿ± ŸÖÿπŸÑŸàŸÖÿßÿ™ŸÉ
                    </h3>
                    <div class="quiz-container">
                        <div class="quiz-header">
                            <div>ÿßŸÑÿ≥ÿ§ÿßŸÑ <span id="questionNumber">1</span> ŸÖŸÜ 6</div>
                            <div>ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©: <span id="quizScore">0</span>/6</div>
                        </div>
                        <div class="quiz-question" id="quizQuestion">
                            <!-- Question will be set by JavaScript -->
                        </div>
                        <div class="quiz-options" id="quizOptions">
                            <!-- Options will be set by JavaScript -->
                        </div>
                        <div class="quiz-navigation" id="quizNavigation">
                            <button class="quiz-next-btn" id="quizNextBtn">
                                <span>‚û°Ô∏è</span> ÿßŸÑÿ™ÿßŸÑŸä
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Score Panel -->
                <div class="score-panel">
                    <div class="score-card">
                        <div class="score-label">ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿ≠ÿ±ŸÅ</div>
                        <div class="score-value" id="writingScore">0/20</div>
                    </div>
                    <div class="score-card">
                        <div class="score-label">ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑŸÉŸÑŸÖÿßÿ™</div>
                        <div class="score-value" id="wordsScore">0/6</div>
                    </div>
                    <div class="score-card">
                        <div class="score-label">ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±</div>
                        <div class="score-value" id="testScore">0/6</div>
                    </div>
                    <div class="score-card">
                        <div class="score-label">ÿßŸÑŸÖÿ¨ŸÖŸàÿπ</div>
                        <div class="score-value" id="totalScore">0/32</div>
                    </div>
                </div>

                <!-- Achievements -->
                <div class="words-section">
                    <h3 class="section-title">
                        <span>üèÜ</span> ÿßŸÑÿ•ŸÜÿ¨ÿßÿ≤ÿßÿ™
                    </h3>
                    <div class="achievements-container" id="achievementsContainer">
                        <!-- Achievements will be generated here by JavaScript -->
                    </div>
                </div>

                <!-- Footer Actions -->
                <div class="footer-actions">
                    <button class="btn btn-secondary" id="prevLetter">
                        <span>‚¨ÖÔ∏è</span> ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿ≥ÿßÿ®ŸÇ
                    </button>
                    <button class="btn btn-primary" id="finishLetter" style="touch-action: manipulation; z-index: 100; position: relative;">
                        <span>‚úÖ</span> ÿ•ŸÜŸáÿßÿ° ÿßŸÑÿ≠ÿ±ŸÅ
                    </button>
                </div>
            </section>
        </main>
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast"></div>

    <!-- Motivation Modal -->
    <div class="modal" id="motivationModal">
        <div class="modal-content">
            <button class="modal-close" id="closeMotivation">√ó</button>
            <div class="modal-header">
                <div class="modal-badge">üî• ŸÜÿßÿ±! ŸÖÿ®ÿ±ŸàŸÉ!</div>
                <h2 class="modal-title" id="motivationTitle">ÿ£ÿ≠ÿ≥ŸÜÿ™!</h2>
                <p class="modal-subtitle" id="motivationSubtitle">ŸÑŸÇÿØ ÿ£ÿ™ŸÖŸÖÿ™ ÿ™ÿπŸÑŸÖ ÿßŸÑÿ≠ÿ±ŸÅ A ÿ®ŸÜÿ¨ÿßÿ≠</p>
            </div>
            <div class="modal-quote" id="motivationQuote">
                "ŸÖŸÜ ÿ¨ÿØ Ÿàÿ¨ÿØÿå ŸàŸÖŸÜ ÿ≤ÿ±ÿπ ÿ≠ÿµÿØ. ÿßÿ≥ÿ™ŸÖÿ± ŸÅŸä ÿßŸÑÿ™ŸÇÿØŸÖ!"
            </div>
            
            
            <!-- Games Grid -->
            <div class="games-container-wrapper">
                <div class="games-grid" id="gamesGrid">
                    <div class="game-card" data-game="carRace">
                        <div class="game-icon">üèéÔ∏è</div>
                        <div class="game-name">ÿ≥ÿ®ÿßŸÇ ÿßŸÑÿ≥Ÿäÿßÿ±ÿßÿ™</div>
                    </div>
                    <div class="game-card" data-game="racket">
                        <div class="game-icon">üéæ</div>
                        <div class="game-name">ŸÑÿπÿ®ÿ© ÿßŸÑŸÖÿ∂ÿ±ÿ®</div>
                    </div>
                    <div class="game-card" data-game="shooting">
                        <div class="game-icon">üéØ</div>
                        <div class="game-name">ÿßÿµÿ∑ŸäÿßÿØ ÿßŸÑÿ≠ÿ±ŸÅ</div>
                    </div>
                    <div class="game-card" data-game="balloons">
                        <div class="mandatory-badge">ŸÖÿ∑ŸÑŸàÿ®</div>
                        <div class="game-icon">üéà</div>
                        <div class="game-name">ŸÑÿπÿ®ÿ© ÿßŸÑÿ®ÿßŸÑŸàŸÜÿßÿ™</div>
                    </div>
                    <div class="game-card" data-game="memory">
                        <div class="mandatory-badge">ŸÖÿ∑ŸÑŸàÿ®</div>
                        <div class="game-icon">üß†</div>
                        <div class="game-name">ŸÑÿπÿ®ÿ© ÿßŸÑÿ∞ÿßŸÉÿ±ÿ©</div>
                    </div>
                    <div class="game-card" data-game="wordsearch">
                        <div class="game-icon">üîç</div>
                        <div class="game-name">ŸÑÿπÿ®ÿ© ÿßŸÑÿ®ÿ≠ÿ´</div>
                    </div>
                    <div class="game-card" data-game="typing">
                        <div class="game-icon">‚å®Ô∏è</div>
                        <div class="game-name">ÿßŸÑŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿ≥ÿ±Ÿäÿπÿ©</div>
                    </div>
                    <div class="game-card" data-game="match">
                        <div class="mandatory-badge">ŸÖÿ∑ŸÑŸàÿ®</div>
                        <div class="game-icon">üî§</div>
                        <div class="game-name">ŸÑÿπÿ®ÿ© ÿßŸÑŸÖÿ∑ÿßÿ®ŸÇÿ©</div>
                    </div>
                </div>
                
                <!-- Scroll Arrows for Mobile -->
                <div class="games-scroll-arrows">
                    <button class="scroll-arrow" id="scrollUpBtn" title="ÿ™ŸÖÿ±Ÿäÿ± ŸÑÿ£ÿπŸÑŸâ">
                        <i class="fas fa-chevron-up"></i>
                    </button>
                    <button class="scroll-arrow" id="scrollDownBtn" title="ÿ™ŸÖÿ±Ÿäÿ± ŸÑÿ£ÿ≥ŸÅŸÑ">
                        <i class="fas fa-chevron-down"></i>
                    </button>
                </div>
            </div>
            
            <div class="modal-actions">
                <button class="modal-btn game" id="playGames">
                    <span>üéÆ</span> ÿßŸÑÿπÿ® ÿßŸÑÿ£ŸÑÿπÿßÿ®
                </button>
                <button class="modal-btn next" id="nextLetter">
                    <span>‚û°Ô∏è</span> ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿ™ÿßŸÑŸä
                </button>
            </div>
        </div>
    </div>

    <!-- Game Modal -->
    <div class="modal" id="gameModal">
        <div class="modal-content game-modal">
            <button class="modal-close" id="closeGame">√ó</button>
            <div class="game-header">
                <h3 class="game-title" id="gameTitle">üéÆ ŸÑÿπÿ®ÿ© ÿ™ÿπŸÑŸäŸÖŸäÿ©</h3>
                <div class="game-score">
                    <span>ÿßŸÑŸÜŸÇÿßÿ∑:</span>
                    <span id="gameScore">0</span>
                    <span>ÿßŸÑŸàŸÇÿ™:</span>
                    <span id="gameTimer">60</span>
                </div>
            </div>
            <div class="game-area">
                <canvas id="gameCanvas"></canvas>
            </div>
            
            <!-- Touch Controls for Mobile -->
            <div class="touch-controls" id="touchControls">
                <button class="control-btn" data-action="left">‚Üê</button>
                <button class="control-btn" data-action="action">‚ö°</button>
                <button class="control-btn" data-action="right">‚Üí</button>
            </div>
            
            <div class="game-instructions" id="gameInstructions">
                ÿ™ÿπŸÑŸäŸÖÿßÿ™ ÿßŸÑŸÑÿπÿ®ÿ©
            </div>
            
            <div class="game-stats" id="gameStats">
                <div class="stat-item">
                    <div class="stat-value" id="successCount">0</div>
                    <div class="stat-label">ŸÖÿ±ÿßÿ™ ŸÜÿßÿ¨ÿ≠ÿ©</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="difficultyLevel">1</div>
                    <div class="stat-label">ÿßŸÑŸÖÿ≥ÿ™ŸàŸâ</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="accuracy">0%</div>
                    <div class="stat-label">ÿßŸÑÿØŸÇÿ©</div>
                </div>
            </div>
            
            <div class="game-controls" id="gameControls">
                <button class="btn btn-primary" id="restartGame">
                    <span>üîÑ</span> ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÑÿπÿ®
                </button>
                <button class="btn btn-secondary" id="pauseGame">
                    <span>‚è∏Ô∏è</span> ÿ•ŸäŸÇÿßŸÅ
                </button>
                <button class="btn btn-secondary" id="backToSelection">
                    <span>üè†</span> ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑÿ£ŸÑÿπÿßÿ®
                </button>
            </div>
        </div>
    </div>

    <!-- Win Modal -->
    <div class="modal win-modal" id="winModal">
        <div class="modal-content">
            <button class="modal-close" id="closeWin">√ó</button>
            <div class="modal-header">
                <div class="modal-badge">üèÜ ŸÅŸàÿ≤ ÿ±ÿßÿ¶ÿπ!</div>
                <h2 class="modal-title" id="winTitle">ÿ≥ŸÑŸÖÿ™ Ÿäÿßÿ®ÿ∑ŸÑ! üî•</h2>
                <p class="modal-subtitle" id="winSubtitle">ÿ£ŸÜÿ™ ŸÜÿ¨ŸÖ ÿßŸÑŸÖÿ≥ÿ™ŸÇÿ®ŸÑ ‚ú®</p>
            </div>
            
            <div class="win-animation" id="winAnimation">üéÜüéá‚ú®</div>
            
            <div class="modal-quote" id="winQuote">
                "ŸÖÿ≥ÿ™ŸàŸâ ÿ±ÿßÿ¶ÿπ! ŸÖŸáÿßÿ±ÿßÿ™ŸÉ ŸÅŸä ÿ™ÿπŸÑŸÖ ÿßŸÑÿ≠ÿ±ŸàŸÅ ŸÖÿ∞ŸáŸÑÿ©!"
            </div>
            
            <div class="game-stats">
                <div class="stat-item">
                    <div class="stat-value" id="finalScore">0</div>
                    <div class="stat-label">ÿßŸÑŸÜŸÇÿßÿ∑ ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ©</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="finalTime">60</div>
                    <div class="stat-label">ÿ´ÿßŸÜŸäÿ© ŸÖÿ™ÿ®ŸÇŸäÿ©</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="finalAccuracy">100%</div>
                    <div class="stat-label">ÿßŸÑÿØŸÇÿ©</div>
                </div>
            </div>
            
            <div class="modal-actions">
                <button class="modal-btn game" id="playAgain">
                    <span>üîÑ</span> ÿßŸÑÿπÿ® ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ
                </button>
                <button class="modal-btn next" id="backToGames">
                    <span>üéÆ</span> ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑÿ£ŸÑÿπÿßÿ®
                </button>
                <button class="modal-btn next" id="winNextLetterBtn" style="display:none; background: linear-gradient(135deg, #10b981, #059669);">
                    <span>‚û°Ô∏è</span> ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿ™ÿßŸÑŸä
                </button>
            </div>
        </div>
    </div>

    <!-- Certificate Modal -->
    <div class="modal" id="certificateModal">
        <div class="certificate-container">
            <div class="certificate-header">
                <div class="stars" style="font-size: 2rem; color: gold; margin-bottom: 10px;">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</div>
                <h1 class="certificate-title">ÿ¥ŸáÿßÿØÿ© ÿ•ŸÜÿ¨ÿßÿ≤ / Certificate of Achievement</h1>
                <p class="certificate-subtitle">ŸÖŸÜÿµÿ© ÿ£ŸÑÿπÿßÿ® ÿßŸÑÿ≠ÿ±ŸàŸÅ ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ© / English Phonics Games Platform</p>
            </div>
            <div class="certificate-body">
                <p>Ÿáÿ∞Ÿá ÿßŸÑÿ¥ŸáÿßÿØÿ© ÿ™ŸÖŸÜÿ≠ ÿ•ŸÑŸâ / This certificate is presented to:</p>
                <h2 class="certificate-student-name" id="certificateName">ÿßŸÑÿ∑ÿßŸÑÿ® ÿßŸÑŸÖÿ™ŸÖŸäÿ≤</h2>
                <p class="certificate-message">
                    ŸÑŸÇÿØ ÿ£ÿ™ŸÖŸÖÿ™ ÿ®ŸÜÿ¨ÿßÿ≠ ÿ™ÿπŸÑŸÖ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ≠ÿ±ŸàŸÅ ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ© ŸÖŸÜ A ÿ•ŸÑŸâ Z<br>
                    You have successfully completed learning all English letters from A to Z<br>
                    <br>
                    ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑŸÜÿ¨ŸàŸÖ ÿßŸÑŸÖÿ≠ÿµŸÑ ÿπŸÑŸäŸáÿß: <span id="certificate-stars" style="color: gold; font-weight: bold;">0</span> ‚≠ê<br>
                    ÿπÿØÿØ ÿßŸÑÿ≠ÿ±ŸàŸÅ ÿßŸÑŸÖŸÉÿ™ŸÖŸÑÿ©: <span id="certificate-letters-count" style="color: green; font-weight: bold;">26</span> ÿ≠ÿ±ŸÅ<br>
                    <br>
                    "ÿ£ŸÜÿ™ ŸÜÿ¨ŸÖ ÿ≥ÿßÿ∑ÿπ ŸÅŸä ÿ≥ŸÖÿßÿ° ÿßŸÑÿπŸÑŸÖ! ÿßÿ≥ÿ™ŸÖÿ± ŸÅŸä ÿßŸÑÿ™ÿ£ŸÑŸÇ ŸàÿßŸÑŸÜÿ¨ÿßÿ≠."<br>
                    "You are a shining star! Keep up the great work."
                </p>
                <p class="certificate-date">ÿ™ŸÖ ŸÖŸÜÿ≠ Ÿáÿ∞Ÿá ÿßŸÑÿ¥ŸáÿßÿØÿ© ŸÅŸä: <span id="certificate-date">2024</span></p>
            </div>
            <div class="certificate-stamp">
                ŸÖŸÉÿ™ŸÖŸÑ<br>Completed
            </div>
            <div style="margin-top: 30px; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                <button class="btn btn-primary" id="printCertificate">
                    <span>üñ®Ô∏è</span> ÿ™ÿ≠ŸÖŸäŸÑ PDF / Download
                </button>
                <button class="btn btn-success" id="emailCertificate">
                    <span>üìß</span> ÿ•ÿ±ÿ≥ÿßŸÑ ŸÑŸÑÿ•ŸäŸÖŸäŸÑ / Email
                </button>
                <button class="btn btn-info" id="whatsappCertificate">
                    <span>üì±</span> ÿ•ÿ±ÿ≥ÿßŸÑ ŸÑŸÑŸàÿßÿ™ÿ≥ÿßÿ® / WhatsApp
                </button>
                <button class="btn btn-secondary" id="closeCertificate">
                    <span>‚úï</span> ÿ•ÿ∫ŸÑÿßŸÇ / Close
                </button>
            </div>
        </div>
    </div>

    <!-- Letter Jump Menu -->
    <div class="letter-jump-menu" id="letterJumpMenu">
        <!-- Letters will be added here -->
    </div>

    <!-- Completion Animation -->
    <div class="completion-animation" id="completionAnimation"></div>

    <!-- Microphone Status -->
    <div class="mic-status" id="micStatus">
        <span>üé§</span>
        <span id="micStatusText">ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ÿ∂Ÿäÿ± ÿßŸÑŸÖÿßŸäŸÉÿ±ŸàŸÅŸàŸÜ...</span>
    </div>

    <!-- Scroll to Top Button -->
    <button class="scroll-top" id="scrollTop">‚Üë</button>

    <!-- Footer -->
    <footer class="app-footer">
        <div class="footer-content">
            <div class="footer-links">
                <a href="#" class="footer-link">
                    <i class="fab fa-telegram"></i> ÿ™ŸÑŸäÿ¨ÿ±ÿßŸÖ
                </a>
                <a href="https://wa.me/966551561955" target="_blank" class="footer-link">
                    <i class="fab fa-whatsapp"></i> Ÿàÿßÿ™ÿ≥ÿßÿ®
                </a>

            </div>
            <div class="footer-copyright">
                <p>¬© 2025 Phonics Game Lab. ÿ¨ŸÖŸäÿπ ÿßŸÑÿ≠ŸÇŸàŸÇ ŸÖÿ≠ŸÅŸàÿ∏ÿ©.</p>

            </div>
        </div>
    </footer>



    <style>
        .app-footer {
            background: var(--surface);
            border-top: 1px solid var(--border);
            padding: 30px 20px;
            margin-top: 40px;
            text-align: center;
            border-radius: 0 0 var(--radius-lg) var(--radius-lg);
        }

        .footer-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .footer-links {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .footer-link, .footer-link-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-secondary);
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.95rem;
            font-family: inherit;
            padding: 10px 20px;
            border-radius: 50px;
            background-color: var(--surface-light);
            box-shadow: var(--shadow-light);
        }

        .footer-link:hover, .footer-link-btn:hover {
            color: var(--primary);
            background-color: white;
            transform: translateY(-3px);
            box-shadow: var(--shadow);
        }

        .footer-copyright {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .developer-credit {
            font-size: 0.8rem;
            margin-top: 5px;
            opacity: 0.8;
        }
    </style>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const privacyBtn = document.getElementById('privacyPolicyBtn');
            const privacyModal = document.getElementById('privacyModal');
            const closePrivacyBtn = document.getElementById('closePrivacyModal');

            if (privacyBtn && privacyModal && closePrivacyBtn) {
                privacyBtn.addEventListener('click', () => {
                    privacyModal.style.display = 'flex';
                });

                closePrivacyBtn.addEventListener('click', () => {
                    privacyModal.style.display = 'none';
                });

                privacyModal.addEventListener('click', (e) => {
                    if (e.target === privacyModal) {
                        privacyModal.style.display = 'none';
                    }
                });
            }
        });
    </script>

    <script>
        // ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ
        const LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
        
        // ŸÜÿ∏ÿßŸÖ ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿµŸàÿ™ ÿßŸÑÿ®ÿ±Ÿäÿ∑ÿßŸÜŸä ÿßŸÑŸÖÿ≠ÿ≥ŸÜ
        class BritishSoundManager {
            constructor() {
                this.sounds = new Map();
                this.currentSpeech = null;
                this.isSpeaking = false;
                this.audioQueue = [];
                this.isProcessing = false;
                this.britishVoices = [];
                this.currentBritishVoice = null;
                this.isSpeakingEnabled = true;
            }
            
            async initialize() {
                if (window.speechSynthesis) {
                    const loadVoices = () => {
                        const voices = window.speechSynthesis.getVoices();
                        
                        // Priority 1: Specific high-quality British Male voices
                        const preferredNames = [
                            'Google UK English Male', 
                            'Microsoft George', 
                            'Microsoft Ryan',
                            'Daniel',
                            'Arthur',
                            'Gordon',
                            'Aaron'
                        ];
                        
                        // Try to find exact matches first
                        this.britishVoices = voices.filter(voice => 
                            preferredNames.some(name => voice.name.includes(name))
                        );

                        // Priority 2: Any English Male voice (GB preferred)
                        if (this.britishVoices.length === 0) {
                            this.britishVoices = voices.filter(voice => 
                                (voice.lang.includes('GB') || voice.lang.includes('UK')) && 
                                voice.name.toLowerCase().includes('male')
                            );
                        }

                        // Priority 3: Any English Male voice
                        if (this.britishVoices.length === 0) {
                            this.britishVoices = voices.filter(voice => 
                                voice.lang.includes('en') && 
                                voice.name.toLowerCase().includes('male')
                            );
                        }
                        
                        // Priority 4: Any British voice
                        if (this.britishVoices.length === 0) {
                            this.britishVoices = voices.filter(voice => 
                                voice.lang.includes('GB') || 
                                voice.name.includes('UK') || 
                                voice.name.includes('British')
                            );
                        }
                        
                        this.currentBritishVoice = this.britishVoices[0] || voices.find(v => v.lang.startsWith('en'));
                        console.log("Selected Voice:", this.currentBritishVoice ? this.currentBritishVoice.name : "Default");
                    };
                    
                    loadVoices();
                    window.speechSynthesis.onvoiceschanged = loadVoices;
                }
            }
            
            async speak(text, lang = 'en-GB') {
                if (!window.speechSynthesis || !this.isSpeakingEnabled) return;
                
                return new Promise((resolve) => {
                    if (this.isSpeaking) {
                        window.speechSynthesis.cancel();
                    }
                    
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = lang;
                    utterance.rate = 0.85; // ÿ≥ÿ±ÿπÿ© ŸÖÿ™Ÿàÿ≥ÿ∑ÿ© ŸÑŸÑŸàÿ∂Ÿàÿ≠
                    utterance.pitch = 1.0; // ŸÜÿ®ÿ±ÿ© ÿ∑ÿ®ŸäÿπŸäÿ©
                    utterance.volume = 1.0; // ÿ£ÿπŸÑŸâ ŸÖÿ≥ÿ™ŸàŸâ ÿµŸàÿ™
                    
                    if (this.currentBritishVoice) {
                        utterance.voice = this.currentBritishVoice;
                    } else {
                        const voices = window.speechSynthesis.getVoices();
                        // ŸÖÿ≠ÿßŸàŸÑÿ© ÿ£ÿÆŸäÿ±ÿ© ŸÑŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿµŸàÿ™ ŸÖŸÜÿßÿ≥ÿ® ÿπŸÜÿØ ÿßŸÑÿ™ÿ≠ÿØÿ´
                        const britishVoice = voices.find(voice => 
                            voice.name.includes('Google UK English Male') ||
                            voice.name.includes('Microsoft George') ||
                            (voice.lang.startsWith('en-GB') && voice.name.toLowerCase().includes('male'))
                        ) || voices.find(voice => voice.lang.startsWith('en-GB'));
                        
                        if (britishVoice) {
                            utterance.voice = britishVoice;
                        }
                    }
                    
                    utterance.onstart = () => {
                        this.isSpeaking = true;
                        this.currentSpeech = utterance;
                    };
                    
                    utterance.onend = () => {
                        this.isSpeaking = false;
                        this.currentSpeech = null;
                        resolve();
                    };
                    
                    utterance.onerror = () => {
                        this.isSpeaking = false;
                        this.currentSpeech = null;
                        resolve();
                    };
                    
                    setTimeout(() => {
                        window.speechSynthesis.speak(utterance);
                    }, 50);
                });
            }
            
            playSound(type) {
                if (!this.isSpeakingEnabled) return;
                
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                let frequency, duration;
                
                switch(type) {
                    case 'success':
                        frequency = [523.25, 659.25, 783.99];
                        duration = 0.5;
                        break;
                    case 'error':
                        frequency = [220, 180];
                        duration = 0.3;
                        break;
                    case 'click':
                        frequency = [440];
                        duration = 0.1;
                        break;
                    case 'win':
                        frequency = [523.25, 659.25, 783.99, 1046.50];
                        duration = 0.8;
                        break;
                    case 'applause':
                        // Fanfare sequence
                        frequency = [523.25, 659.25, 783.99, 1046.50, 783.99, 1046.50];
                        duration = 1.5;
                        break;
                    case 'fireworks':
                        frequency = [392, 523.25, 659.25, 784];
                        duration = 1.0;
                        break;
                    default:
                        frequency = [440];
                        duration = 0.2;
                }
                
                oscillator.frequency.setValueAtTime(frequency[0], audioContext.currentTime);
                
                if (frequency.length > 1) {
                    frequency.forEach((freq, index) => {
                        oscillator.frequency.setValueAtTime(freq, audioContext.currentTime + (index * 0.15));
                    });
                }
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
                
                setTimeout(() => {
                    audioContext.close();
                }, duration * 1000 + 100);
            }
            
            stopAll() {
                if (this.isSpeaking) {
                    window.speechSynthesis.cancel();
                    this.isSpeaking = false;
                }
            }
        }

        // ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ≠ÿ±ŸàŸÅ ŸàÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿßŸÑŸÖÿ≠ÿ≥ŸÜÿ©
        const LETTER_DATA = {};
        
        // ÿ™ŸáŸäÿ¶ÿ© ÿ®ŸäÿßŸÜÿßÿ™ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ≠ÿ±ŸàŸÅ
        LETTERS.forEach(letter => {
            let words = [];
            let emojis = [];
            let translations = [];
            
            switch(letter) {
                case 'A':
                    words = ["Apple", "Ant", "Airplane", "Arrow", "Astronaut", "Alligator", "Arm", "Anchor", "Axe", "Apricot"];
                    emojis = ["üçé", "üêú", "‚úàÔ∏è", "üèπ", "üßë‚ÄçüöÄ", "üêä", "üí™", "‚öì", "ü™ì", "üçë"];
                    translations = ["ÿ™ŸÅÿßÿ≠ÿ©", "ŸÜŸÖŸÑÿ©", "ÿ∑ÿßÿ¶ÿ±ÿ©", "ÿ≥ŸáŸÖ", "ÿ±ÿßÿ¶ÿØ ŸÅÿ∂ÿßÿ°", "ÿ™ŸÖÿ≥ÿßÿ≠", "ÿ∞ÿ±ÿßÿπ", "ŸÖÿ±ÿ≥ÿßÿ©", "ŸÅÿ£ÿ≥", "ŸÖÿ¥ŸÖÿ¥"];
                    break;
                case 'B':
                    words = ["Ball", "Banana", "Butterfly", "Book", "Bear", "Bird", "Bus", "Bee", "Balloon", "Bread"];
                    emojis = ["‚öΩ", "üçå", "ü¶ã", "üìñ", "üêª", "üê¶", "üöå", "üêù", "üéà", "üçû"];
                    translations = ["ŸÉÿ±ÿ©", "ŸÖŸàÿ≤ÿ©", "ŸÅÿ±ÿßÿ¥ÿ©", "ŸÉÿ™ÿßÿ®", "ÿØÿ®", "ÿ∑ÿßÿ¶ÿ±", "ÿ≠ÿßŸÅŸÑÿ©", "ŸÜÿ≠ŸÑÿ©", "ÿ®ÿßŸÑŸàŸÜ", "ÿÆÿ®ÿ≤"];
                    break;
                case 'C':
                    words = ["Cat", "Car", "Cake", "Candle", "Crown", "Cloud", "Cow", "Cup", "Camera", "Clock"];
                    emojis = ["üê±", "üöó", "üç∞", "üïØÔ∏è", "üëë", "‚òÅÔ∏è", "üêÆ", "‚òï", "üì∑", "‚è∞"];
                    translations = ["ŸÇÿ∑ÿ©", "ÿ≥Ÿäÿßÿ±ÿ©", "ŸÉÿπŸÉÿ©", "ÿ¥ŸÖÿπÿ©", "ÿ™ÿßÿ¨", "ÿ≥ÿ≠ÿßÿ®ÿ©", "ÿ®ŸÇÿ±ÿ©", "ŸÉŸàÿ®", "ŸÉÿßŸÖŸäÿ±ÿß", "ÿ≥ÿßÿπÿ©"];
                    break;
                case 'D':
                    words = ["Dog", "Duck", "Dolphin", "Door", "Diamond", "Drum", "Desk", "Doll", "Donut", "Dress"];
                    emojis = ["üê∂", "ü¶Ü", "üê¨", "üö™", "üíé", "ü•Å", "üñ•Ô∏è", "üéé", "üç©", "üëó"];
                    translations = ["ŸÉŸÑÿ®", "ÿ®ÿ∑ÿ©", "ÿØŸàŸÑŸÅŸäŸÜ", "ÿ®ÿßÿ®", "ÿ£ŸÑŸÖÿßÿ≥", "ÿ∑ÿ®ŸÑ", "ŸÖŸÉÿ™ÿ®", "ÿØŸÖŸäÿ©", "ÿØŸàŸÜÿßÿ™", "ŸÅÿ≥ÿ™ÿßŸÜ"];
                    break;
                case 'E':
                    words = ["Elephant", "Egg", "Eagle", "Earth", "Engine", "Eyes", "Ear", "Eight", "Envelope", "Eraser"];
                    emojis = ["üêò", "ü•ö", "ü¶Ö", "üåç", "üöÇ", "üëÄ", "üëÇ", "8Ô∏è‚É£", "‚úâÔ∏è", "‚úèÔ∏è"];
                    translations = ["ŸÅŸäŸÑ", "ÿ®Ÿäÿ∂ÿ©", "ŸÜÿ≥ÿ±", "ÿ£ÿ±ÿ∂", "ŸÖÿ≠ÿ±ŸÉ", "ÿπŸäŸàŸÜ", "ÿ£ÿ∞ŸÜ", "ÿ´ŸÖÿßŸÜŸäÿ©", "ÿ∏ÿ±ŸÅ", "ŸÖŸÖÿ≠ÿßÿ©"];
                    break;
                case 'F':
                    words = ["Fish", "Flower", "Frog", "Flag", "Fire", "Fox", "Fan", "Fork", "Five", "Fruit"];
                    emojis = ["üêü", "üåπ", "üê∏", "üö©", "üî•", "ü¶ä", "ü™≠", "üç¥", "5Ô∏è‚É£", "üçé"];
                    translations = ["ÿ≥ŸÖŸÉÿ©", "ÿ≤Ÿáÿ±ÿ©", "ÿ∂ŸÅÿØÿπ", "ÿπŸÑŸÖ", "ŸÜÿßÿ±", "ÿ´ÿπŸÑÿ®", "ŸÖÿ±Ÿàÿ≠ÿ©", "ÿ¥ŸàŸÉÿ©", "ÿÆŸÖÿ≥ÿ©", "ŸÅÿßŸÉŸáÿ©"];
                    break;
                case 'G':
                    words = ["Goat", "Grapes", "Guitar", "Glasses", "Garden", "Gift", "Girl", "Grass", "Green", "Giraffe"];
                    emojis = ["üêê", "üçá", "üé∏", "üëì", "üå≥", "üéÅ", "üëß", "üåø", "üü¢", "ü¶í"];
                    translations = ["ŸÖÿßÿπÿ≤", "ÿπŸÜÿ®", "ÿ¨Ÿäÿ™ÿßÿ±", "ŸÜÿ∏ÿßÿ±ÿßÿ™", "ÿ≠ÿØŸäŸÇÿ©", "ŸáÿØŸäÿ©", "ŸÅÿ™ÿßÿ©", "ÿπÿ¥ÿ®", "ÿ£ÿÆÿ∂ÿ±", "ÿ≤ÿ±ÿßŸÅÿ©"];
                    break;
                case 'H':
                    words = ["House", "Horse", "Hat", "Heart", "Hand", "Honey", "Hippo", "Hammer", "Helicopter", "Hen"];
                    emojis = ["üè†", "üê¥", "üé©", "‚ù§Ô∏è", "‚úã", "üçØ", "ü¶õ", "üî®", "üöÅ", "üêî"];
                    translations = ["ŸÖŸÜÿ≤ŸÑ", "ÿ≠ÿµÿßŸÜ", "ŸÇÿ®ÿπÿ©", "ŸÇŸÑÿ®", "ŸäÿØ", "ÿπÿ≥ŸÑ", "ŸÅÿ±ÿ≥ ÿßŸÑŸÜŸáÿ±", "ŸÖÿ∑ÿ±ŸÇÿ©", "ŸáŸÑŸäŸÉŸàÿ®ÿ™ÿ±", "ÿØÿ¨ÿßÿ¨ÿ©"];
                    break;
                case 'I':
                    words = ["Ice", "Igloo", "Insect", "Island", "Ice Cream", "Ink", "Iron", "Idea", "Ill", "Inside"];
                    emojis = ["üßä", "üßä", "üêõ", "üèùÔ∏è", "üç¶", "üñãÔ∏è", "üî•", "üí°", "ü§í", "üè†"];
                    translations = ["ÿ¨ŸÑŸäÿØ", "ÿ®Ÿäÿ™ ÿ¨ŸÑŸäÿØŸä", "ÿ≠ÿ¥ÿ±ÿ©", "ÿ¨ÿ≤Ÿäÿ±ÿ©", "ÿ¢Ÿäÿ≥ ŸÉÿ±ŸäŸÖ", "ÿ≠ÿ®ÿ±", "ŸÖŸÉŸàÿßÿ©", "ŸÅŸÉÿ±ÿ©", "ŸÖÿ±Ÿäÿ∂", "ÿØÿßÿÆŸÑ"];
                    break;
                case 'J':
                    words = ["Juice", "Jellyfish", "Jacket", "Jar", "Jewel", "Jet", "Jeep", "Jam", "Jump", "Jungle"];
                    emojis = ["üßÉ", "ü™º", "üß•", "ü´ô", "üíé", "‚úàÔ∏è", "üöô", "üçØ", "üèÉ", "üå¥"];
                    translations = ["ÿπÿµŸäÿ±", "ŸÇŸÜÿØŸäŸÑ ÿ®ÿ≠ÿ±", "ÿ≥ÿ™ÿ±ÿ©", "ÿ¨ÿ±ÿ©", "ÿ¨ŸàŸáÿ±ÿ©", "ÿ∑ÿßÿ¶ÿ±ÿ© ŸÜŸÅÿßÿ´ÿ©", "ÿ¨Ÿäÿ®", "ŸÖÿ±ÿ®Ÿâ", "ŸÇŸÅÿ≤", "ÿ∫ÿßÿ®ÿ©"];
                    break;
                case 'K':
                    words = ["Key", "Kite", "Kangaroo", "King", "Kitchen", "Kitten", "Kiwi", "Koala", "Kettle", "Kick"];
                    emojis = ["üîë", "ü™Å", "ü¶ò", "ü§¥", "üç≥", "üê±", "ü•ù", "üê®", "ü´ñ", "‚öΩ"];
                    translations = ["ŸÖŸÅÿ™ÿßÿ≠", "ÿ∑ÿßÿ¶ÿ±ÿ© Ÿàÿ±ŸÇŸäÿ©", "ŸÉŸÜÿ∫ÿ±", "ŸÖŸÑŸÉ", "ŸÖÿ∑ÿ®ÿÆ", "Ÿáÿ±Ÿäÿ±ÿ©", "ŸÉŸäŸàŸä", "ŸÉŸàÿßŸÑÿß", "ÿ∫ŸÑÿßŸäÿ©", "ÿ±ŸÉŸÑ"];
                    break;
                case 'L':
                    words = ["Lion", "Lemon", "Leaf", "Ladder", "Light", "Lamp", "Lock", "Log", "Lips", "Ladybug"];
                    emojis = ["ü¶Å", "üçã", "üçÉ", "ü™ú", "üí°", "ü™î", "üîí", "ü™µ", "üëÑ", "üêû"];
                    translations = ["ÿ£ÿ≥ÿØ", "ŸÑŸäŸÖŸàŸÜ", "Ÿàÿ±ŸÇÿ©", "ÿ≥ŸÑŸÖ", "ÿ∂Ÿàÿ°", "ŸÖÿµÿ®ÿßÿ≠", "ŸÇŸÅŸÑ", "ÿ¨ÿ∞ÿπ", "ÿ¥ŸÅÿßŸá", "ÿØÿπÿ≥ŸàŸÇÿ©"];
                    break;
                case 'M':
                    words = ["Monkey", "Moon", "Milk", "Mouse", "Mountain", "Music", "Map", "Man", "Mug", "Mushroom"];
                    emojis = ["üêí", "üåô", "ü•õ", "üê≠", "‚õ∞Ô∏è", "üéµ", "üó∫Ô∏è", "üë®", "‚òï", "üçÑ"];
                    translations = ["ŸÇÿ±ÿØ", "ŸÇŸÖÿ±", "ÿ≠ŸÑŸäÿ®", "ŸÅÿ£ÿ±", "ÿ¨ÿ®ŸÑ", "ŸÖŸàÿ≥ŸäŸÇŸâ", "ÿÆÿ±Ÿäÿ∑ÿ©", "ÿ±ÿ¨ŸÑ", "ŸÉŸàÿ®", "ŸÅÿ∑ÿ±"];
                    break;
                case 'N':
                    words = ["Nest", "Nose", "Nut", "Night", "Nurse", "Numbers", "Net", "Nine", "Neck", "Nail"];
                    emojis = ["ü™π", "üëÉ", "ü•ú", "üåô", "üë©‚Äç‚öïÔ∏è", "üî¢", "ü•Ö", "9Ô∏è‚É£", "üß£", "üíÖ"];
                    translations = ["ÿπÿ¥", "ÿ£ŸÜŸÅ", "ŸÖŸÉÿ≥ÿ±ÿßÿ™", "ŸÑŸäŸÑ", "ŸÖŸÖÿ±ÿ∂ÿ©", "ÿ£ÿ±ŸÇÿßŸÖ", "ÿ¥ÿ®ŸÉÿ©", "ÿ™ÿ≥ÿπÿ©", "ÿ±ŸÇÿ®ÿ©", "ÿ∏ŸÅÿ±"];
                    break;
                case 'O':
                    words = ["Orange", "Owl", "Octopus", "Ocean", "Onion", "Ostrich", "Olive", "Oven", "One", "Ox"];
                    emojis = ["üçä", "ü¶â", "üêô", "üåä", "üßÖ", "ü¶§", "ü´í", "üç≥", "1Ô∏è‚É£", "üêÇ"];
                    translations = ["ÿ®ÿ±ÿ™ŸÇÿßŸÑ", "ÿ®ŸàŸÖÿ©", "ÿ£ÿÆÿ∑ÿ®Ÿàÿ∑", "ŸÖÿ≠Ÿäÿ∑", "ÿ®ÿµŸÑ", "ŸÜÿπÿßŸÖÿ©", "ÿ≤Ÿäÿ™ŸàŸÜ", "ŸÅÿ±ŸÜ", "Ÿàÿßÿ≠ÿØ", "ÿ´Ÿàÿ±"];
                    break;
                case 'P':
                    words = ["Penguin", "Pizza", "Pencil", "Panda", "Pineapple", "Pear", "Pig", "Pen", "Pot", "Pumpkin"];
                    emojis = ["üêß", "üçï", "‚úèÔ∏è", "üêº", "üçç", "üçê", "üê∑", "üñäÔ∏è", "üç≤", "üéÉ"];
                    translations = ["ÿ®ÿ∑ÿ±ŸäŸÇ", "ÿ®Ÿäÿ™ÿ≤ÿß", "ŸÇŸÑŸÖ ÿ±ÿµÿßÿµ", "ÿ®ÿßŸÜÿØÿß", "ÿ£ŸÜÿßŸÜÿßÿ≥", "ŸÉŸÖÿ´ÿ±Ÿâ", "ÿÆŸÜÿ≤Ÿäÿ±", "ŸÇŸÑŸÖ ÿ≠ÿ®ÿ±", "ŸÇÿØÿ±", "ŸäŸÇÿ∑ŸäŸÜ"];
                    break;
                case 'Q':
                    words = ["Queen", "Quilt", "Question", "Quack", "Quarter", "Quiet", "Queue", "Quick", "Quiz", "Quill"];
                    emojis = ["üë∏", "üõèÔ∏è", "‚ùì", "ü¶Ü", "ü™ô", "ü§´", "üö∂", "‚ö°", "üìù", "ü™∂"];
                    translations = ["ŸÖŸÑŸÉÿ©", "ŸÑÿ≠ÿßŸÅ", "ÿ≥ÿ§ÿßŸÑ", "ÿµÿ±ÿÆÿ© ÿ®ÿ∑ÿ©", "ÿ±ÿ®ÿπ", "ŸáÿßÿØÿ¶", "ÿ∑ÿßÿ®Ÿàÿ±", "ÿ≥ÿ±Ÿäÿπ", "ÿßÿÆÿ™ÿ®ÿßÿ±", "ÿ±Ÿäÿ¥ÿ©"];
                    break;
                case 'R':
                    words = ["Rabbit", "Rainbow", "Robot", "Rose", "Rocket", "Ring", "Rat", "Rain", "Red", "Radio"];
                    emojis = ["üê∞", "üåà", "ü§ñ", "üåπ", "üöÄ", "üíç", "üêÄ", "üåßÔ∏è", "üî¥", "üìª"];
                    translations = ["ÿ£ÿ±ŸÜÿ®", "ŸÇŸàÿ≥ ŸÇÿ≤ÿ≠", "ÿ±Ÿàÿ®Ÿàÿ™", "Ÿàÿ±ÿØÿ©", "ÿµÿßÿ±ŸàÿÆ", "ÿÆÿßÿ™ŸÖ", "ÿ¨ÿ±ÿ∞", "ŸÖÿ∑ÿ±", "ÿ£ÿ≠ŸÖÿ±", "ÿ±ÿßÿØŸäŸà"];
                    break;
                case 'S':
                    words = ["Sun", "Star", "Snake", "Spider", "Strawberry", "Ship", "Spoon", "Sock", "Six", "Snow"];
                    emojis = ["‚òÄÔ∏è", "‚≠ê", "üêç", "üï∑Ô∏è", "üçì", "üö¢", "ü•Ñ", "üß¶", "6Ô∏è‚É£", "‚ùÑÔ∏è"];
                    translations = ["ÿ¥ŸÖÿ≥", "ŸÜÿ¨ŸÖÿ©", "ÿ´ÿπÿ®ÿßŸÜ", "ÿπŸÜŸÉÿ®Ÿàÿ™", "ŸÅÿ±ÿßŸàŸÑÿ©", "ÿ≥ŸÅŸäŸÜÿ©", "ŸÖŸÑÿπŸÇÿ©", "ÿ¨Ÿàÿ±ÿ®", "ÿ≥ÿ™ÿ©", "ÿ´ŸÑÿ¨"];
                    break;
                case 'T':
                    words = ["Tiger", "Tree", "Table", "Train", "Tomato", "Turtle", "Ten", "Tent", "Taxi", "Tea"];
                    emojis = ["üêØ", "üå≥", "ü™ë", "üöÇ", "üçÖ", "üê¢", "üîü", "‚õ∫", "üöï", "üçµ"];
                    translations = ["ŸÜŸÖÿ±", "ÿ¥ÿ¨ÿ±ÿ©", "ÿ∑ÿßŸàŸÑÿ©", "ŸÇÿ∑ÿßÿ±", "ÿ∑ŸÖÿßÿ∑ŸÖ", "ÿ≥ŸÑÿ≠ŸÅÿßÿ©", "ÿπÿ¥ÿ±ÿ©", "ÿÆŸäŸÖÿ©", "ÿ™ÿßŸÉÿ≥Ÿä", "ÿ¥ÿßŸä"];
                    break;
                case 'U':
                    words = ["Umbrella", "Unicorn", "Uniform", "Ukulele", "Up", "Under", "Uncle", "Urn", "Umpire", "Unhappy"];
                    emojis = ["‚òÇÔ∏è", "ü¶Ñ", "üëî", "üéµ", "‚¨ÜÔ∏è", "‚¨áÔ∏è", "üë®", "‚ö±Ô∏è", "üï¥Ô∏è", "‚òπÔ∏è"];
                    translations = ["ŸÖÿ∏ŸÑÿ©", "ÿ≠ÿµÿßŸÜ Ÿàÿ≠ŸäÿØ ÿßŸÑŸÇÿ±ŸÜ", "ÿ≤Ÿä ŸÖŸàÿ≠ÿØ", "ÿπŸàÿØ", "ÿ£ÿπŸÑŸâ", "ÿ™ÿ≠ÿ™", "ÿπŸÖ", "ÿ¨ÿ±ÿ©", "ÿ≠ŸÉŸÖ", "ÿ≠ÿ≤ŸäŸÜ"];
                    break;
                case 'V':
                    words = ["Violin", "Volcano", "Vegetable", "Van", "Vase", "Vacuum", "Vest", "Vet", "Village", "Vulture"];
                    emojis = ["üéª", "üåã", "ü•¶", "üöê", "üè∫", "üßπ", "ü¶∫", "üë®‚Äç‚öïÔ∏è", "üèòÔ∏è", "ü¶Ö"];
                    translations = ["ŸÉŸÖÿßŸÜ", "ÿ®ÿ±ŸÉÿßŸÜ", "ÿÆÿ∂ÿßÿ±", "ÿ¥ÿßÿ≠ŸÜÿ©", "ŸÖÿ≤Ÿáÿ±Ÿäÿ©", "ŸÖŸÉŸÜÿ≥ÿ© ŸÉŸáÿ±ÿ®ÿßÿ¶Ÿäÿ©", "ÿ≥ÿ™ÿ±ÿ©", "ÿ∑ÿ®Ÿäÿ® ÿ®Ÿäÿ∑ÿ±Ÿä", "ŸÇÿ±Ÿäÿ©", "ŸÜÿ≥ÿ±"];
                    break;
                case 'W':
                    words = ["Watermelon", "Whale", "Wheel", "Wolf", "Window", "Watch", "Water", "Web", "Worm", "Wall"];
                    emojis = ["üçâ", "üêã", "üõû", "üê∫", "ü™ü", "‚åö", "üíß", "üï∏Ô∏è", "ü™±", "üß±"];
                    translations = ["ÿ®ÿ∑ŸäÿÆ", "ÿ≠Ÿàÿ™", "ÿπÿ¨ŸÑÿ©", "ÿ∞ÿ¶ÿ®", "ŸÜÿßŸÅÿ∞ÿ©", "ÿ≥ÿßÿπÿ©", "ŸÖÿßÿ°", "ÿ¥ÿ®ŸÉÿ©", "ÿØŸàÿØÿ©", "ÿ¨ÿØÿßÿ±"];
                    break;
                case 'X':
                    words = ["Xylophone", "X-ray", "Xmas", "Box", "Six", "Fox", "Mix", "Wax", "Ox", "Taxi"];
                    emojis = ["üéµ", "üì∏", "üéÑ", "üì¶", "6Ô∏è‚É£", "ü¶ä", "ü•£", "üïØÔ∏è", "üêÇ", "üöï"];
                    translations = ["ÿ•ŸÉÿ≥ŸäŸÑŸäŸÅŸàŸÜ", "ÿ£ÿ¥ÿπÿ© ÿ•ŸÉÿ≥", "ŸÉÿ±Ÿäÿ≥ŸÖÿßÿ≥", "ÿµŸÜÿØŸàŸÇ", "ÿ≥ÿ™ÿ©", "ÿ´ÿπŸÑÿ®", "ÿÆŸÑÿ∑", "ÿ¥ŸÖÿπ", "ÿ´Ÿàÿ±", "ÿ™ÿßŸÉÿ≥Ÿä"];
                    break;
                case 'Y':
                    words = ["Yoyo", "Yacht", "Yogurt", "Yellow", "Yak", "Yarn", "Yard", "Year", "Yes", "Yolk"];
                    emojis = ["ü™Ä", "üö§", "ü•õ", "üü°", "üêÇ", "üß∂", "üè°", "üìÖ", "üëç", "ü•ö"];
                    translations = ["ŸäŸàŸäŸà", "ŸäÿÆÿ™", "ÿ≤ÿ®ÿßÿØŸä", "ÿ£ÿµŸÅÿ±", "ŸäÿßŸÉ", "ÿÆŸäÿ∑", "ŸÅŸÜÿßÿ°", "ÿ≥ŸÜÿ©", "ŸÜÿπŸÖ", "ÿµŸÅÿßÿ± ÿßŸÑÿ®Ÿäÿ∂"];
                    break;
                case 'Z':
                    words = ["Zebra", "Zoo", "Zero", "Zipper", "Zigzag", "Zoom", "Zucchini", "Zone", "Zap", "Zeppelin"];
                    emojis = ["ü¶ì", "üêÖ", "0Ô∏è‚É£", "ü§ê", "‚ö°", "üîç", "ü•í", "üöß", "‚ö°", "üéà"];
                    translations = ["ÿ≠ŸÖÿßÿ± Ÿàÿ≠ÿ¥Ÿä", "ÿ≠ÿØŸäŸÇÿ© ÿ≠ŸäŸàÿßŸÜÿßÿ™", "ÿµŸÅÿ±", "ÿ≥ÿ≠ÿßÿ®", "ŸÖÿ™ÿπÿ±ÿ¨", "ÿ™ŸÉÿ®Ÿäÿ±", "ŸÉŸàÿ≥ÿ©", "ŸÖŸÜÿ∑ŸÇÿ©", "ÿµÿπŸÇ", "ŸÖŸÜÿ∑ÿßÿØ"];
                    break;
                default:
                    words = ["Apple", "Ant", "Airplane", "Arrow", "Astronaut", "Alligator", "Arm", "Anchor", "Axe", "Apricot"];
                    emojis = ["üçé", "üêú", "‚úàÔ∏è", "üèπ", "üßë‚ÄçüöÄ", "üêä", "üí™", "‚öì", "ü™ì", "üçë"];
                    translations = ["ÿ™ŸÅÿßÿ≠ÿ©", "ŸÜŸÖŸÑÿ©", "ÿ∑ÿßÿ¶ÿ±ÿ©", "ÿ≥ŸáŸÖ", "ÿ±ÿßÿ¶ÿØ ŸÅÿ∂ÿßÿ°", "ÿ™ŸÖÿ≥ÿßÿ≠", "ÿ∞ÿ±ÿßÿπ", "ŸÖÿ±ÿ≥ÿßÿ©", "ŸÅÿ£ÿ≥", "ŸÖÿ¥ŸÖÿ¥"];
            }
            
            LETTER_DATA[letter] = {
                words: words.map((word, index) => ({
                    word: word.toLowerCase(),
                    translation: translations[index] || word,
                    emoji: emojis[index] || "üî§"
                })),
                quiz: generateQuizForLetter(letter, words, emojis, translations),
                type: ["A", "E", "I", "O", "U"].includes(letter) ? "ÿ≠ÿ±ŸÅ ŸÖÿ™ÿ≠ÿ±ŸÉ" : "ÿ≠ÿ±ŸÅ ÿ≥ÿßŸÉŸÜ"
            };
        });

        // ŸÖÿ≥ÿßÿπÿØÿßÿ™ ŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ≠ÿ±ŸàŸÅ
        function getLetterSound(letter) {
            const sounds = {
                'A': '√¶', 'B': 'b', 'C': 'k', 'D': 'd', 'E': 'e', 
                'F': 'f', 'G': 'g', 'H': 'h', 'I': '…™', 'J': 'd í',
                'K': 'k', 'L': 'l', 'M': 'm', 'N': 'n', 'O': '…í',
                'P': 'p', 'Q': 'kw', 'R': 'r', 'S': 's', 'T': 't',
                'U': ' å', 'V': 'v', 'W': 'w', 'X': 'ks', 'Y': 'j', 'Z': 'z'
            };
            return sounds[letter] || '√¶';
        }

        function generateQuizForLetter(letter, words, emojis, translations) {
            // ŸÇÿßÿ¶ŸÖÿ© ŸÉŸÑŸÖÿßÿ™ ŸÑŸÑÿ™ŸÖŸàŸäŸá (Distractors)
            const commonDistractors = ["apple", "ball", "cat", "dog", "egg", "fish", "goat", "hat", "ice", "juice", "kite", "lion", "monkey", "nest", "orange", "pizza", "queen", "rabbit", "sun", "tiger", "umbrella", "van", "watch", "box", "yoyo", "zebra"];
            const commonEmojis = ["üçé", "‚öΩ", "üê±", "üê∂", "ü•ö", "üêü", "üêê", "üé©", "üßä", "üßÉ", "ü™Å", "ü¶Å", "üêí", "ü™π", "üçä", "üçï", "üë∏", "üê∞", "‚òÄÔ∏è", "üêØ", "‚òÇÔ∏è", "üöê", "‚åö", "üì¶", "ü™Ä", "ü¶ì"];
            
            // ÿßÿ≥ÿ™ÿ®ÿπÿßÿØ ŸÉŸÑŸÖÿßÿ™ ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿ≠ÿßŸÑŸä ŸÖŸÜ ÿßŸÑÿ™ŸÖŸàŸäŸá
            const validDistractors = commonDistractors.filter(w => !w.toLowerCase().startsWith(letter.toLowerCase()));
            const validEmojiDistractors = commonEmojis.filter((e, i) => !commonDistractors[i].toLowerCase().startsWith(letter.toLowerCase()));
            
            // ÿÆŸÑÿ∑ ŸàÿßÿÆÿ™Ÿäÿßÿ± ŸÖŸÖŸàŸáÿßÿ™ ÿπÿ¥Ÿàÿßÿ¶Ÿäÿ©
            const getRandom = (arr, count) => arr.sort(() => 0.5 - Math.random()).slice(0, count);
            
            const wrongWords = getRandom(validDistractors, 3);
            const wrongEmojis = getRandom(validEmojiDistractors, 3);
            
            // ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© (ÿ£ŸàŸÑ ŸÉŸÑŸÖÿ© ŸÅŸä ÿßŸÑŸÇÿßÿ¶ŸÖÿ©)
            const correctWord = words[0].toLowerCase();
            const correctEmoji = emojis ? emojis[0] : "‚ùì";
            
            // ÿÆŸäÿßÿ±ÿßÿ™ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ´ÿßŸÜŸä (ŸÉŸÑŸÖÿ© ÿ™ÿ®ÿØÿ£ ÿ®ÿßŸÑÿ≠ÿ±ŸÅ)
            const q2Options = [correctWord, ...wrongWords].sort(() => 0.5 - Math.random());
            const q2CorrectIndex = q2Options.indexOf(correctWord);
            
            // ÿÆŸäÿßÿ±ÿßÿ™ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ±ÿßÿ®ÿπ (ÿµŸàÿ±ÿ© ÿ™ÿ®ÿØÿ£ ÿ®ÿßŸÑÿ≠ÿ±ŸÅ)
            const q4Options = [correctEmoji, ...wrongEmojis].sort(() => 0.5 - Math.random());
            const q4CorrectIndex = q4Options.indexOf(correctEmoji);
            
            // ÿÆŸäÿßÿ±ÿßÿ™ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ≥ÿßÿØÿ≥ (ŸÖÿπŸÜŸâ ÿßŸÑŸÉŸÑŸÖÿ©)
            // ŸÜÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑÿ´ÿßŸÜŸäÿ© ŸÉŸáÿØŸÅ
            const targetWordForTrans = words[1] ? words[1].toLowerCase() : correctWord;
            const targetTrans = translations && translations[1] ? translations[1] : (translations ? translations[0] : "ŸÖÿπŸÜŸâ");
            
            // ŸÖŸÖŸàŸáÿßÿ™ ŸÑŸÑŸÖÿπŸÜŸâ (ŸÜÿ≠ÿ™ÿßÿ¨ ÿ™ÿ±ÿ¨ŸÖÿßÿ™ ÿπÿ¥Ÿàÿßÿ¶Ÿäÿ©)
            const allTranslations = ["ÿ™ŸÅÿßÿ≠ÿ©", "ŸÉÿ±ÿ©", "ŸÇÿ∑ÿ©", "ŸÉŸÑÿ®", "ÿ®Ÿäÿ∂ÿ©", "ÿ≥ŸÖŸÉÿ©", "ŸÖÿßÿπÿ≤", "ŸÇÿ®ÿπÿ©", "ÿ´ŸÑÿ¨", "ÿπÿµŸäÿ±", "ÿ∑ÿßÿ¶ÿ±ÿ© Ÿàÿ±ŸÇŸäÿ©", "ÿ£ÿ≥ÿØ", "ŸÇÿ±ÿØ", "ÿπÿ¥", "ÿ®ÿ±ÿ™ŸÇÿßŸÑ", "ÿ®Ÿäÿ™ÿ≤ÿß", "ŸÖŸÑŸÉÿ©", "ÿ£ÿ±ŸÜÿ®", "ÿ¥ŸÖÿ≥", "ŸÜŸÖÿ±", "ŸÖÿ∏ŸÑÿ©", "ÿ¥ÿßÿ≠ŸÜÿ©", "ÿ≥ÿßÿπÿ©", "ÿµŸÜÿØŸàŸÇ", "ŸäŸàŸäŸà", "ÿ≠ŸÖÿßÿ± Ÿàÿ≠ÿ¥Ÿä"];
            const wrongTrans = getRandom(allTranslations.filter(t => t !== targetTrans), 3);
            const q6Options = [targetTrans, ...wrongTrans].sort(() => 0.5 - Math.random());
            const q6CorrectIndex = q6Options.indexOf(targetTrans);

            return [
                {
                    question: `ŸÖÿß ŸáŸà ÿßŸÑÿµŸàÿ™ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿä ŸÑŸÑÿ≠ÿ±ŸÅ ${letter}ÿü`,
                    options: [
                        `/${getLetterSound(letter)}/ ŸÉŸÖÿß ŸÅŸä ${correctWord}`,
                        "/…ë:/ ŸÉŸÖÿß ŸÅŸä arm",
                        "/e…™/ ŸÉŸÖÿß ŸÅŸä ace",
                        "/…™/ ŸÉŸÖÿß ŸÅŸä ink"
                    ],
                    correct: 0
                },
                {
                    question: `ÿ£Ÿä ŸÖŸÜ Ÿáÿ∞Ÿá ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿ™ÿ®ÿØÿ£ ÿ®ÿßŸÑÿ≠ÿ±ŸÅ ${letter}ÿü`,
                    options: q2Options,
                    correct: q2CorrectIndex
                },
                {
                    question: `ŸÖÿß ŸáŸà ÿ¥ŸÉŸÑ ÿßŸÑÿ≠ÿ±ŸÅ ${letter} ÿßŸÑÿµÿ∫Ÿäÿ±ÿü`,
                    options: [letter, letter.toLowerCase(), "Œ±", letter.toLowerCase() + letter.toLowerCase()],
                    correct: 1
                },
                {
                    question: `ÿ£Ÿä ŸÖŸÜ Ÿáÿ∞Ÿá ÿßŸÑÿµŸàÿ± ÿ™ÿ®ÿØÿ£ ÿ®ÿßŸÑÿ≠ÿ±ŸÅ ${letter}ÿü`,
                    options: q4Options,
                    correct: q4CorrectIndex
                },
                {
                    question: `ŸÖÿß ŸÜŸàÿπ ÿßŸÑÿ≠ÿ±ŸÅ ${letter}ÿü`,
                    options: [
                        "ÿ≠ÿ±ŸÅ ŸÖÿ™ÿ≠ÿ±ŸÉ (Vowel)",
                        "ÿ≠ÿ±ŸÅ ÿ≥ÿßŸÉŸÜ (Consonant)",
                        "ÿ±ŸÇŸÖ",
                        "ÿ±ŸÖÿ≤"
                    ],
                    correct: ["A", "E", "I", "O", "U"].includes(letter) ? 0 : 1
                },
                {
                    question: `ŸÖÿß ŸÖÿπŸÜŸâ ŸÉŸÑŸÖÿ© "${targetWordForTrans}"ÿü`,
                    options: q6Options,
                    correct: q6CorrectIndex
                }
            ];
        }

        // ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä ÿßŸÑŸÖÿ≠ÿ≥ŸÜ
        class PhonicsGameLab {
            constructor() {
                // Performance optimization variables
                this.maxFPS = 60;
                this.lastFrameTime = 0;
                this.frameInterval = 1000 / this.maxFPS;
                this.gameRunning = false;
                this.activeAnimations = new Set();
                
                this.REQUIRED_SCORE = 14;
                this.PROGRESS_KEY_PREFIX = 'phonicsProgress';
                this.ANONYMOUS_ID_KEY = 'phonicsAnonymousId';
                this.userIdentifier = this.resolveCurrentUserIdentifier();
                this.progressStorageKey = this.getProgressKey();
                this.progress = this.loadProgressState();

                // Required games for progression (updated)
                this.requiredGames = ['match', 'balloons', 'memory'];
                this.mandatoryGames = this.requiredGames;

                this.syncProgressDerivedState();

                this.currentLetterIndex = LETTERS.indexOf(this.progress.currentLetter) >= 0 ? LETTERS.indexOf(this.progress.currentLetter) : 0;
                this.currentQuizIndex = 0;
                this.quizScore = 0;
                this.writingScore = 0;
                this.wordsScore = 0;
                
                // Game state management
                this.isGameEnding = false;
                this.isCelebrating = false;
                this.isMiniCelebrating = false;
                this.isConfettiActive = false;
                this.gameTimeouts = [];
                
                // ÿØŸÖÿ¨ letterProgress ŸÅŸä ÿ®ŸÜŸäÿ© progress ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©
                // this.letterProgress = JSON.parse(localStorage.getItem('letterProgress')) || {}; // OLD: This was the cause of the bug

                // Profile Data
                this.studentName = localStorage.getItem('studentName') || '';
                this.studentSchool = localStorage.getItem('studentSchool') || '';
                this.studentPhone = localStorage.getItem('studentPhone') || '';
                this.parentPhone = localStorage.getItem('parentPhone') || '';
                this.studentEmail = localStorage.getItem('studentEmail') || '';

                this.currentGame = null;
                this.isNightMode = localStorage.getItem('nightMode') === 'true';
                this.gameInterval = null;
                this.gameTimeLeft = 60;
                this.soundEnabled = localStorage.getItem('soundEnabled') !== 'false';
                this.speechRecognition = null;
                this.isListening = false;
                this.micPermissionGranted = false;
                this.audioContext = null;
                this.analyser = null;
                this.microphone = null;
                this.audioStream = null;
                this.soundManager = new BritishSoundManager();
                this.soundManager.isSpeakingEnabled = this.soundEnabled;
                this.gameStats = {
                    successCount: 0,
                    totalAttempts: 0,
                    accuracy: 0,
                    difficulty: 1,
                    gameWins: 0
                };
                this.isPaused = false;
                this.touchControls = {
                    left: false,
                    right: false,
                    up: false,
                    down: false,
                    action: false
                };
                this.quizCompletedFlag = false;
                this.isAnswerSelected = false;
                this.currentQuizAnswer = null;
                this.quizTimeout = null;
                this.gameObjects = [];
                this.gameAnimationFrame = null;
                this.currentKeyHandlers = null;
                this.currentClickHandler = null;
                this.currentMouseHandlers = null;
                
                this.init();
            }
            
            init() {
                this.cacheDOM();
                this.bindEvents();
                this.renderLettersNav();
                this.loadLetter(this.currentLetterIndex);
                this.updateProgress();
                this.setupScrollTop();
                this.setupTheme();
                this.renderAchievements();
                this.setupLetterJumpMenu();
                
                if (this.studentName) {
                    const nameInput = document.getElementById('studentName');
                    if (nameInput) nameInput.value = this.studentName;
                }
                
                if (this.completedLetters.length === LETTERS.length) {
                    this.showCompletionAnimation();
                }
                
                this.setupSpeechRecognition();
                this.setupAudioVisualizer();
                this.checkMicrophonePermission();
                this.setupTouchControls();
                
                this.soundManager.initialize();
                this.disableCopyPaste();

                // Mobile Audio Unlock & Resize Handling
                const unlockAudio = () => {
                    if (this.soundManager.audioContext && this.soundManager.audioContext.state === 'suspended') {
                        this.soundManager.audioContext.resume();
                    }
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    document.removeEventListener('touchstart', unlockAudio);
                    document.removeEventListener('click', unlockAudio);
                };
                document.addEventListener('touchstart', unlockAudio, { passive: true });
                document.addEventListener('click', unlockAudio);

                // Initial resize
                if (this.handleResize) this.handleResize();
            }

            resolveCurrentUserIdentifier() {
                const globalIdentifier = this.detectUserIdentifierFromGlobals();
                if (globalIdentifier) {
                    return globalIdentifier;
                }

                const domIdentifier = this.detectUserIdentifierFromDOM();
                if (domIdentifier) {
                    return domIdentifier;
                }

                const storedEmail = this.normalizeIdentifier(localStorage.getItem('studentEmail'));
                if (storedEmail) {
                    return storedEmail;
                }

                return this.getOrCreateAnonymousId();
            }

            detectUserIdentifierFromGlobals() {
                const idCandidates = [
                    window.currentUserId,
                    window.currentUserID,
                    window.userId,
                    window.userID,
                    window.studentId,
                    window.studentID,
                    window.phonicsUserId,
                    window.PHONICS_USER_ID,
                    window.PHONICS_STUDENT_ID
                ];

                for (const candidate of idCandidates) {
                    const normalized = this.normalizeIdentifier(candidate);
                    if (normalized) {
                        return normalized;
                    }
                }

                const emailCandidates = [
                    window.currentUserEmail,
                    window.userEmail,
                    window.studentEmail,
                    window.phonicsUserEmail,
                    window.PHONICS_USER_EMAIL
                ];

                for (const candidate of emailCandidates) {
                    const normalized = this.normalizeIdentifier(candidate);
                    if (normalized) {
                        return normalized;
                    }
                }

                return '';
            }

            detectUserIdentifierFromDOM() {
                const metaId = document.querySelector('meta[name="phonics-user-id"], meta[name="current-user-id"], meta[name="user-id"]');
                if (metaId && metaId.content) {
                    const normalizedMetaId = this.normalizeIdentifier(metaId.content);
                    if (normalizedMetaId) {
                        return normalizedMetaId;
                    }
                }

                const metaEmail = document.querySelector('meta[name="phonics-user-email"], meta[name="current-user-email"], meta[name="user-email"]');
                if (metaEmail && metaEmail.content) {
                    const normalizedMetaEmail = this.normalizeIdentifier(metaEmail.content);
                    if (normalizedMetaEmail) {
                        return normalizedMetaEmail;
                    }
                }

                const candidateElements = [
                    document.querySelector('[data-phonics-user-id]'),
                    document.querySelector('[data-user-id]'),
                    document.querySelector('[data-student-id]'),
                    document.querySelector('[data-phonics-user-email]'),
                    document.querySelector('[data-user-email]'),
                    document.querySelector('[data-student-email]'),
                    document.body,
                    document.getElementById('phonicsApp'),
                    document.getElementById('app')
                ].filter(Boolean);

                const datasetKeys = [
                    'phonicsUserId',
                    'userId',
                    'userid',
                    'studentId',
                    'student',
                    'accountId',
                    'phonicsUserEmail',
                    'userEmail',
                    'email',
                    'studentEmail'
                ];

                const attributeKeys = [
                    'data-phonics-user-id',
                    'data-user-id',
                    'data-student-id',
                    'data-phonics-user-email',
                    'data-user-email',
                    'data-student-email'
                ];

                for (const element of candidateElements) {
                    if (!element) continue;

                    const dataset = element.dataset || {};
                    for (const key of datasetKeys) {
                        const camelKey = key.replace(/-([a-z])/g, (_, char) => char.toUpperCase());
                        const value = dataset[camelKey] ?? dataset[key] ?? dataset[key.toLowerCase()];
                        const normalized = this.normalizeIdentifier(value);
                        if (normalized) {
                            return normalized;
                        }
                    }

                    if (element.getAttribute) {
                        for (const attr of attributeKeys) {
                            const value = element.getAttribute(attr);
                            const normalized = this.normalizeIdentifier(value);
                            if (normalized) {
                                return normalized;
                            }
                        }
                    }
                }

                return '';
            }

            normalizeIdentifier(value) {
                if (value === undefined || value === null) {
                    return '';
                }

                const str = String(value).trim();
                if (!str) {
                    return '';
                }

                return str.toLowerCase().replace(/[^a-z0-9@._-]+/g, '_');
            }

            getProgressKey(identifier = null) {
                const normalized = this.normalizeIdentifier(identifier ?? this.userIdentifier);
                const finalId = normalized || this.getOrCreateAnonymousId();
                return `${this.PROGRESS_KEY_PREFIX}_${finalId}`;
            }

            getOrCreateAnonymousId() {
                const existingAnonymousId = localStorage.getItem(this.ANONYMOUS_ID_KEY);
                const normalizedExisting = this.normalizeIdentifier(existingAnonymousId);
                if (normalizedExisting) {
                    return normalizedExisting;
                }

                const newAnonymousId = `anon_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
                localStorage.setItem(this.ANONYMOUS_ID_KEY, newAnonymousId);
                return this.normalizeIdentifier(newAnonymousId);
            }

            refreshUserIdentifier() {
                const resolvedIdentifier = this.resolveCurrentUserIdentifier();
                if (!resolvedIdentifier || resolvedIdentifier === this.userIdentifier) {
                    return;
                }

                this.userIdentifier = resolvedIdentifier;
                this.progressStorageKey = this.getProgressKey();
                this.progress = this.loadProgressState();
                this.syncProgressDerivedState();

                const currentLetter = this.progress.currentLetter || 'A';
                const indexToLoad = LETTERS.indexOf(currentLetter) >= 0 ? LETTERS.indexOf(currentLetter) : 0;

                this.loadLetter(indexToLoad);
            }

            createInitialProgressState() {
                const lettersState = {};

                LETTERS.forEach((letter, index) => {
                    lettersState[letter] = {
                        unlocked: index === 0,
                        completed: false,
                        exercisesCompleted: false,
                        score: 0,
                        games: {
                            match: false,
                            balloons: false,
                            memory: false
                        },
                        // NEW: Add detailed exercise state
                        exercises: {
                            writing: {
                                capital: {}, // { 0: 'A', 1: 'a', ... }
                                small: {}
                            },
                            words: {}, // { 'apple': 'apple', 'ant': 'ant', ... }
                            quiz: {
                                answers: {}, // { 0: 1, 1: 2, ... }
                                score: 0,
                                completed: false
                            }
                        }
                    };
                });

                return {
                    currentLetter: 'A',
                    letters: lettersState,
                    // NEW: Add user profile info to the main progress object
                    profile: {
                        name: '',
                        school: '',
                        phone: '',
                        parentPhone: ''
                    }
                };
            }

            loadProgressState() {
                try {
                    const stored = localStorage.getItem(this.progressStorageKey);
                    if (stored) {
                        const parsed = JSON.parse(stored);
                        if (parsed && parsed.letters) {
                            // Ensure all letters exist in parsed data
                            LETTERS.forEach(letter => {
                                if (!parsed.letters[letter]) {
                                    // If a letter is missing, create its initial state
                                    parsed.letters[letter] = this.createInitialProgressState().letters[letter];
                                } else {
                                    // Ensure games object exists and is structured correctly
                                    parsed.letters[letter].games = Object.assign(
                                        { match: false, balloons: false, memory: false },
                                        parsed.letters[letter].games || {}
                                    );
                                    // Migrate old 'matching' game key
                                    if (parsed.letters[letter].games.matching === true && parsed.letters[letter].games.match !== true) {
                                        parsed.letters[letter].games.match = true;
                                    }
                                    delete parsed.letters[letter].games.matching;

                                    // NEW: Ensure exercises structure exists
                                    if (!parsed.letters[letter].exercises) {
                                        parsed.letters[letter].exercises = this.createInitialProgressState().letters[letter].exercises;
                                    } else {
                                        // Ensure all sub-structures exist
                                        parsed.letters[letter].exercises.writing = parsed.letters[letter].exercises.writing || { capital: {}, small: {} };
                                        parsed.letters[letter].exercises.words = parsed.letters[letter].exercises.words || {};
                                        parsed.letters[letter].exercises.quiz = parsed.letters[letter].exercises.quiz || { answers: {}, score: 0, completed: false };
                                    }
                                }
                            });

                            if (!parsed.currentLetter || !LETTERS.includes(parsed.currentLetter)) {
                                parsed.currentLetter = 'A';
                            }
                            
                            // NEW: Ensure profile object exists
                            if (!parsed.profile) {
                                parsed.profile = this.createInitialProgressState().profile;
                            }

                            const migrated = this.applyLegacyProgress(parsed);
                            localStorage.setItem(this.progressStorageKey, JSON.stringify(migrated));
                            return migrated;
                        }
                    }
                } catch (error) {
                    console.warn('Failed to parse stored phonics progress. Resetting progress state.', error);
                }

                const initialState = this.createInitialProgressState();
                const migratedState = this.applyLegacyProgress(initialState);
                localStorage.setItem(this.progressStorageKey, JSON.stringify(migratedState));
                return migratedState;
            }

            applyLegacyProgress(progress) {
                if (!progress || progress._legacyMigrated) {
                    return progress;
                }

                try {
                    const legacyUnlocked = JSON.parse(localStorage.getItem('unlockedLetters') || '[]');
                    const legacyCompleted = JSON.parse(localStorage.getItem('completedLetters') || '[]');
                    const legacyGames = JSON.parse(localStorage.getItem('passedGames') || '{}');
                    const legacyCurrentIndex = parseInt(localStorage.getItem('currentLetterIndex'), 10);
                    const legacyLetterProgress = JSON.parse(localStorage.getItem('letterProgress') || '{}'); // Load old detailed progress

                    if (!Number.isNaN(legacyCurrentIndex) && LETTERS[legacyCurrentIndex]) {
                        progress.currentLetter = LETTERS[legacyCurrentIndex];
                    }


                    legacyUnlocked.forEach(index => {
                        const letter = LETTERS[index];
                        if (!letter) return;
                        const entry = this.ensureLetterRecordWithProgress(progress, letter);
                        entry.unlocked = true;
                    });

                    legacyCompleted.forEach(index => {
                        const letter = LETTERS[index];
                        if (!letter) return;
                        const entry = this.ensureLetterRecordWithProgress(progress, letter);
                        entry.completed = true;
                    });

                    Object.keys(legacyGames || {}).forEach(key => {
                        if (!key) return;
                        const normalizedLetter = key.toUpperCase();
                        if (!LETTERS.includes(normalizedLetter)) {
                            return;
                        }
                        const entry = this.ensureLetterRecordWithProgress(progress, normalizedLetter);
                        const gamesList = legacyGames[key] || [];
                        gamesList.forEach(game => {
                            if (!game) return;
                            const normalized = game === 'matching' ? 'match' : game.toLowerCase();
                            if (entry.games[normalized] === undefined) {
                                entry.games[normalized] = true;
                            } else {
                                entry.games[normalized] = true;
                            }
                        });
                    });

                    // NEW: Migrate detailed exercise progress from letterProgress
                    Object.keys(legacyLetterProgress).forEach(letter => {
                        if (!LETTERS.includes(letter)) return;
                        const entry = this.ensureLetterRecordWithProgress(progress, letter);
                        const oldData = legacyLetterProgress[letter];

                        if (oldData.writingBoxes) {
                            entry.exercises.writing.capital = oldData.writingBoxes.capital || {};
                            entry.exercises.writing.small = oldData.writingBoxes.small || {};
                        }
                        if (oldData.wordInputs) {
                            entry.exercises.words = oldData.wordInputs || {};
                        }
                        if (oldData.scores) {
                            entry.exercises.quiz.score = oldData.scores.quiz || 0;
                        }
                        if (oldData.quizCompleted) {
                            entry.exercises.quiz.completed = true;
                        }
                    });

                } catch (error) {
                    console.warn('Legacy progress migration failed:', error);
                }

                progress._legacyMigrated = true;
                // Clear all old keys
                localStorage.removeItem('currentLetterIndex');
                localStorage.removeItem('completedLetters');
                localStorage.removeItem('unlockedLetters');
                localStorage.removeItem('passedGames');
                localStorage.removeItem('phonicsUserId');
                localStorage.removeItem('letterProgress'); // Remove the old detailed progress key

                return progress;
            }

            ensureLetterRecordWithProgress(progress, letter) {
                // Ensure letters object exists
                if (!progress || typeof progress !== 'object') {
                    console.error('Invalid progress object');
                    return null;
                }
                if (!progress.letters) {
                    progress.letters = {};
                }
                
                // Initialize if missing
                if (!progress.letters[letter]) {
                    progress.letters[letter] = {
                        unlocked: letter === 'A',
                        completed: false,
                        exercisesCompleted: false,
                        score: 0,
                        games: { match: false, balloons: false, memory: false },
                        exercises: {
                            writing: { capital: {}, small: {} },
                            words: {},
                            quiz: { answers: {}, score: 0, completed: false }
                        }
                    };
                }
                
                const record = progress.letters[letter];
                
                // Repair structure for existing records - DEEP CHECK
                if (!record.games) record.games = { match: false, balloons: false, memory: false };
                if (!record.exercises) record.exercises = {};
                
                if (!record.exercises.writing) record.exercises.writing = { capital: {}, small: {} };
                if (!record.exercises.writing.capital) record.exercises.writing.capital = {};
                if (!record.exercises.writing.small) record.exercises.writing.small = {};
                
                if (!record.exercises.words) record.exercises.words = {};
                
                if (!record.exercises.quiz) record.exercises.quiz = { answers: {}, score: 0, completed: false };
                if (!record.exercises.quiz.answers) record.exercises.quiz.answers = {};
                
                // Fix legacy field name if present
                if (record.games.matching === true && record.games.match !== true) {
                    record.games.match = true;
                    delete record.games.matching;
                }

                return record;
            }

            saveProgressState() {
                localStorage.setItem(this.progressStorageKey, JSON.stringify(this.progress));
            }

            commitProgressUpdate() {
                this.syncProgressDerivedState();
                this.saveProgressState();
            }

            syncProgressDerivedState() {
                this.completedLetters = [];
                this.unlockedLetters = [];
                this.passedGames = {};

                LETTERS.forEach((letter, index) => {
                    const data = (this.progress.letters && this.progress.letters[letter]) || {};
                    const games = data.games || {};
                    const exercisesDone = data.exercisesCompleted === true;
                    const scoreReached = (data.score || 0) >= this.REQUIRED_SCORE;
                    const gamesCompleted = (this.requiredGames || []).every(game => games[game] === true);
                    const fullyCompleted = exercisesDone && scoreReached && gamesCompleted;

                    if (data.unlocked) {
                        this.unlockedLetters.push(index);
                    }

                    if (fullyCompleted) {
                        this.completedLetters.push(index);
                    }

                    if (data.completed !== fullyCompleted) {
                        data.completed = fullyCompleted;
                    }

                    const completedGames = Object.keys(games).filter(game => games[game]);
                    if (completedGames.length > 0) {
                        this.passedGames[letter] = completedGames;
                    }
                });
            }

            isLetterUnlocked(letter) {
                const data = this.progress.letters[letter];
                return !!(data && data.unlocked);
            }

            ensureLetterRecord(letter) {
                return this.ensureLetterRecordWithProgress(this.progress, letter);
            }

            markLetterCompleted(letter) {
                const entry = this.ensureLetterRecord(letter);
                if (!entry.completed) {
                    entry.completed = true;
                    this.commitProgressUpdate();
                }
            }

            markGameCompleted(letter, gameName) {
                const entry = this.ensureLetterRecord(letter);
                if (entry.games[gameName] !== true) {
                    entry.games[gameName] = true;
                    this.commitProgressUpdate();
                }
            }

            unlockLetter(letter) {
                const entry = this.ensureLetterRecord(letter);
                if (!entry.unlocked) {
                    entry.unlocked = true;
                    this.commitProgressUpdate();
                }
            }

            getMissingRequiredGames(letter) {
                const entry = this.ensureLetterRecord(letter);
                return this.requiredGames.filter(game => entry.games[game] !== true);
            }

            isLetterCompleted(letter) {
                const entry = this.ensureLetterRecord(letter);
                const games = entry.games || {};
                const passedExercises = entry.exercisesCompleted === true;
                const passedScore = (entry.score || 0) >= this.REQUIRED_SCORE;
                const passedGames = this.requiredGames.every(game => games[game] === true);
                return passedExercises && passedScore && passedGames;
            }

            updateLetterExerciseProgress(letter) {
                const entry = this.ensureLetterRecord(letter);
                const totalScore = this.getCurrentLetterTotalScore();
                const exercisesCompleted = this.areExercisesCompleted();
                const games = entry.games || {};
                const fullyCompleted = exercisesCompleted && totalScore >= this.REQUIRED_SCORE && (this.requiredGames || []).every(game => games[game] === true);

                const needsUpdate = entry.exercisesCompleted !== exercisesCompleted || (entry.score || 0) !== totalScore || entry.completed !== fullyCompleted;

                if (needsUpdate) {
                    entry.exercisesCompleted = exercisesCompleted;
                    entry.score = totalScore;
                    entry.completed = fullyCompleted;
                    this.commitProgressUpdate();
                }
            }

            areExercisesCompleted() {
                const letter = this.progress.currentLetter;
                if (!letter) return false;
                
                const staticData = LETTER_DATA[letter];
                const letterProgress = this.ensureLetterRecord(letter);

                // Check Writing (Capital + Small)
                const capitalCorrect = Object.keys(letterProgress.exercises.writing.capital || {}).length;
                const smallCorrect = Object.keys(letterProgress.exercises.writing.small || {}).length;
                const totalWriting = capitalCorrect + smallCorrect;
                const maxWritingScore = 20; // 10 capital + 10 small
                const writingComplete = totalWriting >= maxWritingScore;

                // Check Words
                const wordsCorrect = Object.keys(letterProgress.exercises.words || {}).length;
                const maxWordScore = staticData ? staticData.words.length : 10;
                const wordsComplete = wordsCorrect >= maxWordScore;

                // Check Quiz (Completed all questions, regardless of score)
                const answeredCount = Object.keys(letterProgress.exercises.quiz.answers || {}).length;
                const quizLength = staticData ? staticData.quiz.length : 6;
                const quizComplete = this.quizCompletedFlag === true || answeredCount >= quizLength;

                return writingComplete && wordsComplete && quizComplete;
            }

            getCurrentLetterTotalScore() {
                return this.writingScore + this.wordsScore + this.quizScore;
            }
            
            cacheDOM() {
                this.lettersNav = document.getElementById('lettersNav');
                this.currentLetterEl = document.getElementById('currentLetter');
                this.letterUpperEl = document.getElementById('letterUpper');
                this.letterLowerEl = document.getElementById('letterLower');
                this.letterForWordsEl = document.getElementById('letterForWords');
                this.wordsGrid = document.getElementById('wordsGrid');
                this.capitalWriting = document.getElementById('capitalWriting');
                this.smallWriting = document.getElementById('smallWriting');
                this.wordWritingList = document.getElementById('wordWritingList');
                this.quizQuestion = document.getElementById('quizQuestion');
                this.quizOptions = document.getElementById('quizOptions');
                this.questionNumberEl = document.getElementById('questionNumber');
                this.quizScoreEl = document.getElementById('quizScore');
                this.writingScoreEl = document.getElementById('writingScore');
                this.wordsScoreEl = document.getElementById('wordsScore');
                this.testScoreEl = document.getElementById('testScore');
                this.totalScoreEl = document.getElementById('totalScore');
                this.progressValueEl = document.getElementById('progressValue');
                this.progressBar = document.getElementById('progressBar');
                this.achievementsContainer = document.getElementById('achievementsContainer');
                this.quizNextBtn = document.getElementById('quizNextBtn');
                this.quizNavigation = document.getElementById('quizNavigation');
                
                this.playLetterBtn = document.getElementById('playLetter');
                this.letterInfoBtn = document.getElementById('letterInfo');
                this.resetLetterBtn = document.getElementById('resetLetter');
                this.prevLetterBtn = document.getElementById('prevLetter');
                this.finishLetterBtn = document.getElementById('finishLetter');
                // this.studentNameInput = document.getElementById('studentName'); // Removed old input
                this.studentProfileBtn = document.getElementById('profileBtn');
                this.studentNameDisplay = document.getElementById('studentNameDisplay');
                this.themeToggle = document.getElementById('themeToggle');
                
                // New Header Elements
                this.userMenuBtn = document.getElementById('userMenuBtn');
                this.userDropdown = document.getElementById('userDropdown');
                this.mobileMenuBtn = document.getElementById('mobileMenuBtn');
                this.closeMenuBtn = document.getElementById('closeMenuBtn');
                this.viewInstructionsBtn = document.getElementById('viewInstructions');
                
                this.resetProgressBtn = document.getElementById('resetProgressBtn');
                this.viewAllLettersBtn = document.getElementById('viewAllLetters');
                this.viewCertificateBtn = document.getElementById('viewCertificate');
                this.toggleSoundBtn = document.getElementById('toggleSound');
                this.testMicrophoneBtn = document.getElementById('testMicrophone');
                this.jumpToLetterBtn = document.getElementById('jumpToLetter');
                
                this.motivationModal = document.getElementById('motivationModal');
                this.gameModal = document.getElementById('gameModal');
                this.winModal = document.getElementById('winModal');
                this.certificateModal = document.getElementById('certificateModal');
                this.profileModal = document.getElementById('profileModal');
                this.instructionsModal = document.getElementById('instructionsModal');
                this.closeInstructionsModalBtn = document.getElementById('closeInstructionsModal');
                
                this.closeMotivationBtn = document.getElementById('closeMotivation');
                this.closeGameBtn = document.getElementById('closeGame');
                this.closeWinBtn = document.getElementById('closeWin');
                this.nextLetterBtn = document.getElementById('nextLetter');
                this.playGamesBtn = document.getElementById('playGames');
                this.motivationTitle = document.getElementById('motivationTitle');
                this.motivationSubtitle = document.getElementById('motivationSubtitle');
                this.motivationQuote = document.getElementById('motivationQuote');
                this.gamesGrid = document.getElementById('gamesGrid');
                
                this.gameCanvas = document.getElementById('gameCanvas');
                this.gameScoreEl = document.getElementById('gameScore');
                this.gameTimerEl = document.getElementById('gameTimer');
                this.gameTitle = document.getElementById('gameTitle');
                this.gameInstructions = document.getElementById('gameInstructions');
                this.touchControlsEl = document.getElementById('touchControls');
                this.gameControlsEl = document.getElementById('gameControls');
                this.restartGameBtn = document.getElementById('restartGame');
                this.pauseGameBtn = document.getElementById('pauseGame');
                this.backToSelectionBtn = document.getElementById('backToSelection');
                this.successCountEl = document.getElementById('successCount');
                this.difficultyLevelEl = document.getElementById('difficultyLevel');
                this.accuracyEl = document.getElementById('accuracy');
                this.gameStatsEl = document.getElementById('gameStats');
                
                this.winTitle = document.getElementById('winTitle');
                this.winSubtitle = document.getElementById('winSubtitle');
                this.winQuote = document.getElementById('winQuote');
                this.winAnimation = document.getElementById('winAnimation');
                this.finalScoreEl = document.getElementById('finalScore');
                this.finalTimeEl = document.getElementById('finalTime');
                this.finalAccuracyEl = document.getElementById('finalAccuracy');
                this.playAgainBtn = document.getElementById('playAgain');
                this.backToGamesBtn = document.getElementById('backToGames');
                this.winNextLetterBtn = document.getElementById('winNextLetterBtn');
                
                this.certificateName = document.getElementById('certificateName');
                this.certificateDate = document.getElementById('certificateDate');
                this.printCertificateBtn = document.getElementById('printCertificate');
                this.emailCertificateBtn = document.getElementById('emailCertificate');
                this.whatsappCertificateBtn = document.getElementById('whatsappCertificate');
                this.closeCertificateBtn = document.getElementById('closeCertificate');
                
                this.completionAnimation = document.getElementById('completionAnimation');
                this.scrollTopBtn = document.getElementById('scrollTop');
                this.micStatus = document.getElementById('micStatus');
                this.micStatusText = document.getElementById('micStatusText');
                this.letterJumpMenu = document.getElementById('letterJumpMenu');
                this.toast = document.getElementById('toast');
            }
            
            bindEvents() {
                // Global Touch Feedback for all buttons (Static & Dynamic)
                document.body.addEventListener('touchstart', (e) => {
                    const btn = e.target.closest('button');
                    if (btn && !btn.disabled) btn.classList.add('btn-touch-active');
                }, {passive: true});

                document.body.addEventListener('touchend', (e) => {
                    const btn = e.target.closest('button');
                    if (btn) btn.classList.remove('btn-touch-active');
                }, {passive: true});

                document.body.addEventListener('touchcancel', (e) => {
                    const btn = e.target.closest('button');
                    if (btn) btn.classList.remove('btn-touch-active');
                }, {passive: true});

                this.playLetterBtn.addEventListener('click', () => this.speakLetter());
                this.letterInfoBtn.addEventListener('click', () => this.showLetterInfo());
                this.resetLetterBtn.addEventListener('click', () => this.resetLetter());
                
                // Improved Previous Letter Button (Touch Support)
                const handlePrevLetter = (e) => {
                    if (e.cancelable) e.preventDefault();
                    this.previousLetter();
                };
                this.prevLetterBtn.addEventListener('click', handlePrevLetter);
                this.prevLetterBtn.addEventListener('touchstart', handlePrevLetter, { passive: false });
                
                // Robust Finish Letter Button Handler
                const handleFinishLetter = (e) => {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    this.finishLetter();
                };

                this.finishLetterBtn.addEventListener('click', handleFinishLetter);
                this.finishLetterBtn.addEventListener('touchstart', handleFinishLetter, { passive: false });
                this.finishLetterBtn.addEventListener('touchend', (e) => e.preventDefault(), { passive: false }); // Prevent ghost clicks
                
                this.themeToggle.addEventListener('click', () => this.toggleTheme());
                
                // Mobile Menu Events
                if (this.mobileMenuBtn) {
                    this.mobileMenuBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.userDropdown.classList.add('show');
                        const overlay = document.getElementById('menuOverlay');
                        if (overlay) overlay.classList.add('active');
                    });
                }

                if (this.closeMenuBtn) {
                    this.closeMenuBtn.addEventListener('click', () => {
                        this.userDropdown.classList.remove('show');
                        const overlay = document.getElementById('menuOverlay');
                        if (overlay) overlay.classList.remove('active');
                    });
                }

                // Close menu when clicking overlay
                const menuOverlay = document.getElementById('menuOverlay');
                if (menuOverlay) {
                    menuOverlay.addEventListener('click', () => {
                        this.userDropdown.classList.remove('show');
                        menuOverlay.classList.remove('active');
                    });
                }

                // Instructions Modal
                if (this.viewInstructionsBtn) {
                    this.viewInstructionsBtn.addEventListener('click', () => {
                        if (this.instructionsModal) this.instructionsModal.style.display = 'flex';
                        this.userDropdown.classList.remove('show');
                        if (menuOverlay) menuOverlay.classList.remove('active');
                    });
                }

                if (this.closeInstructionsModalBtn) {
                    this.closeInstructionsModalBtn.addEventListener('click', () => {
                        this.instructionsModal.style.display = 'none';
                    });
                }

                // User Menu Dropdown
                if (this.userMenuBtn) {
                    this.userMenuBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.userDropdown.classList.toggle('show');
                    });
                }

                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (this.userDropdown && this.userDropdown.classList.contains('show') && !this.userMenuBtn.contains(e.target)) {
                        this.userDropdown.classList.remove('show');
                    }
                });
                
                if (this.resetProgressBtn) {
                    this.resetProgressBtn.addEventListener('click', () => {
                        if (confirm('ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ™ŸÇÿØŸÖÿü ÿ≥Ÿäÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿ•ŸÜÿ¨ÿßÿ≤ÿßÿ™ŸÉ.')) {
                            localStorage.clear();
                            location.reload();
                        }
                        this.userDropdown.classList.remove('show');
                    });
                }
                
                if (this.viewAllLettersBtn) {
                    this.viewAllLettersBtn.addEventListener('click', () => {
                        document.getElementById('lettersNav').scrollIntoView({ behavior: 'smooth' });
                        this.userDropdown.classList.remove('show');
                    });
                }
                
                if (this.jumpToLetterBtn) {
                    this.jumpToLetterBtn.addEventListener('click', () => {
                        this.toggleLetterJumpMenu();
                        this.userDropdown.classList.remove('show');
                    });
                }
                
                if (this.viewCertificateBtn) {
                    this.viewCertificateBtn.addEventListener('click', () => {
                        if (this.completedLetters.length === LETTERS.length) {
                            this.showCertificate();
                        } else {
                            this.showToast('ŸÑŸÖ ÿ™ŸÉÿ™ŸÖŸÑ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ≠ÿ±ŸàŸÅ ÿ®ÿπÿØ!');
                        }
                        this.userDropdown.classList.remove('show');
                    });
                }
                
                if (this.toggleSoundBtn) {
                    this.toggleSoundBtn.addEventListener('click', () => {
                        this.soundEnabled = !this.soundEnabled;
                        this.soundManager.isSpeakingEnabled = this.soundEnabled;
                        localStorage.setItem('soundEnabled', this.soundEnabled);
                        this.toggleSoundBtn.innerHTML = this.soundEnabled ? 
                            '<i class="fas fa-volume-up"></i> ŸÉÿ™ŸÖ ÿßŸÑÿµŸàÿ™' : '<i class="fas fa-volume-mute"></i> ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿµŸàÿ™';
                        this.userDropdown.classList.remove('show');
                    });
                }
                
                if (this.testMicrophoneBtn) {
                    this.testMicrophoneBtn.addEventListener('click', () => {
                        this.testMicrophone();
                        this.userDropdown.classList.remove('show');
                    });
                }
                
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('#letterJumpMenu') && !e.target.closest('#jumpToLetter')) {
                        if (this.letterJumpMenu) this.letterJumpMenu.classList.remove('show');
                    }
                });
                
                // Profile Events
                this.studentProfileBtn.addEventListener('click', () => {
                    this.openProfileModal();
                });

                document.getElementById('closeProfileModal').addEventListener('click', () => {
                    this.profileModal.style.display = 'none';
                });

                document.getElementById('profileForm').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.saveProfile();
                });

                document.getElementById('googleLoginBtn').addEventListener('click', () => {
                    // Simulation of Google Login
                    const email = prompt("ÿ£ÿØÿÆŸÑ ÿ®ÿ±ŸäÿØŸÉ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä (Google):", "student@gmail.com");
                    if (email) {
                        this.studentEmail = email;
                        this.studentName = email.split('@')[0]; // Use part of email as name initially
                        localStorage.setItem('studentEmail', this.studentEmail);
                        localStorage.setItem('studentName', this.studentName);
                        this.refreshUserIdentifier();
                        this.updateProfileDisplay();
                        this.profileModal.style.display = 'none';
                        this.showToast("ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ÿ®ŸÜÿ¨ÿßÿ≠! Ÿäÿ±ÿ¨Ÿâ ÿ•ŸÉŸÖÿßŸÑ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ÿßŸÑÿ¥ÿÆÿµŸäÿ©.", 3000, 'success');
                        this.openProfileModal(); // Re-open to fill other details
                    }
                });

                this.closeMotivationBtn.addEventListener('click', () => this.motivationModal.style.display = 'none');
                
                // Improved Close Game Button (Returns to Selection)
                const handleCloseGame = (e) => {
                    if (e.cancelable) e.preventDefault();
                    this.backToGames();
                };
                this.closeGameBtn.addEventListener('click', handleCloseGame);
                this.closeGameBtn.addEventListener('touchstart', handleCloseGame, { passive: false });

                this.closeWinBtn.addEventListener('click', () => this.winModal.style.display = 'none');
                
                // Improved Next Letter Button
                const handleNextLetter = (e) => {
                    // Prevent default only if it's a touch event to avoid double firing, 
                    // but ensure the logic runs.
                    if (e.type === 'touchstart') {
                        e.preventDefault(); // Prevent mouse emulation
                        this.nextLetter();
                    } else {
                        this.nextLetter();
                    }
                };
                // Remove old listeners first to be safe (though not strictly necessary if replacing)
                this.nextLetterBtn.removeEventListener('click', handleNextLetter);
                this.nextLetterBtn.removeEventListener('touchstart', handleNextLetter);
                
                this.nextLetterBtn.addEventListener('click', handleNextLetter);
                this.nextLetterBtn.addEventListener('touchstart', handleNextLetter, { passive: false });

                this.playGamesBtn.addEventListener('click', () => this.showGames());
                this.closeCertificateBtn.addEventListener('click', () => this.certificateModal.style.display = 'none');
                this.printCertificateBtn.addEventListener('click', () => this.printCertificate());
                this.emailCertificateBtn.addEventListener('click', () => this.sendCertificateEmail());
                this.whatsappCertificateBtn.addEventListener('click', () => this.sendCertificateWhatsApp());
                
                // Improved Game Control Buttons (Touch Support)
                const handleRestart = (e) => { 
                    if (e.type === 'touchstart') e.preventDefault();
                    this.restartGame(); 
                };
                const handlePause = (e) => { 
                    if (e.type === 'touchstart') e.preventDefault();
                    this.togglePause(); 
                };
                const handleBackToGames = (e) => { 
                    if (e.type === 'touchstart') e.preventDefault();
                    this.backToGames(); 
                };

                this.restartGameBtn.addEventListener('click', handleRestart);
                this.restartGameBtn.addEventListener('touchstart', handleRestart, { passive: false });
                
                this.pauseGameBtn.addEventListener('click', handlePause);
                this.pauseGameBtn.addEventListener('touchstart', handlePause, { passive: false });
                
                this.backToSelectionBtn.addEventListener('click', handleBackToGames);
                this.backToSelectionBtn.addEventListener('touchstart', handleBackToGames, { passive: false });
                
                this.playAgainBtn.addEventListener('click', () => this.playAgain());
                
                this.backToGamesBtn.addEventListener('click', handleBackToGames);
                this.backToGamesBtn.addEventListener('touchstart', handleBackToGames, { passive: false });
                
                this.winNextLetterBtn.addEventListener('click', () => {
                    this.winModal.style.display = 'none';
                    this.nextLetter();
                });
                this.winNextLetterBtn.addEventListener('touchstart', (e) => {
                    if (e.cancelable) e.preventDefault();
                    this.winModal.style.display = 'none';
                    this.nextLetter();
                }, { passive: false });
                
                // ŸÖÿπÿßŸÑÿ¨ ÿ∞ŸÉŸä ŸÑŸÑŸÖÿ≥ ŸäŸÖŸäÿ≤ ÿ®ŸäŸÜ ÿßŸÑÿ™ŸÖÿ±Ÿäÿ± ŸàÿßŸÑŸÜŸÇÿ±
                let touchStartY = 0;
                let touchStartX = 0;
                let touchStartTime = 0;
                let isTouchScrolling = false;

                this.gamesGrid.addEventListener('touchstart', (e) => {
                    const gameCard = e.target.closest('.game-card');
                    if (gameCard && !gameCard.classList.contains('locked')) {
                        const touch = e.touches[0];
                        touchStartY = touch.clientY;
                        touchStartX = touch.clientX;
                        touchStartTime = Date.now();
                        isTouchScrolling = false;
                    }
                }, { passive: true });

                this.gamesGrid.addEventListener('touchmove', (e) => {
                    const gameCard = e.target.closest('.game-card');
                    if (gameCard && !gameCard.classList.contains('locked')) {
                        const touch = e.touches[0];
                        const deltaY = Math.abs(touch.clientY - touchStartY);
                        const deltaX = Math.abs(touch.clientX - touchStartX);
                        
                        // ÿ•ÿ∞ÿß ÿ™ÿ≠ÿ±ŸÉ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ£ŸÉÿ´ÿ± ŸÖŸÜ 10 ÿ®ŸÉÿ≥ŸÑÿå ŸÅŸáŸà ŸäŸÖÿ±ÿ± ŸàŸÑŸäÿ≥ ŸäŸÜŸÇÿ±
                        if (deltaY > 10 || deltaX > 10) {
                            isTouchScrolling = true;
                        }
                    }
                }, { passive: true });

                this.gamesGrid.addEventListener('touchend', (e) => {
                    const gameCard = e.target.closest('.game-card');
                    if (gameCard && !gameCard.classList.contains('locked')) {
                        const touch = e.changedTouches[0];
                        const deltaY = Math.abs(touch.clientY - touchStartY);
                        const deltaX = Math.abs(touch.clientX - touchStartX);
                        const deltaTime = Date.now() - touchStartTime;
                        
                        // ŸÅÿ™ÿ≠ ÿßŸÑŸÑÿπÿ®ÿ© ŸÅŸÇÿ∑ ÿ•ÿ∞ÿß:
                        // 1. ÿßŸÑÿ≠ÿ±ŸÉÿ© ÿ£ŸÇŸÑ ŸÖŸÜ 10 ÿ®ŸÉÿ≥ŸÑ (ŸÑŸäÿ≥ ÿ™ŸÖÿ±Ÿäÿ±)
                        // 2. ÿßŸÑŸàŸÇÿ™ ÿ£ŸÇŸÑ ŸÖŸÜ 300ms (ŸÜŸÇÿ±ÿ© ÿ≥ÿ±Ÿäÿπÿ©)
                        // 3. ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÉÿ™ÿ¥ÿßŸÅ ÿ™ŸÖÿ±Ÿäÿ± ÿ£ÿ´ŸÜÿßÿ° ÿßŸÑÿ≠ÿ±ŸÉÿ©
                        if (!isTouchScrolling && deltaY < 10 && deltaX < 10 && deltaTime < 300) {
                            e.preventDefault();
                            const gameType = gameCard.dataset.game;
                            this.startGame(gameType);
                        }
                    }
                }, { passive: false });
                
                // ŸÖÿπÿßŸÑÿ¨ ÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿä ŸÑŸÑŸÅÿ£ÿ±ÿ© ÿπŸÑŸâ ÿßŸÑŸÉŸÖÿ®ŸäŸàÿ™ÿ±
                this.gamesGrid.addEventListener('click', (e) => {
                    // ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ŸÜŸá ŸÑŸäÿ≥ ÿ¨Ÿáÿßÿ≤ ŸÑŸÖÿ≥
                    if (e.pointerType === 'mouse' || !('ontouchstart' in window)) {
                        const gameCard = e.target.closest('.game-card');
                        if (gameCard && !gameCard.classList.contains('locked')) {
                            const gameType = gameCard.dataset.game;
                            this.startGame(gameType);
                        }
                    }
                });
                
                // ŸÖÿπÿßŸÑÿ¨ ÿ£ÿ≤ÿ±ÿßÿ± ÿßŸÑÿ™ŸÖÿ±Ÿäÿ± ŸÑŸÑÿ£ŸÑÿπÿßÿ®
                const scrollUpBtn = document.getElementById('scrollUpBtn');
                const scrollDownBtn = document.getElementById('scrollDownBtn');
                
                if (scrollUpBtn) {
                    scrollUpBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.gamesGrid.scrollBy({ top: -150, behavior: 'smooth' });
                    });
                    scrollUpBtn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.gamesGrid.scrollBy({ top: -150, behavior: 'smooth' });
                    }, { passive: false });
                }
                
                if (scrollDownBtn) {
                    scrollDownBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.gamesGrid.scrollBy({ top: 150, behavior: 'smooth' });
                    });
                    scrollDownBtn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.gamesGrid.scrollBy({ top: 150, behavior: 'smooth' });
                    }, { passive: false });
                }
                
                this.quizNextBtn.addEventListener('click', () => this.nextQuizQuestion());
                
                window.addEventListener('click', (e) => {
                    if (e.target === this.motivationModal) {
                        this.motivationModal.style.display = 'none';
                    }
                    if (e.target === this.gameModal) {
                        this.closeGame();
                    }
                    if (e.target === this.winModal) {
                        this.winModal.style.display = 'none';
                    }
                    if (e.target === this.certificateModal) {
                        this.certificateModal.style.display = 'none';
                    }
                });
                
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.closeGame();
                    }
                });
            }
            
            setupTheme() {
                if (this.isNightMode) {
                    document.body.classList.add('night-mode');
                    this.themeToggle.innerHTML = '<i class="fas fa-sun"></i><span>ÿßŸÑŸàÿ∂ÿπ ÿßŸÑŸÜŸáÿßÿ±Ÿä</span>';
                } else {
                    document.body.classList.remove('night-mode');
                    this.themeToggle.innerHTML = '<i class="fas fa-moon"></i><span>ÿßŸÑŸàÿ∂ÿπ ÿßŸÑŸÑŸäŸÑŸä</span>';
                }
            }
            
            toggleTheme() {
                this.isNightMode = !this.isNightMode;
                localStorage.setItem('nightMode', this.isNightMode);
                this.setupTheme();
            }

            openProfileModal() {
                document.getElementById('profileName').value = this.studentName;
                document.getElementById('profileSchool').value = this.studentSchool;
                document.getElementById('profilePhone').value = this.studentPhone;
                document.getElementById('profileParentPhone').value = this.parentPhone;
                this.profileModal.style.display = 'flex';
            }

            saveProfile() {
                this.studentName = document.getElementById('profileName').value;
                this.studentSchool = document.getElementById('profileSchool').value;
                this.studentPhone = document.getElementById('profilePhone').value;
                this.parentPhone = document.getElementById('profileParentPhone').value;

                localStorage.setItem('studentName', this.studentName);
                localStorage.setItem('studentSchool', this.studentSchool);
                localStorage.setItem('studentPhone', this.studentPhone);
                localStorage.setItem('parentPhone', this.parentPhone);

                this.refreshUserIdentifier();
                this.updateProfileDisplay();
                this.profileModal.style.display = 'none';
                this.showToast("ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ®ŸÜÿ¨ÿßÿ≠!", 3000, 'success');
            }

            updateProfileDisplay() {
                this.studentNameDisplay.textContent = this.studentName || 'ÿ≤ÿßÿ¶ÿ±';
                this.certificateName.textContent = this.studentName || 'ÿßŸÑÿ∑ÿßŸÑÿ® ÿßŸÑŸÖÿ™ŸÖŸäÿ≤';
            }
            
            setupSpeechRecognition() {
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    this.speechRecognition = new SpeechRecognition();
                    this.speechRecognition.continuous = false;
                    this.speechRecognition.interimResults = false;
                    this.speechRecognition.lang = 'en-GB'; // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ© ÿßŸÑÿ®ÿ±Ÿäÿ∑ÿßŸÜŸäÿ© ŸÑŸÑÿ™ÿπÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑÿµŸàÿ™
                    this.speechRecognition.maxAlternatives = 20; // ÿ≤ŸäÿßÿØÿ© ÿßŸÑÿ®ÿØÿßÿ¶ŸÑ ŸÑÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿØŸÇÿ© ÿ®ÿ¥ŸÉŸÑ ÿ£ŸÉÿ®ÿ±
                    
                    this.speechRecognition.onstart = () => {
                        this.isListening = true;
                        this.showMicStatus('üé§ ÿ¨ÿßÿ±Ÿä ÿßŸÑÿßÿ≥ÿ™ŸÖÿßÿπ...', false);
                    };
                    
                    this.speechRecognition.onresult = (event) => {
                        const transcript = event.results[0][0].transcript.trim().toLowerCase();
                        this.showMicStatus('‚úÖ ÿ™ŸÖ ÿßŸÑÿßÿ≥ÿ™ŸÖÿßÿπ ÿ®ŸÜÿ¨ÿßÿ≠!', false);
                        setTimeout(() => this.hideMicStatus(), 2000);
                        return transcript;
                    };
                    
                    this.speechRecognition.onerror = (event) => {
                        this.isListening = false;
                        let errorMessage = 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ÿπÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑÿµŸàÿ™';
                        
                        switch(event.error) {
                            case 'not-allowed':
                            case 'permission-denied':
                                errorMessage = 'ŸÑŸÖ Ÿäÿ™ŸÖ ŸÖŸÜÿ≠ ÿßŸÑÿ•ÿ∞ŸÜ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÖŸäŸÉÿ±ŸàŸÅŸàŸÜ';
                                this.micPermissionGranted = false;
                                break;
                            case 'no-speech':
                                errorMessage = 'ŸÑŸÖ Ÿäÿ™ŸÖ ÿ≥ŸÖÿßÿπ ÿßŸÑÿµŸàÿ™ÿå ÿ≠ÿßŸàŸÑ ÿßŸÑÿ™ÿ≠ÿØÿ´ ÿ®ÿµŸàÿ™ ÿ£ÿπŸÑŸâ üîä';
                                break;
                            case 'audio-capture':
                                errorMessage = 'ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖŸäŸÉÿ±ŸàŸÅŸàŸÜ ŸÖÿ™ÿßÿ≠';
                                break;
                            case 'network':
                                errorMessage = 'ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ¥ÿ®ŸÉÿ©';
                                break;
                        }
                        
                        this.showMicStatus(`‚ùå ${errorMessage}`, true);
                    };
                    
                    this.speechRecognition.onend = () => {
                        this.isListening = false;
                    };
                } else {
                    this.showMicStatus('‚ö†Ô∏è ÿßŸÑŸÖÿ™ÿµŸÅÿ≠ ŸÑÿß ŸäÿØÿπŸÖ ÿßŸÑÿ™ÿπÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑÿµŸàÿ™', true);
                }
            }
            
            setupAudioVisualizer() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 256;
                } catch (error) {
                    console.log('Audio context not supported:', error);
                }
            }
            
            async checkMicrophonePermission() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    this.micPermissionGranted = true;
                    stream.getTracks().forEach(track => track.stop());
                    this.showMicStatus('‚úÖ ÿßŸÑŸÖÿßŸäŸÉÿ±ŸàŸÅŸàŸÜ ÿ¨ÿßŸáÿ≤ ŸÑŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ', false);
                    setTimeout(() => this.hideMicStatus(), 3000);
                } catch (error) {
                    this.micPermissionGranted = false;
                    this.showMicStatus('‚ùå Ÿäÿ±ÿ¨Ÿâ ŸÖŸÜÿ≠ ÿ•ÿ∞ŸÜ ÿßŸÑŸÖÿßŸäŸÉÿ±ŸàŸÅŸàŸÜ', true);
                }
            }
            
            showMicStatus(message, isError = false) {
                this.micStatusText.textContent = message;
                this.micStatus.className = 'mic-status' + (isError ? ' error' : '');
                this.micStatus.classList.add('show');
            }
            
            hideMicStatus() {
                this.micStatus.classList.remove('show');
            }
            
            async testMicrophone() {
                if (!this.micPermissionGranted) {
                    if (!await this.requestMicrophonePermission()) {
                        return;
                    }
                }
                
                try {
                    this.audioStream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });
                    
                    this.showMicStatus('üé§ ÿ¨ÿßÿ±Ÿä ÿßÿÆÿ™ÿ®ÿßÿ± ÿßŸÑŸÖÿßŸäŸÉÿ±ŸàŸÅŸàŸÜ...', false);
                    
                    if (this.audioContext) {
                        const source = this.audioContext.createMediaStreamSource(this.audioStream);
                        source.connect(this.analyser);
                        
                        const bufferLength = this.analyser.frequencyBinCount;
                        const dataArray = new Uint8Array(bufferLength);
                        
                        const checkAudio = () => {
                            this.analyser.getByteFrequencyData(dataArray);
                            const average = dataArray.reduce((a, b) => a + b) / bufferLength;
                            
                            if (average > 10) {
                                this.showMicStatus('‚úÖ ÿßŸÑŸÖÿßŸäŸÉÿ±ŸàŸÅŸàŸÜ ŸäÿπŸÖŸÑ ÿ®ÿ¥ŸÉŸÑ ŸÖŸÖÿ™ÿßÿ≤!', false);
                                setTimeout(() => {
                                    this.stopMicrophoneTest();
                                    this.showMicStatus('üé§ ÿ¨ÿßŸáÿ≤ ŸÑŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ', false);
                                    setTimeout(() => this.hideMicStatus(), 2000);
                                }, 1000);
                            } else {
                                setTimeout(checkAudio, 100);
                            }
                        };
                        
                        setTimeout(() => {
                            this.showMicStatus('üé§ ÿ™ÿ≠ÿØÿ´ ÿßŸÑÿ¢ŸÜ...', false);
                            checkAudio();
                        }, 500);
                        
                        setTimeout(() => {
                            if (this.isListening) {
                                this.showMicStatus('‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÉÿ™ÿ¥ÿßŸÅ ÿµŸàÿ™', true);
                                this.stopMicrophoneTest();
                            }
                        }, 5000);
                    }
                    
                } catch (error) {
                    this.showMicStatus('‚ùå ŸÅÿ¥ŸÑ ŸÅŸä ÿßŸÑŸàÿµŸàŸÑ ÿ•ŸÑŸâ ÿßŸÑŸÖÿßŸäŸÉÿ±ŸàŸÅŸàŸÜ', true);
                }
            }
            
            stopMicrophoneTest() {
                if (this.audioStream) {
                    this.audioStream.getTracks().forEach(track => track.stop());
                    this.audioStream = null;
                }
            }
            
            async requestMicrophonePermission() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    this.micPermissionGranted = true;
                    stream.getTracks().forEach(track => track.stop());
                    this.showMicStatus('‚úÖ ÿ™ŸÖ ŸÖŸÜÿ≠ ÿ•ÿ∞ŸÜ ÿßŸÑŸÖÿßŸäŸÉÿ±ŸàŸÅŸàŸÜ', false);
                    setTimeout(() => this.hideMicStatus(), 3000);
                    return true;
                } catch (error) {
                    this.showMicStatus('‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ŸÖŸÜÿ≠ ÿ•ÿ∞ŸÜ ÿßŸÑŸÖÿßŸäŸÉÿ±ŸàŸÅŸàŸÜ', true);
                    return false;
                }
            }
            
            setupTouchControls() {
                const controlButtons = this.touchControlsEl.querySelectorAll('.control-btn');
                
                controlButtons.forEach(btn => {
                    const action = btn.dataset.action;
                    
                    const activate = (e) => {
                        if (e.cancelable) e.preventDefault();
                        this.touchControls[action] = true;
                        btn.classList.add('btn-touch-active');
                        // Add a small vibration if supported
                        if (navigator.vibrate) navigator.vibrate(10);
                        this.soundManager.playSound('click');
                    };

                    const deactivate = (e) => {
                        if (e.cancelable) e.preventDefault();
                        this.touchControls[action] = false;
                        btn.classList.remove('btn-touch-active');
                    };
                    
                    btn.addEventListener('touchstart', activate, { passive: false });
                    btn.addEventListener('touchend', deactivate, { passive: false });
                    btn.addEventListener('touchcancel', deactivate, { passive: false });
                    
                    btn.addEventListener('mousedown', activate);
                    btn.addEventListener('mouseup', deactivate);
                    btn.addEventListener('mouseleave', deactivate);
                });
                
                // Check for touch support but allow fallback
                if (!('ontouchstart' in window || navigator.maxTouchPoints > 0)) {
                    // Optional: Hide on non-touch devices if desired, but keeping for hybrid
                    // this.touchControlsEl.style.display = 'none';
                }
            }
            
            setupLetterJumpMenu() {
                this.letterJumpMenu.innerHTML = '';
                
                LETTERS.forEach((letter, index) => {
                    const item = document.createElement('div');
                    item.className = 'letter-jump-item';
                    item.textContent = `${letter} - ÿßŸÑÿ≠ÿ±ŸÅ ${index + 1}`;
                    item.dataset.index = index;
                    
                    item.addEventListener('click', () => {
                        this.goToLetter(letter);
                        if (this.isLetterUnlocked(letter)) {
                            this.letterJumpMenu.classList.remove('show');
                        }
                    });
                    
                    this.letterJumpMenu.appendChild(item);
                });
            }
            
            toggleLetterJumpMenu() {
                this.letterJumpMenu.classList.toggle('show');
            }
            
            checkPreviousLetter(letter) {
                const currentIndex = LETTERS.indexOf(letter);
                if (currentIndex === 0) return true; // ÿßŸÑÿ≠ÿ±ŸÅ A ÿØÿßÿ¶ŸÖÿßŸã ŸÖÿ™ÿßÿ≠
                const prevLetter = LETTERS[currentIndex - 1];
                return this.isLetterCompleted(prevLetter);
            }

            checkLetterCompleted(letter) {
                return this.isLetterCompleted(letter);
            }

            unlockNextLetter(letter) {
                const currentIndex = LETTERS.indexOf(letter);
                const nextIndex = currentIndex + 1;
                
                if (nextIndex < LETTERS.length) {
                    // ŸÅÿ™ÿ≠ ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿ™ÿßŸÑŸä ŸÅŸÇÿ∑
                    const nextLetter = LETTERS[nextIndex];
                    const entry = this.ensureLetterRecord(nextLetter);

                    if (!entry.unlocked) {
                        entry.unlocked = true;
                        this.commitProgressUpdate();
                        this.renderLettersNav(); // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸàÿßÿ¨Ÿáÿ©
                        this.setupLetterJumpMenu();
                        this.showToast(`üéâ ÿ±ÿßÿ¶ÿπ! ÿ™ŸÖ ŸÅÿ™ÿ≠ ÿßŸÑÿ≠ÿ±ŸÅ ${nextLetter}`, 3000, 'success');

                        // ÿßŸÑÿßŸÜÿ™ŸÇÿßŸÑ ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã ŸÑŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿ™ÿßŸÑŸä
                        setTimeout(() => {
                            this.loadLetter(nextIndex);
                        }, 1500);
                    }
                } else {
                    // All letters completed - show final certificate!
                    this.showToast("üéâ ŸÖÿ®ÿ±ŸàŸÉ! ŸÑŸÇÿØ ÿ£ŸÜŸáŸäÿ™ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ≠ÿ±ŸàŸÅ! ÿ≥ÿ™ÿ≠ÿµŸÑ ÿπŸÑŸâ ÿ¥ŸáÿßÿØÿ© ÿßŸÑÿ•ÿ™ŸÇÿßŸÜ!", 5000, 'success');
                    setTimeout(() => {
                        this.showCertificate();
                    }, 2000);
                }
            }

            goToLetter(letter) {
                const index = LETTERS.indexOf(letter);
                if (index === -1) return;
                
                // ÿßŸÑÿ≥ŸÖÿßÿ≠ ÿ®ÿßŸÑŸàÿµŸàŸÑ ŸÑŸÑÿ≠ÿ±ŸÅ A ÿØÿßÿ¶ŸÖÿßŸã
                if (index === 0) {
                    this.loadLetter(index);
                    return;
                }

                // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑÿ≠ÿ±ŸÅ ŸÖŸÅÿ™Ÿàÿ≠ÿßŸã ÿ®ÿßŸÑŸÅÿπŸÑÿå ÿßÿ≥ŸÖÿ≠ ÿ®ÿßŸÑÿØÿÆŸàŸÑ ŸÖÿ®ÿßÿ¥ÿ±ÿ©
                if (this.isLetterUnlocked(letter)) {
                    this.loadLetter(index);
                    return;
                }
                
                // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿ≥ÿßÿ®ŸÇ ŸÖŸÉÿ™ŸÖŸÑ
                const prevLetter = LETTERS[index - 1];
                if (!this.isLetterCompleted(prevLetter)) {
                    this.showToast('ÿπÿ∞ÿ±Ÿãÿßÿå Ÿáÿ∞ÿß ÿßŸÑÿ≠ÿ±ŸÅ ŸÖÿ∫ŸÑŸÇ. Ÿäÿ¨ÿ® ÿ•ŸÜŸáÿßÿ° ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿ≥ÿßÿ®ŸÇ ÿ£ŸàŸÑŸãÿß.');
                    this.soundManager?.playSound('error');
                    return;
                }
                
                // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿ≥ÿßÿ®ŸÇ ŸÖŸÉÿ™ŸÖŸÑÿßŸãÿå ŸÅÿ™ÿ≠ ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿ≠ÿßŸÑŸä
                this.unlockLetter(letter);
                this.renderLettersNav();
                this.setupLetterJumpMenu();
                
                this.loadLetter(index);
            }

            renderLettersNav() {
                this.lettersNav.innerHTML = '';
                
                LETTERS.forEach((letter, index) => {
                    const tab = document.createElement('div');
                    tab.className = 'letter-tab';
                    tab.textContent = letter;
                    tab.dataset.index = index;
                    
                    if (index === this.currentLetterIndex) {
                        tab.classList.add('active');
                    }
                    
                    if (this.isLetterCompleted(letter)) {
                        tab.classList.add('completed');
                    }
                    
                    if (!this.isLetterUnlocked(letter)) {
                        tab.classList.add('locked');
                    }
                    
                    tab.addEventListener('click', () => {
                        this.goToLetter(letter);
                    });
                    
                    this.lettersNav.appendChild(tab);
                });

                if (this.completedLetters.length === LETTERS.length) {
                    const certTab = document.createElement('div');
                    certTab.className = 'letter-tab certificate-tab';
                    certTab.innerHTML = 'üéì';
                    certTab.title = 'ÿßŸÑÿ¥ŸáÿßÿØÿ© / Certificate';
                    certTab.style.backgroundColor = 'gold';
                    certTab.style.borderColor = '#b8860b';
                    certTab.style.cursor = 'pointer';
                    certTab.style.fontSize = '1.2rem';
                    
                    certTab.addEventListener('click', () => {
                        this.showCertificate();
                    });
                    
                    this.lettersNav.appendChild(certTab);
                }
            }
            
            loadLetter(index) {
                try {
                    const letter = LETTERS[index];
                    if (!letter) {
                        console.error('Invalid letter index:', index);
                        return;
                    }

                    if (index !== 0 && !this.isLetterUnlocked(letter)) {
                        this.showToast('ÿπÿ∞ÿ±Ÿãÿßÿå Ÿáÿ∞ÿß ÿßŸÑÿ≠ÿ±ŸÅ ŸÖÿ∫ŸÑŸÇ. Ÿäÿ¨ÿ® ÿ•ŸÜŸáÿßÿ° ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿ≥ÿßÿ®ŸÇ ÿ£ŸàŸÑŸãÿß.', 3000);
                        this.soundManager.playSound('error');
                        return;
                    }

                    this.currentLetterIndex = index;
                    this.progress.currentLetter = letter;
                    
                    // Critical: Ensure record is robust
                    const letterProgress = this.ensureLetterRecord(letter);
                    if (!letterProgress) throw new Error('Failed to ensure letter record');

                    const staticLetterData = LETTER_DATA[letter];

                    if (!staticLetterData || !staticLetterData.words) {
                        console.error(`No static data or words found for letter: ${letter}`);
                        this.showToast('ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ŸÑŸáÿ∞ÿß ÿßŸÑÿ≠ÿ±ŸÅ', 3000, 'error');
                        return;
                    }

                    // Safe usage of properties with fallbacks
                    this.quizScore = (letterProgress.exercises && letterProgress.exercises.quiz && letterProgress.exercises.quiz.score) || 0;
                    this.quizCompletedFlag = (letterProgress.exercises && letterProgress.exercises.quiz && letterProgress.exercises.quiz.completed) || false;
                    
                    const answers = (letterProgress.exercises && letterProgress.exercises.quiz && letterProgress.exercises.quiz.answers) || {};
                    const answeredCount = Object.keys(answers).length;
                    
                    // Safe quiz length check
                    const quizLength = (staticLetterData.quiz && Array.isArray(staticLetterData.quiz)) ? staticLetterData.quiz.length : 0;
                    this.currentQuizIndex = this.quizCompletedFlag ? quizLength : answeredCount;
                    
                    // Render Steps with individual error handling ensures one failure doesn't break the whole page
                    try { this.updateUIForLetter(letter, staticLetterData.words); } catch(e) { console.error('Error updating UI', e); }
                    try { this.renderWritingBoxes(letter); } catch(e) { console.error('Error rendering writing', e); }
                    try { this.renderWordWriting(letter, staticLetterData.words); } catch(e) { console.error('Error rendering words', e); }
                    try { this.renderQuiz(staticLetterData.quiz); } catch(e) { console.error('Error rendering quiz', e); }
                    
                    try { this.updateAndCommitScores(); } catch(e) { console.error('Error updating scores', e); }
                    try { this.updateProgress(); } catch(e) { console.error('Error updating progress', e); }
                    try { this.renderLettersNav(); } catch(e) { console.error('Error rendering letters nav', e); }
                    try { this.renderAchievements(); } catch(e) { console.error('Error rendering achievements', e); }
                } catch (error) {
                    console.error("Error loading letter:", error);
                    // Show more specific error to user if possible, otherwise generic
                    const msg = error.message || "Unknown error";
                    // Suppress "Cannot set properties of null" error toast as per user request
                    if (msg && (msg.includes("Cannot set properties of null") || msg.includes("setting 'textContent'") || msg.includes("null"))) {
                        // Fallback logging only
                        console.warn("Suppressed persistent UI error:", msg);
                    } else {
                        this.showToast(`ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ≠ÿ±ŸÅ: ${msg}`, 5000, 'error');
                    }
                }
            }

            updateUIForLetter(letter, words) {
                if (this.currentLetterEl) this.currentLetterEl.textContent = letter;
                if (this.letterUpperEl) this.letterUpperEl.textContent = letter.toUpperCase();
                if (this.letterLowerEl) this.letterLowerEl.textContent = letter.toLowerCase();
                if (this.letterForWordsEl) this.letterForWordsEl.textContent = letter;
                
                // ÿ•ÿ∂ÿßŸÅÿ© ÿ≤ÿ± ÿ™ÿ≠ŸÖŸäŸÑ Ÿàÿ±ŸÇÿ© ÿßŸÑÿπŸÖŸÑ
                if (this.currentLetterEl && this.currentLetterEl.parentElement) {
                    const headerContainer = this.currentLetterEl.parentElement;
                    let downloadBtn = headerContainer.querySelector('.download-worksheet-btn');
                    
                    if (!downloadBtn) {
                        downloadBtn = document.createElement('button');
                        downloadBtn.className = 'download-worksheet-btn';
                        downloadBtn.innerHTML = '<i class="fas fa-file-pdf"></i> Ÿàÿ±ŸÇÿ© ÿπŸÖŸÑ';
                        downloadBtn.style.cssText = `
                            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
                            color: white;
                            border: none;
                            padding: 8px 15px;
                            border-radius: 20px;
                            font-size: 14px;
                            cursor: pointer;
                            margin-right: 15px;
                            display: inline-flex;
                            align-items: center;
                            gap: 8px;
                            box-shadow: 0 4px 6px rgba(239, 68, 68, 0.2);
                            transition: transform 0.2s;
                        `;
                        downloadBtn.onmouseover = () => downloadBtn.style.transform = 'scale(1.05)';
                        downloadBtn.onmouseout = () => downloadBtn.style.transform = 'scale(1)';
                        
                        // ÿ•ÿØÿ±ÿßÿ¨ ÿßŸÑÿ≤ÿ± ÿ®ÿ¨ÿßŸÜÿ® ÿßŸÑÿπŸÜŸàÿßŸÜ
                        this.currentLetterEl.parentElement.appendChild(downloadBtn);
                    }
                    
                    // ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿØÿ´ ÿßŸÑŸÜŸÇÿ± ŸÑŸÑÿ≤ÿ±
                    downloadBtn.onclick = () => this.generateWorksheet(letter);
                }

                this.renderWordsGrid(words);
            }

            generateWorksheet(letter) {
                const letterData = LETTER_DATA[letter];
                if (!letterData) return;

                this.showToast('ÿ¨ÿßÿ±Ÿä ÿ•ÿπÿØÿßÿØ Ÿàÿ±ŸÇÿ© ÿßŸÑÿπŸÖŸÑ... üìÑ', 2000);

                // ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿßŸàŸäÿ© Ÿàÿ±ŸÇÿ© ÿßŸÑÿπŸÖŸÑ - ŸÜÿ¨ÿπŸÑŸáÿß ÿ∏ÿßŸáÿ±ÿ© (Overlay) ŸÑÿ∂ŸÖÿßŸÜ ÿßŸÑÿ™ŸÇÿßÿ∑Ÿáÿß
                const worksheetContainer = document.createElement('div');
                worksheetContainer.className = 'worksheet-overlay';
                
                worksheetContainer.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    z-index: 99999;
                    background: rgba(0,0,0,0.8);
                    overflow-y: auto;
                    padding: 20px;
                    box-sizing: border-box;
                    display: flex;
                    justify-content: center;
                    align-items: flex-start;
                `;

                const wordsList = letterData.words;
                
                // ÿØÿßŸÑÿ© ŸÖÿ≥ÿßÿπÿØÿ© ŸÑÿ•ŸÜÿ¥ÿßÿ° ÿÆÿ∑Ÿàÿ∑ ÿßŸÑÿ™ÿ™ÿ®ÿπ
                const createTracingLine = (text, count) => {
                    return Array(count).fill(text).join('     ');
                };

                // ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑŸÅÿπŸÑŸä ŸÑŸÑŸàÿ±ŸÇÿ© (A4) - ÿ™ÿµŸÖŸäŸÖ ÿßÿ≠ÿ™ÿ±ÿßŸÅŸä ŸàŸÖÿ∂ÿ∫Ÿàÿ∑
                const content = document.createElement('div');
                content.id = 'pdf-content';
                content.style.cssText = `
                    width: 210mm;
                    min-height: 297mm;
                    padding: 10mm;
                    background: white;
                    box-shadow: 0 0 20px rgba(0,0,0,0.5);
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                    direction: ltr;
                    color: black;
                    position: relative;
                    margin-bottom: 50px;
                `;

                content.innerHTML = `
                    <div style="border: 2px solid #4361ee; border-radius: 15px; height: 100%; padding: 15px; box-sizing: border-box; position: relative; overflow: hidden;">
                        
                        <!-- Decorative Corner -->
                        <div style="position: absolute; top: -20px; right: -20px; width: 80px; height: 80px; background: #4361ee; transform: rotate(45deg); z-index: 0;"></div>

                        <!-- Header -->
                        <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 2px dashed #cbd5e1; padding-bottom: 10px; margin-bottom: 15px; position: relative; z-index: 1;">
                            <div style="display: flex; align-items: center; gap: 15px;">
                                <div style="width: 50px; height: 50px; background: #4361ee; color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24pt; font-weight: bold;">${letter}</div>
                                <div>
                                    <h1 style="margin: 0; color: #1e293b; font-size: 20pt; font-weight: 800;">Phonics Worksheet</h1>
                                    <p style="margin: 0; color: #64748b; font-size: 10pt;">Learn the letter ${letter}</p>
                                </div>
                            </div>
                            <div style="text-align: right; font-size: 10pt; color: #334155;">
                                <div style="margin-bottom: 5px; background: #f1f5f9; padding: 5px 10px; border-radius: 5px; width: 180px; display: flex; justify-content: space-between;">
                                    <span>Name:</span>
                                    <span style="border-bottom: 1px solid #94a3b8; width: 100px;"></span>
                                </div>
                                <div style="background: #f1f5f9; padding: 5px 10px; border-radius: 5px; width: 180px; display: flex; justify-content: space-between;">
                                    <span>Date:</span>
                                    <span style="border-bottom: 1px solid #94a3b8; width: 100px;"></span>
                                </div>
                            </div>
                        </div>

                        <!-- 1. Coloring & Introduction -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                            <div style="background: #f8fafc; padding: 10px; border-radius: 12px; border: 1px solid #e2e8f0; text-align: center;">
                                <h3 style="color: #f72585; margin: 0 0 5px; font-size: 11pt; text-align: left; display: flex; align-items: center; gap: 5px;"><i class="fas fa-paint-brush"></i> Color:</h3>
                                <div style="display: flex; justify-content: center; gap: 15px; align-items: center; height: 80px;">
                                    <div style="font-size: 65pt; font-weight: 900; color: white; -webkit-text-stroke: 2px #1e293b; line-height: 1;">${letter}</div>
                                    <div style="font-size: 65pt; font-weight: 900; color: white; -webkit-text-stroke: 2px #1e293b; line-height: 1;">${letter.toLowerCase()}</div>
                                </div>
                            </div>
                            <div style="background: #f0f9ff; padding: 10px; border-radius: 12px; border: 1px solid #bae6fd; display: flex; align-items: center; justify-content: space-around;">
                                <div style="font-size: 50pt;">${wordsList[0].emoji}</div>
                                <div style="text-align: center;">
                                    <div style="font-size: 24pt; font-weight: 900; color: white; -webkit-text-stroke: 1.5px #0284c7; font-family: 'Courier New', monospace; letter-spacing: 2px;">${wordsList[0].word.toUpperCase()}</div>
                                    <div style="font-size: 10pt; color: #0284c7; margin-top: 5px;">${wordsList[0].word} starts with ${letter}</div>
                                </div>
                            </div>
                        </div>

                        <!-- 2. Tracing Section -->
                        <div style="margin-bottom: 15px; background: #fff; border: 1px solid #e2e8f0; border-radius: 12px; padding: 10px 15px;">
                            <h3 style="color: #f72585; margin: 0 0 10px; font-size: 11pt; display: flex; align-items: center; gap: 5px;"><i class="fas fa-pen"></i> Trace and Write:</h3>
                            <div style="font-family: 'Courier New', monospace; font-size: 26pt; color: #cbd5e1; letter-spacing: 8px; line-height: 1.4;">
                                <div style="border-bottom: 1px solid #94a3b8; margin-bottom: 8px; height: 38px; display: flex; align-items: flex-end;">
                                    <span style="color: #1e293b; margin-right: 15px; font-weight: bold;">${letter}</span>
                                    ${createTracingLine(letter, 7)}
                                </div>
                                <div style="border-bottom: 1px solid #94a3b8; margin-bottom: 8px; height: 38px; display: flex; align-items: flex-end;">
                                    <span style="color: #1e293b; margin-right: 15px; font-weight: bold;">${letter.toLowerCase()}</span>
                                    ${createTracingLine(letter.toLowerCase(), 7)}
                                </div>
                                <div style="border-bottom: 1px solid #94a3b8; height: 38px; display: flex; align-items: flex-end;">
                                    <span style="color: #1e293b; margin-right: 15px; font-weight: bold;">${letter}${letter.toLowerCase()}</span>
                                    ${createTracingLine(letter + letter.toLowerCase(), 6)}
                                </div>
                            </div>
                        </div>

                        <!-- 3. Vocabulary Tracing -->
                        <div style="margin-bottom: 15px;">
                            <h3 style="color: #f72585; margin: 0 0 10px; font-size: 11pt; display: flex; align-items: center; gap: 5px;"><i class="fas fa-book"></i> Trace the Words:</h3>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px 15px;">
                                ${wordsList.slice(0, 8).map(w => `
                                    <div style="display: flex; align-items: center; gap: 10px; background: #f8fafc; padding: 5px 10px; border-radius: 8px; border: 1px dashed #cbd5e1;">
                                        <span style="font-size: 18pt;">${w.emoji}</span>
                                        <span style="font-family: 'Courier New', monospace; font-size: 18pt; color: #cbd5e1; font-weight: bold; letter-spacing: 1px; flex: 1; text-align: center;">${w.word}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>

                        <!-- 4. Fun Activity: Find & Circle -->
                        <div style="margin-bottom: 10px; background: #fff0f5; padding: 10px 15px; border-radius: 12px; border: 1px solid #fbcfe8;">
                            <h3 style="color: #db2777; margin: 0 0 10px; font-size: 11pt; display: flex; align-items: center; gap: 5px;"><i class="fas fa-search"></i> Find and Circle the letter '${letter}':</h3>
                            <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; font-family: 'Comic Sans MS', cursive; font-size: 16pt; color: #475569;">
                                ${Array(14).fill(0).map(() => {
                                    const isTarget = Math.random() > 0.6;
                                    const char = isTarget ? letter : String.fromCharCode(65 + Math.floor(Math.random() * 26));
                                    return `<span style="width: 30px; height: 30px; display: flex; align-items: center; justify-content: center;">${char}</span>`;
                                }).join('')}
                            </div>
                        </div>

                        <!-- Footer -->
                        <div style="position: absolute; bottom: 10px; left: 0; width: 100%; text-align: center;">
                            <div style="font-size: 9pt; color: #94a3b8; border-top: 1px solid #e2e8f0; padding-top: 5px; margin: 0 20px;">
                                Great Job! ‚≠ê Phonics Game Lab
                            </div>
                        </div>
                    </div>
                `;

                // ÿ•ÿ∂ÿßŸÅÿ© ÿ±ÿ≥ÿßŸÑÿ© ÿ™ÿ≠ŸÖŸäŸÑ Ÿàÿ≤ÿ± ÿ•ÿ∫ŸÑÿßŸÇ
                const loadingMsg = document.createElement('div');
                loadingMsg.innerHTML = `
                    <div style="position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #4361ee; color: white; padding: 10px 20px; border-radius: 20px; box-shadow: 0 4px 10px rgba(0,0,0,0.2); z-index: 100001; display: flex; align-items: center; gap: 10px;">
                        <i class="fas fa-spinner fa-spin"></i> ÿ¨ÿßÿ±Ÿä ÿ•ŸÜÿ¥ÿßÿ° ŸÖŸÑŸÅ PDF...
                    </div>
                `;
                
                const closeBtn = document.createElement('button');
                closeBtn.innerHTML = '<i class="fas fa-times"></i> ÿ•ÿ∫ŸÑÿßŸÇ';
                closeBtn.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    z-index: 100001;
                    padding: 10px 20px;
                    background: #ef4444;
                    color: white;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                    font-size: 16px;
                    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
                `;
                closeBtn.onclick = () => document.body.removeChild(worksheetContainer);
                
                worksheetContainer.appendChild(loadingMsg);
                worksheetContainer.appendChild(closeBtn);
                worksheetContainer.appendChild(content);
                document.body.appendChild(worksheetContainer);

                const opt = {
                    margin: 0,
                    filename: `Worksheet_Letter_${letter}.pdf`,
                    image: { type: 'jpeg', quality: 0.98 },
                    html2canvas: { scale: 2, useCORS: true, scrollY: 0 },
                    jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
                };

                // ÿ™ÿ£ÿÆŸäÿ± ÿ®ÿ≥Ÿäÿ∑ ŸÑŸÑÿ≥ŸÖÿßÿ≠ ŸÑŸÑŸÖÿ™ÿµŸÅÿ≠ ÿ®ÿ±ÿ≥ŸÖ ÿßŸÑÿπŸÜÿßÿµÿ±
                setTimeout(() => {
                    html2pdf().set(opt).from(content).save().then(() => {
                        document.body.removeChild(worksheetContainer);
                        this.showToast('ÿ™ŸÖ ÿ™ÿ≠ŸÖŸäŸÑ Ÿàÿ±ŸÇÿ© ÿßŸÑÿπŸÖŸÑ ÿ®ŸÜÿ¨ÿßÿ≠! üéâ', 3000, 'success');
                    }).catch(err => {
                        console.error(err);
                        this.showToast('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÖŸÑŸÅ', 3000, 'error');
                    });
                }, 1000);
            }

            generateRandomLettersString(targetLetter) {
                const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
                let result = [];
                for (let i = 0; i < 30; i++) {
                    if (Math.random() < 0.2) {
                        result.push(Math.random() > 0.5 ? targetLetter : targetLetter.toLowerCase());
                    } else {
                        result.push(chars.charAt(Math.floor(Math.random() * chars.length)));
                    }
                }
                return result.join(' ');
            }

            renderWordsGrid(words) {
                if (!this.wordsGrid) return;
                this.wordsGrid.innerHTML = '';
                if (!words || words.length === 0) {
                    this.wordsGrid.innerHTML = '<p>ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÉŸÑŸÖÿßÿ™ ŸÑŸáÿ∞ÿß ÿßŸÑÿ≠ÿ±ŸÅ.</p>';
                    return;
                }
                
                words.forEach(wordData => {
                    const card = document.createElement('div');
                    card.className = 'word-card';
                    card.innerHTML = `
                        <div class="word-emoji">${wordData.emoji}</div>
                        <div class="word-text">${wordData.word}</div>
                        <div class="word-ar">${wordData.translation}</div>
                        <div class="word-actions">
                            <button class="icon-btn" data-word="${wordData.word}" title="ŸÜÿ∑ŸÇ ÿßŸÑŸÉŸÑŸÖÿ©">üîä</button>
                            <button class="icon-btn" data-word="${wordData.word}" title="ÿ™ÿØÿ±ÿ® ÿπŸÑŸâ ÿßŸÑŸÜÿ∑ŸÇ">üé§</button>
                        </div>
                    `;
                    
                    const soundBtn = card.querySelector('button[title="ŸÜÿ∑ŸÇ ÿßŸÑŸÉŸÑŸÖÿ©"]');
                    soundBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.soundManager.speak(wordData.word);
                    });
                    
                    const micBtn = card.querySelector('button[title="ÿ™ÿØÿ±ÿ® ÿπŸÑŸâ ÿßŸÑŸÜÿ∑ŸÇ"]');
                    micBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        if (!this.micPermissionGranted) {
                            if (!await this.requestMicrophonePermission()) return;
                        }
                        this.listenForWord(wordData.word, micBtn);
                    });
                    
                    this.wordsGrid.appendChild(card);
                });
            }

            renderWritingBoxes(letter) {
                if (!this.capitalWriting || !this.smallWriting) return;
                this.capitalWriting.innerHTML = '';
                this.smallWriting.innerHTML = '';
                const letterProgress = this.ensureLetterRecord(letter);
                
                for (let i = 0; i < 10; i++) {
                    const capitalBox = this.createWritingBox(i, letter.toUpperCase(), true, letterProgress.exercises.writing.capital[i]);
                    this.capitalWriting.appendChild(capitalBox);
                    
                    const smallBox = this.createWritingBox(i, letter.toLowerCase(), false, letterProgress.exercises.writing.small[i]);
                    this.smallWriting.appendChild(smallBox);
                }
            }

            createWritingBox(index, expectedChar, isCapital, savedValue) {
                const box = document.createElement('input');
                box.type = 'text';
                box.className = 'writing-box';
                box.maxLength = 1;
                box.dataset.index = index;
                box.dataset.char = isCapital ? 'capital' : 'small';
                box.autocomplete = 'off';
                box.autocorrect = 'off';
                box.spellcheck = false;

                if (savedValue) {
                    box.value = savedValue;
                    this.checkWritingBox(box, expectedChar, isCapital, true);
                }

                box.addEventListener('input', () => this.checkWritingBox(box, expectedChar, isCapital));
                return box;
            }

            checkWritingBox(box, expected, isCapital, isLoading = false) {
                const entered = box.value.trim();
                const letter = this.progress.currentLetter;
                const letterProgress = this.ensureLetterRecord(letter);
                const type = isCapital ? 'capital' : 'small';

                // Strict equality check for case sensitivity
                if (entered === expected) {
                    box.classList.add('correct');
                    box.classList.remove('incorrect');
                    box.disabled = true;
                    letterProgress.exercises.writing[type][box.dataset.index] = entered;
                    
                    if (!isLoading) {
                        this.updateAndCommitScores();
                        this.soundManager.playSound('success');
                        this.speakLetter(entered, isCapital);
                        
                        // Auto-focus next input
                        const nextBox = box.nextElementSibling;
                        if (nextBox && !nextBox.disabled) {
                            nextBox.focus();
                        }
                    }
                } else {
                    box.classList.add('incorrect');
                    box.classList.remove('correct');
                    delete letterProgress.exercises.writing[type][box.dataset.index];
                    
                    if (!isLoading && entered !== '') {
                        this.soundManager.playSound('error');
                        
                        // Add specific feedback for wrong case
                        if (entered.toLowerCase() === expected.toLowerCase()) {
                            if (isCapital) {
                                this.showToast('ÿßŸÑÿ±ÿ¨ÿßÿ° ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑŸÉÿ®Ÿäÿ± (Capital)', 2000, 'warning');
                            } else {
                                this.showToast('ÿßŸÑÿ±ÿ¨ÿßÿ° ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿµÿ∫Ÿäÿ± (Small)', 2000, 'warning');
                            }
                        }
                    }
                }
                if (!isLoading) {
                    this.commitProgressUpdate();
                }
            }

            calculateCurrentWritingScore() {
                const letter = this.progress.currentLetter;
                if (!letter) return 0;
                const letterProgress = this.ensureLetterRecord(letter);
                const capitalCorrect = Object.keys(letterProgress.exercises.writing.capital || {}).length;
                const smallCorrect = Object.keys(letterProgress.exercises.writing.small || {}).length;
                return capitalCorrect + smallCorrect;
            }

            renderWordWriting(letter, words) {
                if (!this.wordWritingList) return;
                this.wordWritingList.innerHTML = '';
                if (!words || words.length === 0) return;

                const letterProgress = this.ensureLetterRecord(letter);

                words.forEach(wordData => {
                    const item = document.createElement('div');
                    item.className = 'word-writing-item';
                    
                    const savedValue = letterProgress.exercises.words[wordData.word];

                    item.innerHTML = `
                        <div class="word-info">
                            <span class="word-emoji">${wordData.emoji}</span>
                            <span>${wordData.translation}</span>
                        </div>
                        <div class="word-input-container">
                            <input type="text" class="word-input" placeholder="${wordData.word}" data-word="${wordData.word}" autocomplete="off" autocorrect="off" spellcheck="false">
                            <button class="icon-btn speak-btn" title="ŸÜÿ∑ŸÇ ÿßŸÑŸÉŸÑŸÖÿ©">üîä</button>
                            <button class="icon-btn mic-btn" title="ÿ™ÿØÿ±ÿ® ÿπŸÑŸâ ÿßŸÑŸÜÿ∑ŸÇ">üé§</button>
                        </div>
                    `;
                    
                    const input = item.querySelector('.word-input');
                    if (savedValue) {
                        input.value = savedValue;
                        this.checkWordInput(input, wordData.word, true);
                    }

                    input.addEventListener('input', () => this.checkWordInput(input, wordData.word));
                    
                    const soundBtn = item.querySelector('.speak-btn');
                    soundBtn.addEventListener('click', () => this.soundManager.speak(wordData.word));

                    const micBtn = item.querySelector('.mic-btn');
                    micBtn.addEventListener('click', async () => {
                        if (!this.micPermissionGranted) {
                            if (!await this.requestMicrophonePermission()) return;
                        }
                        // Use startSpeechRecognitionForWord if available, or listenForWord and fill input
                        if (this.startSpeechRecognitionForWord) {
                            this.startSpeechRecognitionForWord(wordData.word, micBtn, input);
                        } else {
                            this.listenForWord(wordData.word, micBtn, (transcript) => {
                                input.value = transcript;
                                this.checkWordInput(input, wordData.word);
                            });
                        }
                    });
                    
                    this.wordWritingList.appendChild(item);
                });
            }

            checkWordInput(input, expected, isLoading = false) {
                const entered = input.value.trim();
                const letter = this.progress.currentLetter;
                const letterProgress = this.ensureLetterRecord(letter);

                if (entered === expected) {
                    input.classList.add('correct');
                    input.classList.remove('incorrect');
                    input.disabled = true;
                    letterProgress.exercises.words[expected] = entered;
                    if (!isLoading) {
                        this.updateAndCommitScores();
                        this.soundManager.playSound('success');
                        this.soundManager.speak(expected);
                    }
                } else {
                    input.classList.add('incorrect');
                    input.classList.remove('correct');
                    delete letterProgress.exercises.words[expected];
                    
                    if (!isLoading && entered !== '') {
                        this.soundManager.playSound('error');
                        
                        if (entered.toLowerCase() === expected) {
                            this.showToast('ÿßŸÑÿ±ÿ¨ÿßÿ° ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑŸÉŸÑŸÖÿ© ÿ®ÿ≠ÿ±ŸàŸÅ ÿµÿ∫Ÿäÿ±ÿ© (Small Letters)', 2000, 'warning');
                        }
                    }
                }
                if (!isLoading) {
                    this.commitProgressUpdate();
                }
            }

            calculateCurrentWordsScore() {
                const letter = this.progress.currentLetter;
                if (!letter) return 0;
                const letterProgress = this.ensureLetterRecord(letter);
                return Object.keys(letterProgress.exercises.words || {}).length;
            }

            renderQuiz(quizData) {
                if (!this.quizQuestion || !this.quizOptions) return;
                if (!quizData || quizData.length === 0) {
                    this.quizQuestion.innerHTML = 'ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ£ÿ≥ÿ¶ŸÑÿ© ŸÖÿ™ÿßÿ≠ÿ©.';
                    this.quizOptions.innerHTML = '';
                    if (this.quizNavigation) this.quizNavigation.style.display = 'none';
                    return;
                }

                if (this.quizNavigation) this.quizNavigation.style.display = 'flex';
                
                if (this.currentQuizIndex >= quizData.length) {
                    this.showQuizResults();
                    return;
                }
                
                const questionData = quizData[this.currentQuizIndex];
                const letter = this.progress.currentLetter;
                const letterProgress = this.ensureLetterRecord(letter);
                const savedAnswer = letterProgress.exercises.quiz.answers[this.currentQuizIndex];

                this.questionNumberEl.textContent = this.currentQuizIndex + 1;
                this.quizQuestion.textContent = questionData.question;
                this.quizOptions.innerHTML = '';
                
                questionData.options.forEach((option, index) => {
                    const optionEl = document.createElement('div');
                    optionEl.className = 'quiz-option';
                    optionEl.textContent = option;
                    optionEl.dataset.index = index;
                    
                    optionEl.addEventListener('click', () => {
                        if (this.isAnswerSelected) return;
                        this.checkQuizAnswer(index, questionData.correct, optionEl);
                    });
                    
                    this.quizOptions.appendChild(optionEl);
                });

                if (savedAnswer !== undefined) {
                    const selectedOptionEl = this.quizOptions.querySelector(`[data-index='${savedAnswer}']`);
                    if (selectedOptionEl) {
                        this.checkQuizAnswer(savedAnswer, questionData.correct, selectedOptionEl, true);
                    }
                } else {
                    this.isAnswerSelected = false;
                    this.quizNextBtn.disabled = true;
                }
            }

            checkQuizAnswer(selectedIndex, correctIndex, optionEl, isLoading = false) {
                this.isAnswerSelected = true;
                const letter = this.progress.currentLetter;
                const letterProgress = this.ensureLetterRecord(letter);
                letterProgress.exercises.quiz.answers[this.currentQuizIndex] = selectedIndex;

                const allOptions = this.quizOptions.querySelectorAll('.quiz-option');
                allOptions.forEach(opt => opt.classList.add('disabled'));

                if (selectedIndex === correctIndex) {
                    optionEl.classList.add('correct');
                    if (!isLoading) {
                        this.quizScore++;
                        letterProgress.exercises.quiz.score = this.quizScore;
                        this.soundManager.playSound('success');
                        this.updateAndCommitScores();
                    }
                } else {
                    optionEl.classList.add('incorrect');
                    const correctOption = this.quizOptions.querySelector(`[data-index='${correctIndex}']`);
                    if (correctOption) {
                        correctOption.classList.add('correct');
                    }
                    if (!isLoading) {
                        this.soundManager.playSound('error');
                    }
                }
                
                this.quizNextBtn.disabled = false;
                
                if (!isLoading) {
                    this.commitProgressUpdate();
                    
                    // Automatic navigation after 2 seconds
                    if (this.quizTimeout) clearTimeout(this.quizTimeout);
                    this.quizTimeout = setTimeout(() => {
                        this.nextQuizQuestion();
                    }, 2000);
                }
            }

            nextQuizQuestion() {
                // Clear timeout to prevent double navigation if button is clicked
                if (this.quizTimeout) {
                    clearTimeout(this.quizTimeout);
                    this.quizTimeout = null;
                }

                const letter = this.progress.currentLetter;
                const quizData = LETTER_DATA[letter]?.quiz;
                if (!quizData) return;

                this.currentQuizIndex++;
                this.isAnswerSelected = false;
                
                if (this.currentQuizIndex < quizData.length) {
                    this.renderQuiz(quizData);
                } else {
                    const letterProgress = this.ensureLetterRecord(letter);
                    letterProgress.exercises.quiz.completed = true;
                    this.quizCompletedFlag = true;
                    this.commitProgressUpdate();
                    this.showQuizResults();
                }
            }

            showQuizResults() {
                const letter = this.progress.currentLetter;
                const quizData = LETTER_DATA[letter]?.quiz;
                const maxScore = quizData?.length || 6;

                this.quizQuestion.textContent = `üéâ ÿ£ÿ≠ÿ≥ŸÜÿ™! ŸÑŸÇÿØ ÿ£ŸÉŸÖŸÑÿ™ ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±.`;
                this.quizOptions.innerHTML = `<p style="text-align: center; width: 100%;">ŸÜÿ™Ÿäÿ¨ÿ™ŸÉ ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ© ŸáŸä: ${this.quizScore} ŸÖŸÜ ${maxScore}</p>`;
                this.quizNavigation.style.display = 'none';
                this.quizScoreEl.textContent = `${this.quizScore}/${maxScore}`;
                this.quizOptions.closest('.quiz-container').classList.add('quiz-completed');
            }

            updateAndCommitScores() {
                this.writingScore = this.calculateCurrentWritingScore();
                this.wordsScore = this.calculateCurrentWordsScore();
                
                const letter = this.progress.currentLetter;
                if (!letter) return;

                const letterProgress = this.ensureLetterRecord(letter);
                const quizData = LETTER_DATA[letter]?.quiz;

                const maxWritingScore = 20;
                const maxWordsScore = LETTER_DATA[letter]?.words.length || 6;
                const maxTestScore = quizData?.length || 6;

                this.writingScoreEl.textContent = `${this.writingScore}/${maxWritingScore}`;
                this.wordsScoreEl.textContent = `${this.wordsScore}/${maxWordsScore}`;
                this.testScoreEl.textContent = `${this.quizScore}/${maxTestScore}`;
                
                const totalScore = this.writingScore + this.wordsScore + this.quizScore;
                const maxTotalScore = maxWritingScore + maxWordsScore + maxTestScore;
                this.totalScoreEl.textContent = `${totalScore}/${maxTotalScore}`;

                letterProgress.score = totalScore;
                this.commitProgressUpdate();
                this.totalScoreEl.className = 'score-value';
                if (totalScore >= 28) {
                    this.totalScoreEl.classList.add('high');
                } else if (totalScore >= 20) {
                    this.totalScoreEl.classList.add('medium');
                } else {
                    this.totalScoreEl.classList.add('low');
                }

                const currentLetter = LETTERS[this.currentLetterIndex];
                this.updateLetterExerciseProgress(currentLetter);
            }
            
            updateProgress() {
                const currentLetter = LETTERS[this.currentLetterIndex];
                this.progressValueEl.textContent = `ÿßŸÑÿ≠ÿ±ŸÅ ${currentLetter}`;
                
                const progress = ((this.currentLetterIndex + 1) / LETTERS.length) * 100;
                this.progressBar.style.width = `${progress}%`;
            }
            
            renderAchievements() {
                this.achievementsContainer.innerHTML = '';
                
                const achievements = [
                    { id: 'first-letter', icon: 'üöÄ', name: 'ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿ£ŸàŸÑ', description: 'ÿ•ŸÉŸÖÿßŸÑ ÿ£ŸàŸÑ ÿ≠ÿ±ŸÅ', unlocked: this.completedLetters.length >= 1 },
                    { id: 'five-letters', icon: '‚≠ê', name: '5 ÿ≠ÿ±ŸàŸÅ', description: 'ÿ•ŸÉŸÖÿßŸÑ 5 ÿ≠ÿ±ŸàŸÅ', unlocked: this.completedLetters.length >= 5 },
                    { id: 'ten-letters', icon: 'üèÜ', name: '10 ÿ≠ÿ±ŸàŸÅ', description: 'ÿ•ŸÉŸÖÿßŸÑ 10 ÿ≠ÿ±ŸàŸÅ', unlocked: this.completedLetters.length >= 10 },
                    { id: 'all-letters', icon: 'üëë', name: 'ŸÉŸÑ ÿßŸÑÿ≠ÿ±ŸàŸÅ', description: 'ÿ•ŸÉŸÖÿßŸÑ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ≠ÿ±ŸàŸÅ', unlocked: this.completedLetters.length === LETTERS.length }
                ];
                
                achievements.forEach(achievement => {
                    const badge = document.createElement('div');
                    badge.className = `achievement-badge ${achievement.unlocked ? '' : 'locked'}`;
                    badge.innerHTML = `
                        <span>${achievement.icon}</span>
                        <div class="tooltip">${achievement.name}<br>${achievement.description}</div>
                    `;
                    
                    this.achievementsContainer.appendChild(badge);
                });
            }
            
            showToast(message, duration = 3000, type = 'info') {
                const toast = this.toast || document.getElementById('toast');
                if (!toast) return;
                
                toast.textContent = message;
                toast.className = `toast show ${type}`;
                
                setTimeout(() => {
                    toast.className = toast.className.replace('show', '');
                }, duration);
            }
            
            async speakLetter(letter = null, isCapital = null) {
                if (!this.soundEnabled) return;
                
                const targetLetter = letter || this.progress.currentLetter;
                if (!targetLetter) return;

                // ŸÜÿ∑ŸÇ ÿßŸÑÿ≠ÿ±ŸÅ ŸÖÿπ ŸàÿµŸÅ ŸÜŸàÿπŸá
                if (isCapital === true) {
                    await this.soundManager.speak(`Capital ${targetLetter}`);
                } else if (isCapital === false) {
                    await this.soundManager.speak(`Small ${targetLetter}`);
                } else {
                    // ŸÅŸä ÿ≠ÿßŸÑ ÿπÿØŸÖ ÿßŸÑÿ™ÿ≠ÿØŸäÿØ (ÿ≤ÿ± ÿßŸÑÿßÿ≥ÿ™ŸÖÿßÿπ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä)
                    // ŸäŸÜÿ∑ŸÇ ÿßŸÑÿ≠ÿ±ŸÅ ŸÅŸÇÿ∑ ÿ®ÿ™ŸÅÿÆŸäŸÖ
                    await this.soundManager.speak(`Letter ${targetLetter}`);
                }
            }
            
            createMiniCelebration() {
                // ŸÖŸÜÿπ ÿ™ÿπÿØÿØ ÿßŸÑÿßÿ≠ÿ™ŸÅÿßŸÑÿßÿ™
                if (this.isMiniCelebrating) return;
                this.isMiniCelebrating = true;
                
                const container = document.body;
                const miniElements = [];
                
                // ÿ•ŸÜÿ¥ÿßÿ° 5 ÿ®ÿßŸÑŸàŸÜÿßÿ™ ÿµÿ∫Ÿäÿ±ÿ©
                for (let i = 0; i < 5; i++) {
                    const balloon = document.createElement('div');
                    balloon.className = 'mini-celebrate-balloon';
                    balloon.textContent = 'üéà';
                    balloon.style.cssText = `
                        position: fixed;
                        left: ${Math.random() * 100}vw;
                        bottom: 0;
                        font-size: ${Math.random() * 10 + 20}px;
                        animation: miniFloatUp 2s ease-out forwards;
                        pointer-events: none;
                        z-index: 10000;
                    `;
                    container.appendChild(balloon);
                    miniElements.push(balloon);
                }
                
                // ÿ™ŸÜÿ∏ŸäŸÅ ÿπŸÜÿßÿµÿ± ÿßŸÑÿßÿ≠ÿ™ŸÅÿßŸÑ
                this.gameTimeouts.push(setTimeout(() => {
                    miniElements.forEach(element => {
                        if (element.parentNode) {
                            element.parentNode.removeChild(element);
                        }
                    });
                    this.isMiniCelebrating = false;
                }, 2500));
            }
            
            showRandomEncouragement() {
                const wisdomSayings = [
                    '‚ú® ŸÖŸÜ ÿ¨ÿØ Ÿàÿ¨ÿØ! ÿßÿ≥ÿ™ŸÖÿ± ŸÅŸä ÿßŸÑÿ™ŸÅŸàŸÇ!',
                    'üéÜ ŸÉŸÑ ÿ≠ÿ±ŸÅ ÿ™ÿ™ÿπŸÑŸÖŸá ŸäŸÅÿ™ÿ≠ ŸÑŸÉ ÿ®ÿßÿ®ÿßŸã ÿ¨ÿØŸäÿØÿßŸã!',
                    'üèÜ ÿ£ŸÜÿ™ ÿ®ÿ∑ŸÑ ÿ≠ŸÇŸäŸÇŸä! ÿßÿ≥ÿ™ŸÖÿ± ŸÅŸä ÿßŸÑÿ™ÿ£ŸÑŸÇ!',
                    'üåü ÿ∞ŸÉÿßÿ§ŸÉ Ÿäÿ∂Ÿäÿ° ÿßŸÑÿ∑ÿ±ŸäŸÇ ÿ£ŸÖÿßŸÖŸÉ!',
                    '‚≠ê ÿ£ÿ≠ÿ≥ŸÜÿ™! ÿ£ŸÜÿ™ ÿ™ÿµŸÜÿπ ÿßŸÑŸÖÿπÿ¨ÿ≤ÿßÿ™!',
                    'üöÄ ÿπÿßŸÑŸä Ÿàÿßÿ±ÿ™ŸÅÿπ ŸÖÿπ ÿßŸÑŸÜÿ¨ŸàŸÖ!',
                    'üåà ÿ£ŸÜÿ™ ŸÇŸàÿ≥ ŸÇÿ≤ÿ≠ ŸÅŸä ÿπÿßŸÑŸÖ ÿßŸÑÿ™ÿπŸÑŸÖ!',
                    'üî• ŸÜÿßÿ± ŸÅŸä ÿßŸÑÿ™ÿπŸÑŸÖ! ÿ£ÿ≠ÿ±ŸÇÿ™ ÿßŸÑŸÖÿ±ÿßÿ≠ŸÑ!'
                ];
                
                const randomMessage = wisdomSayings[Math.floor(Math.random() * wisdomSayings.length)];
                this.showToast(randomMessage, 2000, 'success');
            }
            
            createMiniCelebration() {
                // ŸÖŸÜÿπ ÿ™ÿπÿØÿØ ÿßŸÑÿßÿ≠ÿ™ŸÅÿßŸÑÿßÿ™
                if (this.isMiniCelebrating) return;
                this.isMiniCelebrating = true;
                
                const container = document.body;
                const miniElements = [];
                
                // ÿ•ŸÜÿ¥ÿßÿ° 5 ÿ®ÿßŸÑŸàŸÜÿßÿ™ ÿµÿ∫Ÿäÿ±ÿ©
                for (let i = 0; i < 5; i++) {
                    const balloon = document.createElement('div');
                    balloon.className = 'mini-celebrate-balloon';
                    balloon.textContent = 'üéà';
                    balloon.style.cssText = `
                        position: fixed;
                        left: ${Math.random() * 100}vw;
                        bottom: 0;
                        font-size: ${Math.random() * 10 + 20}px;
                        animation: miniFloatUp 2s ease-out forwards;
                        pointer-events: none;
                        z-index: 10000;
                    `;
                    container.appendChild(balloon);
                    miniElements.push(balloon);
                }
                
                // ÿ™ŸÜÿ∏ŸäŸÅ ÿπŸÜÿßÿµÿ± ÿßŸÑÿßÿ≠ÿ™ŸÅÿßŸÑ
                this.gameTimeouts.push(setTimeout(() => {
                    miniElements.forEach(element => {
                        if (element.parentNode) {
                            element.parentNode.removeChild(element);
                        }
                    });
                    this.isMiniCelebrating = false;
                }, 2500));
            }
            
            async speakText(text) {
                if (!this.soundEnabled) return;
                await this.soundManager.speak(text);
            }
            
            showLetterInfo() {
                const letter = LETTERS[this.currentLetterIndex];
                const letterData = LETTER_DATA[letter];
                
                const info = `
                    <div style="text-align: right; direction: rtl;">
                        <h3 style="color: var(--primary); margin-bottom: 15px;">ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿπŸÜ ÿßŸÑÿ≠ÿ±ŸÅ ${letter}</h3>
                        <p><strong>ÿßŸÑŸÜŸàÿπ:</strong> ${letterData.type}</p>
                        <p><strong>ÿßŸÑÿµŸàÿ™ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä:</strong> /${getLetterSound(letter)}/</p>
                        <p><strong>ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑŸÉÿ®Ÿäÿ±:</strong> ${letter}</p>
                        <p><strong>ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿµÿ∫Ÿäÿ±:</strong> ${letter.toLowerCase()}</p>
                        <p><strong>ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿßŸÑÿ¥ÿßÿ¶ÿπÿ©:</strong> ${letterData.words.map(w => w.word).join(', ')}</p>
                        <hr style="margin: 15px 0; border-color: var(--border);">
                        <p style="font-style: italic; color: var(--text-secondary);">
                            ${letter === 'A' || letter === 'E' || letter === 'I' || letter === 'O' || letter === 'U' ? 
                              'Ÿáÿ∞ÿß ÿ≠ÿ±ŸÅ ŸÖÿ™ÿ≠ÿ±ŸÉ ŸäŸÖŸÉŸÜ ÿ£ŸÜ ŸäŸÉŸàŸÜ ŸÑŸá ÿπÿØÿ© ÿ£ÿµŸàÿßÿ™ ÿ≠ÿ≥ÿ® ÿßŸÑŸÉŸÑŸÖÿ©.' : 
                              'Ÿáÿ∞ÿß ÿ≠ÿ±ŸÅ ÿ≥ÿßŸÉŸÜ ŸÑŸá ÿµŸàÿ™ ÿ£ÿ≥ÿßÿ≥Ÿä.'}
                        </p>
                    </div>
                `;
                
                this.showToast(info.replace(/<[^>]*>/g, ''), 4000);
            }
            
            saveLetterProgress() {
                const letter = LETTERS[this.currentLetterIndex];
                if (!this.letterProgress[letter]) {
                    this.letterProgress[letter] = {
                        writingBoxes: { capital: {}, small: {} },
                        wordInputs: {},
                        scores: { quiz: 0, writing: 0, words: 0 }
                    };
                }
                
                // Save writing boxes
                const capitalBoxes = this.capitalWriting.querySelectorAll('.writing-box');
                capitalBoxes.forEach(box => {
                    if (box.value) this.letterProgress[letter].writingBoxes.capital[box.dataset.index] = box.value;
                });
                
                const smallBoxes = this.smallWriting.querySelectorAll('.writing-box');
                smallBoxes.forEach(box => {
                    if (box.value) this.letterProgress[letter].writingBoxes.small[box.dataset.index] = box.value;
                });
                
                // Save word inputs
                const wordInputs = this.wordWritingList.querySelectorAll('.word-input');
                wordInputs.forEach(input => {
                    if (input.value) this.letterProgress[letter].wordInputs[input.dataset.word] = input.value;
                });
                
                // Save scores
                this.letterProgress[letter].scores = {
                    quiz: this.quizScore,
                    writing: this.writingScore,
                    words: this.wordsScore
                };
                
                localStorage.setItem('letterProgress', JSON.stringify(this.letterProgress));
            }

            async startSpeechRecognitionForWord(expectedWord, micButton, inputField = null) {
                // ŸÖÿ≠ÿßŸàŸÑÿ© ÿ•ÿπÿßÿØÿ© ÿ™ŸáŸäÿ¶ÿ© ÿßŸÑŸÖŸäŸÉÿ±ŸàŸÅŸàŸÜ ÿ•ÿ∞ÿß ŸÑŸÖ ŸäŸÉŸÜ ŸÖŸàÿ¨ŸàÿØÿßŸã
                if (!this.speechRecognition) {
                    console.log("SpeechRecognition not found, attempting to setup...");
                    this.setupSpeechRecognition();
                }

                if (!this.speechRecognition) {
                    this.showMicStatus('‚ö†Ô∏è ÿßŸÑŸÖÿ™ÿµŸÅÿ≠ ŸÑÿß ŸäÿØÿπŸÖ ÿßŸÑÿ™ÿπÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑÿµŸàÿ™', true);
                    return;
                }
                
                // ÿ•ŸäŸÇÿßŸÅ ÿ£Ÿä ÿπŸÖŸÑŸäÿ© ÿßÿ≥ÿ™ŸÖÿßÿπ ÿ¨ÿßÿ±Ÿäÿ©
                if (this.isListening) {
                    try {
                        this.speechRecognition.abort();
                    } catch (e) { console.log('Error aborting speech recognition:', e); }
                    this.isListening = false;
                    // ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿ¨ŸÖŸäÿπ ÿ£ÿ≤ÿ±ÿßÿ± ÿßŸÑŸÖÿßŸäŸÉ
                    document.querySelectorAll('.mic-word-write').forEach(btn => {
                        btn.classList.remove('mic-active');
                        btn.disabled = false;
                        btn.textContent = 'üé§';
                    });
                }
                
                if (!this.micPermissionGranted) {
                    if (!await this.requestMicrophonePermission()) {
                        return;
                    }
                }
                
                // ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÑÿ∫ÿ© - ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ© ÿßŸÑÿ®ÿ±Ÿäÿ∑ÿßŸÜŸäÿ©
                try {
                    this.speechRecognition.lang = 'en-GB';
                    this.speechRecognition.maxAlternatives = 20;
                    this.speechRecognition.continuous = false;
                    this.speechRecognition.interimResults = false;
                } catch (e) {
                    console.log("Error setting speech recognition properties:", e);
                }

                micButton.classList.add('mic-active');
                micButton.disabled = true;
                
                // Timeout to stop recording after 10 seconds
                const recordingTimeout = setTimeout(() => {
                    if (this.isListening) {
                        try {
                            this.speechRecognition.abort();
                        } catch (e) {}
                        this.isListening = false;
                        micButton.classList.remove('mic-active');
                        micButton.disabled = false;
                        this.showMicStatus('‚è±Ô∏è ÿßŸÜÿ™ŸáŸâ ÿßŸÑŸàŸÇÿ™ - ÿßÿ∂ÿ∫ÿ∑ ŸÑŸÑÿ™ÿ≠ÿØÿ´ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ', true);
                        setTimeout(() => this.hideMicStatus(), 2000);
                    }
                }, 10000);

                // ÿ™ÿπŸäŸäŸÜ ŸÖÿ≥ÿ™ŸÖÿπ ŸÑŸÜŸáÿßŸäÿ© ÿßŸÑÿ¨ŸÑÿ≥ÿ©
                this.speechRecognition.onend = () => {
                    clearTimeout(recordingTimeout);
                    this.isListening = false;
                    if (micButton.textContent === 'üé§' || micButton.classList.contains('mic-active')) {
                        micButton.classList.remove('mic-active');
                        micButton.disabled = false;
                    }
                };

                this.speechRecognition.onresult = async (event) => {
                    // ÿ™ÿ≠ÿ≥ŸäŸÜ: ŸÅÿ≠ÿµ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ®ÿØÿßÿ¶ŸÑ ÿßŸÑŸÖÿ≠ÿ™ŸÖŸÑÿ© ŸàŸÑŸäÿ≥ ŸÅŸÇÿ∑ ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ© ÿßŸÑÿ£ŸàŸÑŸâ
                    const alternatives = Array.from(event.results[0]).map(res => res.transcript.trim().toLowerCase());
                    const expected = expectedWord.toLowerCase();
                    
                    // ÿ™ÿ≠ÿØŸäÿØ ÿ£ŸÅÿ∂ŸÑ ÿ™ÿÆŸÖŸäŸÜ (ÿ£ŸàŸÑ ŸÜÿ™Ÿäÿ¨ÿ© ŸáŸä ÿßŸÑÿ£ŸÉÿ´ÿ± ÿØŸÇÿ© ÿπÿßÿØÿ©)
                    const bestGuess = alternatives[0];
                    
                    micButton.classList.remove('mic-active');
                    micButton.disabled = false;
                    
                    // ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿ£ŸÅÿ∂ŸÑ ÿ™ÿ∑ÿßÿ®ŸÇ
                    let isMatch = false;
                    let maxSimilarity = 0;
                    
                    for (const transcript of alternatives) {
                        const similarity = this.calculateSimilarity(transcript, expected);
                        if (similarity > maxSimilarity) maxSimilarity = similarity;
                        
                        // ŸÇÿ®ŸàŸÑ ÿßŸÑŸÜÿ∑ŸÇ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÖÿ∑ÿßÿ®ŸÇÿßŸã ÿ£Ÿà ŸÖÿ¥ÿßÿ®ŸáÿßŸã ÿ¨ÿØÿßŸã (ÿ™ŸÖ ÿ™ÿÆŸÅŸäŸÅ ÿßŸÑŸÜÿ≥ÿ®ÿ© ÿ•ŸÑŸâ 60% ŸÑŸÑÿ£ÿ∑ŸÅÿßŸÑ)
                        if (transcript === expected || similarity >= 0.6) {
                            isMatch = true;
                            break;
                        }
                    }
                    
                    if (isMatch) {
                        if (inputField) {
                            inputField.value = expectedWord;
                            inputField.classList.add('correct');
                            inputField.classList.remove('incorrect');
                            
                            // ÿ™ÿ≠ÿØŸäÿ´ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ™ŸÇÿØŸÖ
                            const letter = this.progress.currentLetter;
                            const letterProgress = this.ensureLetterRecord(letter);
                            letterProgress.exercises.words[expectedWord] = expectedWord;

                            // ÿ•ÿ∂ÿßŸÅÿ© ÿπŸÑÿßŸÖÿ© "ŸÖÿ¨ÿ™ÿßÿ≤"
                            const container = inputField.parentElement;
                            let badge = container.querySelector('.passed-badge');
                            if (!badge) {
                                badge = document.createElement('span');
                                badge.className = 'passed-badge';
                                badge.textContent = '‚úÖ ŸÖÿ¨ÿ™ÿßÿ≤';
                                badge.style.color = '#22c55e';
                                badge.style.fontWeight = 'bold';
                                badge.style.marginRight = '10px';
                                badge.style.fontSize = '14px';
                                badge.style.animation = 'fadeIn 0.5s ease';
                                container.appendChild(badge);
                            }
                            
                            // ÿ™ŸÑŸàŸäŸÜ ÿÆŸÑŸÅŸäÿ© ÿßŸÑŸÖÿ±ÿ®ÿπ ÿ®ÿßŸÑÿ£ÿÆÿ∂ÿ±
                            inputField.style.backgroundColor = '#dcfce7';
                            inputField.style.borderColor = '#22c55e';
                            
                            this.updateAndCommitScores();
                        }
                        
                        micButton.textContent = '‚úÖ';
                        this.showMicStatus('üéâ ŸÜÿ∑ŸÇ ŸÖŸÖÿ™ÿßÿ≤!', false);
                        this.soundManager.playSound('success');
                        
                        setTimeout(() => {
                            micButton.textContent = 'üé§';
                            this.hideMicStatus();
                        }, 2000);
                        
                        await this.speakText(expectedWord);
                    } else {
                        micButton.textContent = '‚ùå';
                        // ÿπÿ±ÿ∂ ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑÿ™Ÿä ÿ™ŸÖ ÿ≥ŸÖÿßÿπŸáÿß ŸÑŸÖÿ≥ÿßÿπÿØÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
                        this.showMicStatus(`ÿ≥ŸÖÿπÿ™: "${bestGuess}" - ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ: ${expectedWord}`, true);
                        this.soundManager.playSound('error');
                        
                        setTimeout(() => {
                            micButton.textContent = 'üé§';
                            this.hideMicStatus();
                        }, 4000);
                        
                        await this.speakText(expectedWord);
                    }
                };
                
                this.speechRecognition.onerror = (event) => {
                    micButton.classList.remove('mic-active');
                    micButton.disabled = false;
                    micButton.textContent = 'üé§';
                    
                    if (event.error === 'no-speech') {
                        this.showMicStatus('‚ö†Ô∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿ≥ŸÖÿßÿπ ÿßŸÑÿµŸàÿ™ÿå ÿ≠ÿßŸàŸÑ ÿßŸÑÿ™ÿ≠ÿØÿ´ ÿ®ÿµŸàÿ™ ÿ£ÿπŸÑŸâ üîä', true);
                    } else if (event.error === 'audio-capture') {
                        this.showMicStatus('‚ùå ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖŸäŸÉÿ±ŸàŸÅŸàŸÜ ŸÖÿ™ÿßÿ≠', true);
                    } else {
                        this.showMicStatus('‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿ™ÿπÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑÿµŸàÿ™', true);
                    }
                    
                    setTimeout(() => this.hideMicStatus(), 3000);
                };
                
                try {
                    this.isListening = true;
                    this.speechRecognition.start();
                } catch (error) {
                    this.isListening = false;
                    micButton.classList.remove('mic-active');
                    micButton.disabled = false;
                    this.showMicStatus('‚ùå ÿπÿ∞ÿ±Ÿãÿßÿå ŸÑÿß ŸäŸÖŸÉŸÜ ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑŸÖŸäŸÉÿ±ŸàŸÅŸàŸÜ', true);
                    setTimeout(() => this.hideMicStatus(), 3000);
                }
            }
            
            calculateSimilarity(str1, str2) {
                const longer = str1.length > str2.length ? str1 : str2;
                const shorter = str1.length > str2.length ? str2 : str1;
                
                if (longer.length === 0) return 1.0;
                
                const distance = this.levenshteinDistance(longer, shorter);
                return (longer.length - distance) / longer.length;
            }
            
            levenshteinDistance(str1, str2) {
                const matrix = [];
                
                for (let i = 0; i <= str2.length; i++) {
                    matrix[i] = [i];
                }
                
                for (let j = 0; j <= str1.length; j++) {
                    matrix[0][j] = j;
                }
                
                for (let i = 1; i <= str2.length; i++) {
                    for (let j = 1; j <= str1.length; j++) {
                        const cost = str1.charAt(j - 1) === str2.charAt(i - 1) ? 0 : 1;
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j - 1] + cost
                        );
                    }
                }
                
                return matrix[str2.length][str1.length];
            }
            
            // ÿØÿßŸÑÿ© ÿ®ÿØŸäŸÑÿ© ŸÑŸÑÿßÿ≥ÿ™ŸÖÿßÿπ ŸÅŸä ÿ≠ÿßŸÑÿ© ÿπÿØŸÖ Ÿàÿ¨ŸàÿØ startSpeechRecognitionForWord
            async listenForWord(expectedWord, micButton, callback = null) {
                if (this.startSpeechRecognitionForWord) {
                    // ÿ•ÿ∞ÿß ÿ™ŸÖ ÿ™ŸÖÿ±Ÿäÿ± callbackÿå ŸÜŸÇŸàŸÖ ÿ®ÿ™ÿπÿØŸäŸÑ ÿßŸÑÿ≥ŸÑŸàŸÉ ŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖŸá
                    if (callback) {
                        // ŸÜÿ≠ÿ™ŸÅÿ∏ ÿ®ÿßŸÑÿØÿßŸÑÿ© ÿßŸÑÿ£ÿµŸÑŸäÿ©
                        const originalOnResult = this.speechRecognition ? this.speechRecognition.onresult : null;
                        
                        // ŸÜÿ≥ÿ™ÿØÿπŸä ÿßŸÑÿØÿßŸÑÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©
                        await this.startSpeechRecognitionForWord(expectedWord, micButton);
                        
                        // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÑÿØŸäŸÜÿß speechRecognitionÿå ŸÜÿ∂ŸäŸÅ ÿßŸÑŸÄ callback ŸÑŸÑŸÜÿ™Ÿäÿ¨ÿ©
                        if (this.speechRecognition) {
                            const standardOnResult = this.speechRecognition.onresult;
                            this.speechRecognition.onresult = async (event) => {
                                // ŸÜÿ≥ÿ™ÿØÿπŸä ÿßŸÑŸÖÿπÿßŸÑÿ¨ ÿßŸÑŸÇŸäÿßÿ≥Ÿä ÿ£ŸàŸÑÿßŸã ŸÑŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ÿßŸÑÿ™ÿ£ÿ´Ÿäÿ±ÿßÿ™ ÿßŸÑÿ®ÿµÿ±Ÿäÿ© ŸàÿßŸÑÿµŸàÿ™Ÿäÿ©
                                if (standardOnResult) await standardOnResult(event);
                                
                                // ÿ´ŸÖ ŸÜÿ≥ÿ™ÿØÿπŸä ÿßŸÑŸÄ callback ŸÖÿπ ÿßŸÑŸÜÿµ ÿßŸÑŸÖŸÉÿ™ÿ¥ŸÅ
                                const transcript = event.results[0][0].transcript.trim().toLowerCase();
                                callback(transcript);
                            };
                        }
                    } else {
                        await this.startSpeechRecognitionForWord(expectedWord, micButton);
                    }
                } else {
                    console.error("Speech recognition function not found");
                    this.showToast("ÿÆÿ∑ÿ£ ŸÅŸä ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ™ÿπÿ±ŸÅ ÿπŸÑŸâ ÿßŸÑÿµŸàÿ™", 3000);
                }
            }

            resetLetter() {
                if (confirm('ŸáŸÑ ÿ™ÿ±ŸäÿØ ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿ≠ÿßŸÑŸäÿü ÿ≥Ÿäÿ™ŸÖ ŸÖÿ≥ÿ≠ ŸÉŸÑ ÿßŸÑÿ™ŸÇÿØŸÖ ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑÿ≠ÿ±ŸÅ.')) {
                    this.loadLetter(this.currentLetterIndex);
                }
            }
            
            previousLetter() {
                if (this.currentLetterIndex > 0) {
                    this.loadLetter(this.currentLetterIndex - 1);
                }
            }
            
            finishLetter() {
                const currentLetter = LETTERS[this.currentLetterIndex];
                this.updateLetterExerciseProgress(currentLetter);
                const latestEntry = this.ensureLetterRecord(currentLetter);

                if (latestEntry.exercisesCompleted !== true) {
                    this.showToast('ÿ£ŸÉŸÖŸÑ ÿ¨ŸÖŸäÿπ ÿ™ŸÖÿßÿ±ŸäŸÜ ÿßŸÑÿ≠ÿ±ŸÅ (ÿßŸÑŸÉÿ™ÿßÿ®ÿ©ÿå ÿßŸÑŸÉŸÑŸÖÿßÿ™ÿå ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±) ŸÇÿ®ŸÑ ÿßŸÑÿßŸÜÿ™ŸÇÿßŸÑ!', 4000);
                    return;
                }

                if ((latestEntry.score || 0) < this.REQUIRED_SCORE) {
                    this.showToast(`ÿ™ÿ≠ÿ™ÿßÿ¨ ÿ•ŸÑŸâ ÿØÿ±ÿ¨ÿ© ${this.REQUIRED_SCORE} ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ ŸÅŸä ÿßŸÑÿ™ŸÖÿßÿ±ŸäŸÜ. ÿØÿ±ÿ¨ÿ™ŸÉ ÿßŸÑÿ≠ÿßŸÑŸäÿ©: ${latestEntry.score || 0}`, 4000);
                    return;
                }

                const missingGames = this.getMissingRequiredGames(currentLetter);
                
                // ÿ™ÿ¥ÿ∫ŸäŸÑ ÿµŸàÿ™ ÿßŸÑÿ™ÿµŸÅŸäŸÇ ŸàÿßŸÑÿßÿ≠ÿ™ŸÅÿßŸÑ ÿØÿßÿ¶ŸÖÿßŸã ÿπŸÜÿØ ÿ•ŸÜŸáÿßÿ° ÿßŸÑÿ™ŸÖÿßÿ±ŸäŸÜ
                this.soundManager.playSound('success'); 
                this.launchBalloonsCelebration();

                if (missingGames.length > 0) {
                    // ÿ™ÿ≠ÿØŸäÿ´ ŸÜÿµŸàÿµ ŸÜÿßŸÅÿ∞ÿ© ÿßŸÑÿ£ŸÑÿπÿßÿ® ŸÑÿ™ŸÉŸàŸÜ ÿ™ÿ≠ŸÅŸäÿ≤Ÿäÿ©
                    this.motivationTitle.textContent = "ÿ£ŸÜÿ™ ÿ®ÿ∑ŸÑ ÿ≠ŸÇŸäŸÇŸä! ü¶∏‚Äç‚ôÇÔ∏è";
                    this.motivationSubtitle.textContent = "ÿ£ÿ≠ÿ≥ŸÜÿ™! ÿßŸÑÿ¢ŸÜ ŸàŸÇÿ™ ÿßŸÑŸÖÿ±ÿ≠ ŸàÿßŸÑÿ£ŸÑÿπÿßÿ®! üéÆ";
                    this.motivationQuote.textContent = "ÿ£ŸÉŸÖŸÑ ÿßŸÑÿ£ŸÑÿπÿßÿ® ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ© ŸÑÿ™ÿµÿ®ÿ≠ ŸÖÿ≠ÿ™ÿ±ŸÅÿßŸã Ÿàÿ™ŸÜÿ™ŸÇŸÑ ŸÑŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿ™ÿßŸÑŸä!";
                } else {
                    // ÿ•ÿ∞ÿß ÿ™ŸÖ ÿ•ŸÜŸáÿßÿ° ŸÉŸÑ ÿ¥Ÿäÿ°
                    if (!latestEntry.completed) {
                        this.markLetterCompleted(currentLetter);
                        this.renderLettersNav();
                        this.renderAchievements();
                    }
                    this.unlockNextLetter(currentLetter);
                    
                    this.motivationTitle.textContent = "ÿ•ŸÜÿ¨ÿßÿ≤ ŸÖÿ∞ŸáŸÑ! üåü";
                    this.motivationSubtitle.textContent = "ŸÑŸÇÿØ ÿ£ÿ™ŸÖŸÖÿ™ ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖŸáÿßŸÖ ŸÑŸáÿ∞ÿß ÿßŸÑÿ≠ÿ±ŸÅ!";
                    this.motivationQuote.textContent = "ŸäŸÖŸÉŸÜŸÉ ÿßŸÑŸÑÿπÿ® ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ÿ£Ÿà ÿßŸÑÿßŸÜÿ™ŸÇÿßŸÑ ŸÑŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿ™ÿßŸÑŸä.";
                }

                // ÿßŸÑÿßŸÜÿ™ŸÇÿßŸÑ ŸÅŸàÿ±ÿßŸã ŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ£ŸÑÿπÿßÿ® ÿØÿßÿ¶ŸÖÿßŸã
                this.showGameSelection();
                this.showToast('ÿßÿÆÿ™ÿ± ŸÑÿπÿ®ÿ© ŸÑŸÑÿ®ÿØÿ° ÿ£Ÿà ÿßŸÜÿ™ŸÇŸÑ ŸÑŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿ™ÿßŸÑŸä! üöÄ', 3000, 'success');
            }
            
            showMotivationModal(totalScore) {
                const letter = LETTERS[this.currentLetterIndex];
                const studentName = this.studentName || 'ÿßŸÑÿ®ÿ∑ŸÑ';
                
                const fireQuotes = [
                    `üî• ${studentName}ÿå ÿ£ŸÜÿ™ ŸÜÿßÿ± ŸÅŸä ÿßŸÑÿ™ÿπŸÑŸÖ! ŸÖÿßÿ¥ÿßÿ° ÿßŸÑŸÑŸá!`,
                    `üöÄ ${studentName} ŸäÿµÿπÿØ ÿ•ŸÑŸâ ÿßŸÑŸÇŸÖÿ© ÿ®ÿ≥ÿ±ÿπÿ© ÿßŸÑÿµÿßÿ±ŸàÿÆ! ÿ±ŸáŸäÿ®!`,
                    `üëë ŸÖŸÑŸÉ/ŸÖŸÑŸÉÿ© ÿßŸÑÿ≠ÿ±ŸàŸÅ ŸáŸà/ŸáŸä ${studentName}! ŸÑŸÑÿ£ÿ®ÿØ!`,
                    `üí´ ÿ®ÿ±ÿßÿπÿ© ${studentName} ŸÑÿß ŸÖÿ´ŸäŸÑ ŸÑŸáÿß! ÿßŸÜÿ∑ŸÑŸÇ Ÿàÿ≠ŸÑŸëŸÇ!`,
                    `üåü ${studentName} ŸäŸÑŸÖÿπ ŸÉÿßŸÑŸÜÿ¨ŸàŸÖ ŸÅŸä ÿ≥ŸÖÿßÿ° ÿßŸÑÿ™ÿπŸÑŸÖ! ÿ≥ÿ®ÿ≠ÿßŸÜ ÿßŸÑŸÑŸá!`,
                    `üèÜ ${studentName} Ÿäÿ≠ÿµÿØ ÿßŸÑÿ¨Ÿàÿßÿ¶ÿ≤ Ÿàÿßÿ≠ÿØÿ© ÿ™ŸÑŸà ÿßŸÑÿ£ÿÆÿ±Ÿâ! ÿ®ÿ±ÿßŸÅŸà!`,
                    `‚ö° ${studentName} ÿ≥ÿ±Ÿäÿπ ÿßŸÑÿ™ÿπŸÑŸÖ ŸÉÿßŸÑÿ®ÿ±ŸÇ! ŸÅŸÑÿßÿ¥!`,
                    `üéØ ${studentName} ŸäÿµŸäÿ® ÿßŸÑŸáÿØŸÅ ŸÅŸä ŸÉŸÑ ŸÖÿ±ÿ©! ÿ®ŸàŸÑÿ≤ ÿ¢Ÿä!`
                ];
                
                const scoreQuotes = totalScore >= 30 ? [
                    `ŸÖÿ∞ŸáŸÑ! ${studentName} ÿ≠ŸÇŸÇ ${totalScore}/32! ÿ≥Ÿàÿ®ÿ± ÿ≥Ÿàÿ®ÿ±!`,
                    `ÿ•ÿ™ŸÇÿßŸÜ ŸÉÿßŸÖŸÑ! ${studentName} ŸÖŸÖÿ™ÿßÿ≤! ŸàÿßŸà ŸàÿßŸà!`,
                    `ÿ£ÿØÿßÿ° ÿÆÿßÿ±ŸÇ! ${studentName} ŸÅŸä ÿßŸÑŸÇŸÖÿ©! ÿ£ŸÖŸäÿ≤ŸäŸÜÿ¨!`
                ] : totalScore >= 25 ? [
                    `ÿ±ÿßÿ¶ÿπ! ${studentName} Ÿäÿ≠ŸÇŸÇ ŸÜÿ™ÿßÿ¶ÿ¨ ŸÖŸÖÿ™ÿßÿ≤ÿ©! ÿ∫ÿ±Ÿäÿ™!`,
                    `ÿ•ŸÜÿ¨ÿßÿ≤ ŸÉÿ®Ÿäÿ±! ${studentName} Ÿäÿ™ŸÇÿØŸÖ ÿ®ÿ´ÿ®ÿßÿ™! ÿ•ŸÉÿ≥ŸÑŸäŸÜÿ™!`,
                    `ŸÖŸÖÿ™ÿßÿ≤! ${studentName} ÿπŸÑŸâ ÿßŸÑÿ∑ÿ±ŸäŸÇ ÿßŸÑÿµÿ≠Ÿäÿ≠! ŸÅÿßŸÜÿ™ÿßÿ≥ÿ™ŸäŸÉ!`
                ] : [
                    `ÿ¨ŸäÿØ ÿ¨ÿØÿßŸã! ${studentName} ŸäŸÉŸÖŸÑ ÿßŸÑŸÖŸáŸÖÿ© ÿ®ŸÜÿ¨ÿßÿ≠! ÿ∫ŸàÿØ ÿ¨Ÿàÿ®!`,
                    `ŸÖÿ´ÿßÿ®ÿ±ÿ© ÿ±ÿßÿ¶ÿπÿ©! ${studentName} Ÿäÿ≥ÿ™ŸÖÿ± ŸÅŸä ÿßŸÑÿ™ŸÇÿØŸÖ! ŸàŸäŸÑ ÿØÿßŸÜ!`,
                    `ÿ•ŸÜÿ¨ÿßÿ≤ ŸÖÿ¥ÿ±ŸÅ! ${studentName} Ÿäÿ®ÿ∞ŸÑ ÿ¨ŸáÿØÿßŸã ŸÉÿ®Ÿäÿ±ÿßŸã! ÿ¢Ÿàÿ™ÿ≥ÿ™ÿßŸÜÿØŸäŸÜÿ¨!`
                ];
                
                const randomFireQuote = fireQuotes[Math.floor(Math.random() * fireQuotes.length)];
                const randomScoreQuote = scoreQuotes[Math.floor(Math.random() * scoreQuotes.length)];
                
                this.motivationTitle.textContent = "ÿ≥ŸÑŸÖÿ™ Ÿäÿßÿ®ÿ∑ŸÑ! ‚ú®";
                this.motivationSubtitle.textContent = `ŸÑŸÇÿØ ÿ£ÿ™ŸÖŸÖÿ™ ÿ™ÿπŸÑŸÖ ÿßŸÑÿ≠ÿ±ŸÅ ${letter} ÿ®ŸÜÿ¨ÿßÿ≠ - ${randomScoreQuote}`;
                
                const wisdomQuotes = [
                    "ŸÖŸÜ ÿ¨ÿØ Ÿàÿ¨ÿØÿå ŸàŸÖŸÜ ÿ≤ÿ±ÿπ ÿ≠ÿµÿØ. ÿßÿ≥ÿ™ŸÖÿ± ŸÅŸä ÿßŸÑÿ™ŸÇÿØŸÖ!",
                    "ÿßŸÑÿπŸÑŸÖ ŸÜŸàÿ±ÿå ŸàÿßŸÑÿ¨ŸáŸÑ ÿ∏ŸÑÿßŸÖ. ÿ£ŸÜÿ™ ÿ™ŸÜŸäÿ± ÿπŸÇŸÑŸÉ ÿ®ÿßŸÑŸÖÿπÿ±ŸÅÿ©!",
                    "ŸÉŸÑ ÿ≠ÿ±ŸÅ ÿ™ÿ™ÿπŸÑŸÖŸá ŸáŸà ÿÆÿ∑Ÿàÿ© ÿ¨ÿØŸäÿØÿ© ŸÜÿ≠Ÿà ÿ•ÿ™ŸÇÿßŸÜ ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ©!",
                    "ÿ£ŸÜÿ™ ŸÖÿ®ÿØÿπ! ÿßÿ≥ÿ™ŸÖÿ± ŸÅŸä ÿßŸÑÿ™ÿπŸÑŸÖ Ÿàÿ≥ŸàŸÅ ÿ™ÿµŸÑ ÿ•ŸÑŸâ ÿßŸÑŸÇŸÖÿ©!",
                    "ÿßŸÑÿ•ÿµÿ±ÿßÿ± ŸàÿßŸÑÿπÿ≤ŸäŸÖÿ© ŸáŸÖÿß ÿ≥ÿ± ÿßŸÑŸÜÿ¨ÿßÿ≠. ÿ£ŸÜÿ™ ÿπŸÑŸâ ÿßŸÑÿ∑ÿ±ŸäŸÇ ÿßŸÑÿµÿ≠Ÿäÿ≠!",
                    "ÿßŸÑŸÜÿ¨ÿßÿ≠ ŸáŸà ŸÖÿ¨ŸÖŸàÿπ ÿßŸÑÿ¨ŸáŸàÿØ ÿßŸÑÿµÿ∫Ÿäÿ±ÿ© ÿßŸÑŸÖÿ™ŸÉÿ±ÿ±ÿ© ŸäŸàŸÖŸäÿßŸã. ÿ£ŸÜÿ™ ÿ™ŸÅÿπŸÑŸáÿß ÿ®ÿ¥ŸÉŸÑ ÿ±ÿßÿ¶ÿπ!",
                    "ŸÉŸÑŸÖÿß ÿ™ÿπŸÑŸÖÿ™ ÿ£ŸÉÿ´ÿ±ÿå ŸÉŸÑŸÖÿß ÿ£ÿµÿ®ÿ≠ÿ™ ÿ£ŸÉÿ´ÿ± ÿ´ŸÇÿ©. ÿ£ŸÜÿ™ ÿ±ÿßÿ¶ÿπ!",
                    "ÿ£ŸÜÿ™ ÿ®ÿ∑ŸÑ ÿ≠ŸÇŸäŸÇŸäÿå ÿßÿ≥ÿ™ŸÖÿ± ŸÅŸä ÿßŸÑÿ™ÿ£ŸÑŸÇ! ŸàÿßŸà!",
                    "ÿ∞ŸÉÿßÿ§ŸÉ Ÿäÿ∂Ÿäÿ° ÿßŸÑÿ∑ÿ±ŸäŸÇÿå ÿ£ÿ≠ÿ≥ŸÜÿ™! ÿ®ÿ±ŸäŸÑŸäŸÜÿ™!",
                    "ŸÉŸÑ ÿÆÿ∑Ÿàÿ© ÿµÿ∫Ÿäÿ±ÿ© ÿ™ŸÇÿ±ÿ®ŸÉ ŸÖŸÜ ÿßŸÑÿ≠ŸÑŸÖ ÿßŸÑŸÉÿ®Ÿäÿ±!",
                    "ÿ£ŸÜÿ™ ÿ™ÿµŸÜÿπ ŸÖÿ≥ÿ™ŸÇÿ®ŸÑŸÉ ÿ®ŸäÿØŸÉÿå ÿßÿ≥ÿ™ŸÖÿ±!",
                    "ŸÅÿÆŸàÿ±ŸàŸÜ ÿ®ŸÉ ÿ¨ÿØÿßŸãÿå Ÿäÿß ÿ®ÿ∑ŸÑ!",
                    "ÿ£ŸÜÿ™ ÿ™ÿ≥ÿ™ÿ≠ŸÇ ŸÉŸÑ ÿßŸÑÿ™ŸÇÿØŸäÿ± ÿπŸÑŸâ ŸÖÿ¨ŸáŸàÿØŸÉ ÿßŸÑÿ±ÿßÿ¶ÿπ!",
                    "ŸÑÿß ÿ™ÿ™ŸàŸÇŸÅ ÿ£ÿ®ÿØÿßŸã ÿπŸÜ ÿßŸÑÿ™ÿπŸÑŸÖÿå ŸÅÿ£ŸÜÿ™ ÿ™ŸÖŸÑŸÉ ÿπŸÇŸÑÿßŸã ÿ∞Ÿáÿ®ŸäÿßŸã!"
                ];
                
                const randomQuote = wisdomQuotes[Math.floor(Math.random() * wisdomQuotes.length)];
                this.motivationQuote.textContent = `${randomFireQuote}\n${randomQuote}`;
                
                this.motivationModal.style.display = 'flex';
                this.soundManager.playSound('win');

                // ÿ±ÿ≥ÿßÿ¶ŸÑ ÿ™ÿ¥ÿ¨ŸäÿπŸäÿ© ŸÖÿ≠ÿ≥ŸÜÿ© ÿ®ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ©
                const superEnglishPhrases = [
                    "Fantastic job!",
                    "You are amazing!", 
                    "Excellent work!",
                    "Outstanding!",
                    "Brilliant!",
                    "Keep it up, superstar!",
                    "You are a champion!",
                    "Well done, genius!",
                    "Marvelous!",
                    "You rock!",
                    "Awesome work!",
                    "You are incredible!"
                ];
                const randomEnglishPhrase = superEnglishPhrases[Math.floor(Math.random() * superEnglishPhrases.length)];
                
                // ÿ™ÿ£ÿÆŸäÿ± ÿ®ÿ≥Ÿäÿ∑ ŸÑŸÑÿ≥ŸÖÿßÿ≠ ŸÑÿµŸàÿ™ ÿßŸÑŸÅŸàÿ≤ ÿ®ÿßŸÑÿßŸÜÿ™Ÿáÿßÿ° ÿ¨ÿ≤ÿ¶ŸäÿßŸã
                setTimeout(() => {
                    this.soundManager.speak(randomEnglishPhrase);
                }, 1500);
            }
            
            showGames() {
                this.motivationModal.style.display = 'none';
                this.showGameSelection();
            }
            
            showGameSelection() {
                this.motivationModal.style.display = 'flex';
                
                // Update game cards status
                const currentLetter = LETTERS[this.currentLetterIndex];
                const passedGames = this.passedGames[currentLetter] || [];
                const cards = this.gamesGrid.querySelectorAll('.game-card');
                
                cards.forEach(card => {
                    const gameType = card.dataset.game;
                    let badge = card.querySelector('.mandatory-badge');
                    const isMandatory = this.mandatoryGames.includes(gameType);
                    
                    if (isMandatory) {
                        if (!badge) {
                            badge = document.createElement('div');
                            badge.className = 'mandatory-badge';
                            card.appendChild(badge);
                        }

                        if (passedGames.includes(gameType)) {
                            card.classList.add('completed');
                            badge.textContent = 'ÿ™ŸÖ ‚úÖ';
                            badge.style.background = '#22c55e';
                        } else {
                            card.classList.remove('completed');
                            badge.textContent = 'ŸÖÿ∑ŸÑŸàÿ®';
                            badge.style.background = '#ef4444';
                        }
                    } else {
                        if (badge) {
                            badge.remove();
                        }
                        card.classList.remove('completed');
                    }
                });

                // ÿ™ÿ≠ÿØŸäÿ´ ÿ≤ÿ± ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿ™ÿßŸÑŸä
                const nextLetterBtn = document.getElementById('nextLetter');
                const allRequiredGamesDone = this.requiredGames.every(game => passedGames.includes(game));
                
                if (allRequiredGamesDone) {
                    nextLetterBtn.style.opacity = '1';
                    nextLetterBtn.style.cursor = 'pointer';
                    nextLetterBtn.innerHTML = '<span>‚û°Ô∏è</span> ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿ™ÿßŸÑŸä';
                    nextLetterBtn.title = "ÿßŸÜÿ™ŸÇŸÑ ŸÑŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿ™ÿßŸÑŸä";
                } else {
                    nextLetterBtn.style.opacity = '0.5';
                    nextLetterBtn.style.cursor = 'not-allowed';
                    nextLetterBtn.innerHTML = '<span>üîí</span> ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿ™ÿßŸÑŸä';
                    nextLetterBtn.title = "ÿ£ŸÉŸÖŸÑ ÿßŸÑÿ£ŸÑÿπÿßÿ® ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ© ÿ£ŸàŸÑÿßŸã";
                }
            }
            
            nextLetter() {
                this.motivationModal.style.display = 'none';
                
                const nextIndex = this.currentLetterIndex + 1;
                if (nextIndex < LETTERS.length) {
                    const currentLetter = LETTERS[this.currentLetterIndex];
                    const nextLetter = LETTERS[nextIndex];
                    
                    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ•ŸÉŸÖÿßŸÑ ÿßŸÑÿ£ŸÑÿπÿßÿ® ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ© ŸÑŸÅÿ™ÿ≠ ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿ™ÿßŸÑŸä
                    const entry = this.ensureLetterRecord(currentLetter);
                    const games = entry.games || {};
                    
                    // ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿ£ŸÑÿπÿßÿ® ÿßŸÑŸÖÿ™ÿ®ŸÇŸäÿ©
                    const missingGames = this.requiredGames.filter(game => games[game] !== true);
                    
                    if (missingGames.length > 0) {
                        // ÿ™ÿ≠ÿ∂Ÿäÿ± ÿ±ÿ≥ÿßŸÑÿ© ŸÖŸÅÿµŸÑÿ© ÿ®ÿßŸÑÿ£ŸÑÿπÿßÿ® ÿßŸÑŸÜÿßŸÇÿµÿ©
                        const missingNames = missingGames.map(g => this.getGameName(g)).join(' Ÿà ');
                        
                        // ÿ•ÿ∞ÿß ŸÑŸÖ ÿ™ŸÉÿ™ŸÖŸÑ ÿßŸÑÿ£ŸÑÿπÿßÿ®ÿå ÿ£ÿ∏Ÿáÿ± ÿ±ÿ≥ÿßŸÑÿ© Ÿàÿ£ÿπÿØ ŸÅÿ™ÿ≠ ÿßŸÑŸÜÿßŸÅÿ∞ÿ©
                        this.showToast(`ÿπÿ∞ÿ±ÿßŸã! Ÿäÿ¨ÿ® ÿ•ŸÉŸÖÿßŸÑ ÿßŸÑÿ£ŸÑÿπÿßÿ® ÿßŸÑÿ™ÿßŸÑŸäÿ© ÿ£ŸàŸÑÿßŸã: ${missingNames}`, 5000, 'error');
                        this.showGameSelection();
                        return;
                    }
                    
                    // ÿ•ÿ∞ÿß ÿßŸÉÿ™ŸÖŸÑÿ™ ÿßŸÑÿ¥ÿ±Ÿàÿ∑
                    this.unlockLetter(nextLetter);
                    this.goToLetter(nextLetter);
                } else {
                    this.showCertificate();
                }
            }
            
            // ============ ÿ™ÿ≠ÿ≥ŸäŸÜ ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ£ŸÑÿπÿßÿ® ============
            
            // Performance-optimized game loop
            runOptimizedGameLoop(gameLoopFunction) {
                const animate = (currentTime) => {
                    if (!this.gameRunning) return;
                    
                    if (currentTime - this.lastFrameTime >= this.frameInterval) {
                        gameLoopFunction();
                        this.lastFrameTime = currentTime;
                    }
                    
                    const animationId = requestAnimationFrame(animate);
                    this.activeAnimations.add(animationId);
                };
                
                const animationId = requestAnimationFrame(animate);
                this.activeAnimations.add(animationId);
            }
            
            // Clean up all game resources
            cleanupGameResources() {
                this.gameRunning = false;
                
                // Cancel all active animations
                if (this.activeAnimations) {
                    this.activeAnimations.forEach(id => {
                        try {
                            cancelAnimationFrame(id);
                        } catch (e) {
                            console.warn('Error canceling animation frame:', e);
                        }
                    });
                    this.activeAnimations.clear();
                }
                
                // Clear intervals and timeouts
                if (this.gameInterval) {
                    clearInterval(this.gameInterval);
                    this.gameInterval = null;
                }
                
                if (this.gameAnimationFrame) {
                    cancelAnimationFrame(this.gameAnimationFrame);
                    this.gameAnimationFrame = null;
                }
                
                // Clear any pending timeouts
                if (this.gameTimeouts && this.gameTimeouts.length > 0) {
                    this.gameTimeouts.forEach(timeout => clearTimeout(timeout));
                    this.gameTimeouts = [];
                }
                
                // Remove event listeners
                this.removeAllGameEventListeners();
                
                // Remove resize listener
                if (this.resizeHandler) {
                    window.removeEventListener('resize', this.resizeHandler);
                    this.resizeHandler = null;
                }
                
                // Remove hidden input if exists
                if (this.hiddenInput) {
                    if (this.hiddenInput.parentNode) {
                        this.hiddenInput.parentNode.removeChild(this.hiddenInput);
                    }
                    this.hiddenInput = null;
                }
                
                // Reset celebration flags
                this.isCelebrating = false;
                this.isMiniCelebrating = false;
                this.isConfettiActive = false;
            }
            
            removeAllGameEventListeners() {
                if (this.currentClickHandler) {
                    document.getElementById('game-canvas')?.removeEventListener('click', this.currentClickHandler);
                    this.currentClickHandler = null;
                }
                
                if (this.currentKeyHandlers) {
                    if (this.currentKeyHandlers.keydown) {
                        document.removeEventListener('keydown', this.currentKeyHandlers.keydown);
                    }
                    if (this.currentKeyHandlers.keyup) {
                        document.removeEventListener('keyup', this.currentKeyHandlers.keyup);
                    }
                    this.currentKeyHandlers = null;
                }
            }
            
            startGame(gameType) {
                // Clean up any previous game
                this.cleanupGameResources();
                
                // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ•ŸÜŸáÿßÿ° ÿßŸÑÿ™ŸÖÿßÿ±ŸäŸÜ
                const currentLetter = LETTERS[this.currentLetterIndex];
                this.updateLetterExerciseProgress(currentLetter);
                const entry = this.ensureLetterRecord(currentLetter);
                const exercisesReady = entry.exercisesCompleted === true || this.areExercisesCompleted();

                if (!exercisesReady) {
                    this.showToast('ÿπÿ∞ÿ±ÿßŸãÿå Ÿäÿ¨ÿ® ÿ•ŸÉŸÖÿßŸÑ ÿ™ŸÖÿßÿ±ŸäŸÜ ÿßŸÑÿ≠ÿ±ŸÅ (ÿßŸÑŸÉÿ™ÿßÿ®ÿ©ÿå ÿßŸÑŸÉŸÑŸÖÿßÿ™ÿå ÿßŸÑÿßÿÆÿ™ÿ®ÿßÿ±) ŸÇÿ®ŸÑ ÿßŸÑŸÑÿπÿ®!');
                    return;
                }

                this.gameRunning = true;
                this.motivationModal.style.display = 'none';
                this.gameModal.style.display = 'flex';
                this.currentGame = gameType;
                this.gameTimeLeft = 60; // Increased time for better gameplay
                this.gameTimerEl.textContent = this.gameTimeLeft;
                this.gameScoreEl.textContent = '0';
                
                this.gameStats = {
                    successCount: 0,
                    totalAttempts: 0,
                    accuracy: 0,
                    difficulty: Math.floor(this.completedLetters.length / 5) + 1,
                    gameWins: 0
                };
                
                this.updateGameStats();
                this.setupGameControls();
                
                // Add resize listener
                this.resizeHandler = this.handleResize.bind(this);
                window.addEventListener('resize', this.resizeHandler);
                
                const instructions = {
                    'carRace': 'üèéÔ∏è ÿ™ÿ≠ŸÉŸÖ ŸÅŸä ÿßŸÑÿ≥Ÿäÿßÿ±ÿ© ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ£ÿ≥ŸáŸÖ ÿ£Ÿà ÿßŸÑŸÑŸÖÿ≥. ÿßÿ¨ŸÖÿπ ÿßŸÑÿ≠ÿ±ŸàŸÅ ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© (A Ÿà a) Ÿàÿ™ÿ¨ŸÜÿ® ÿßŸÑÿ≠ÿ±ŸàŸÅ ÿßŸÑÿÆÿßÿ∑ÿ¶ÿ©!',
                    'racket': 'üéæ ÿ≠ÿ±ŸÉ ÿßŸÑŸÖÿ∂ÿ±ÿ® ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ£ÿ≥ŸáŸÖ Ÿàÿßÿ±ÿ™ÿØ ÿßŸÑŸÉÿ±ÿ© ÿπŸÜÿØŸÖÿß ÿ™ÿ≠ŸÖŸÑ ÿßŸÑÿ≠ÿ±ŸÅ ÿßŸÑÿµÿ≠Ÿäÿ≠ Aa!',
                    'shooting': 'üéØ ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ£ÿ≥ŸáŸÖ ŸÑÿ™ÿ≠ÿ±ŸäŸÉ ÿßŸÑŸÖÿØŸÅÿπ ŸàŸÖÿ≥ÿßŸÅÿ© ŸÑŸÑÿ±ŸÖŸä. ÿßÿµÿ∑ÿØ ÿßŸÑÿ£ÿ≥ŸÖÿßŸÉ ÿßŸÑÿ™Ÿä ÿ™ÿ≠ŸÖŸÑ ÿßŸÑÿ≠ÿ±ŸÅ A ÿ£Ÿà a!',
                    'balloons': 'üéà ÿßÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ ÿßŸÑÿ®ÿßŸÑŸàŸÜÿßÿ™ ÿßŸÑÿ™Ÿä ÿ™ÿ≠ŸÖŸÑ ÿßŸÑÿ≠ÿ±ŸÅ A ÿ£Ÿà a Ÿàÿ™ÿ¨ŸÜÿ® ÿßŸÑÿ®ÿßŸÑŸàŸÜÿßÿ™ ÿßŸÑÿ£ÿÆÿ±Ÿâ!',
                    'memory': 'üß† ÿßÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑÿ®ÿ∑ÿßŸÇÿßÿ™ ÿßŸÑŸÖÿ™ÿ∑ÿßÿ®ŸÇÿ© ÿßŸÑÿ™Ÿä ÿ™ÿ≠ŸÖŸÑ ÿßŸÑÿ≠ÿ±ŸÅ A Ÿà a!',
                    'wordsearch': 'üîç ÿßÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿßŸÑÿ™Ÿä ÿ™ÿ®ÿØÿ£ ÿ®ÿßŸÑÿ≠ÿ±ŸÅ A ŸÅŸä ÿßŸÑÿ¥ÿ®ŸÉÿ©!',
                    'typing': '‚å®Ô∏è ÿßŸÉÿ™ÿ® ÿßŸÑÿ≠ÿ±ŸÅ A ÿ£Ÿà a ÿßŸÑÿ∞Ÿä Ÿäÿ∏Ÿáÿ± ÿ®ÿ≥ÿ±ÿπÿ© ŸÇÿ®ŸÑ ŸÜŸÅÿßÿØ ÿßŸÑŸàŸÇÿ™!',
                    'match': 'üî§ ÿßÿ≥ÿ≠ÿ® ÿßŸÑÿ≠ÿ±ŸÅ A ÿ£Ÿà a ÿ•ŸÑŸâ ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿßŸÑŸÖŸÜÿßÿ≥ÿ®ÿ© ÿßŸÑÿ™Ÿä ÿ™ÿ®ÿØÿ£ ÿ®Ÿáÿß!'
                };
                
                this.gameInstructions.textContent = instructions[gameType] || 'ÿßÿ≥ÿ™ŸÖÿ™ÿπ ÿ®ÿßŸÑŸÑÿπÿ®ÿ©!';
                this.gameTitle.textContent = `üéÆ ${this.getGameName(gameType)} - ÿßŸÑÿ≠ÿ±ŸÅ ${LETTERS[this.currentLetterIndex]}`;
                
                this.initGame(gameType);
                
                this.gameInterval = setInterval(() => {
                    if (!this.isPaused) {
                        this.gameTimeLeft--;
                        this.gameTimerEl.textContent = this.gameTimeLeft;
                        
                        if (this.gameTimeLeft <= 0) {
                            if (this.currentGame === 'carRace' || this.currentGame === 'shooting') {
                                this.showWinGame();
                            } else {
                                this.endGame();
                            }
                        }
                    }
                }, 1000);
            }
            
            getGameName(gameType) {
                const names = {
                    'carRace': 'ÿ≥ÿ®ÿßŸÇ ÿßŸÑÿ≥Ÿäÿßÿ±ÿßÿ™',
                    'racket': 'ŸÑÿπÿ®ÿ© ÿßŸÑŸÖÿ∂ÿ±ÿ®',
                    'shooting': 'ÿßÿµÿ∑ŸäÿßÿØ ÿßŸÑÿ≠ÿ±ŸÅ',
                    'balloons': 'ŸÑÿπÿ®ÿ© ÿßŸÑÿ®ÿßŸÑŸàŸÜÿßÿ™',
                    'memory': 'ŸÑÿπÿ®ÿ© ÿßŸÑÿ∞ÿßŸÉÿ±ÿ©',
                    'wordsearch': 'ŸÑÿπÿ®ÿ© ÿßŸÑÿ®ÿ≠ÿ´',
                    'typing': 'ÿßŸÑŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿ≥ÿ±Ÿäÿπÿ©',
                    'match': 'ŸÑÿπÿ®ÿ© ÿßŸÑŸÖÿ∑ÿßÿ®ŸÇÿ©'
                };
                return names[gameType] || 'ŸÑÿπÿ®ÿ©';
            }
            
            setupGameControls() {
                if (this.currentGame === 'carRace' || this.currentGame === 'racket' || this.currentGame === 'shooting') {
                    this.touchControlsEl.style.display = 'flex';
                } else {
                    this.touchControlsEl.style.display = 'none';
                }
            }
            
            updateGameStats() {
                this.successCountEl.textContent = this.gameStats.successCount;
                this.difficultyLevelEl.textContent = this.gameStats.difficulty;
                
                if (this.gameStats.totalAttempts > 0) {
                    this.gameStats.accuracy = Math.round((this.gameStats.successCount / this.gameStats.totalAttempts) * 100);
                } else {
                    this.gameStats.accuracy = 0;
                }
                
                this.accuracyEl.textContent = `${this.gameStats.accuracy}%`;
            }
            
            handleResize() {
                if (this.gameCanvas && this.gameCanvas.parentElement) {
                    const container = this.gameCanvas.parentElement;
                    this.gameCanvas.width = container.clientWidth;
                    this.gameCanvas.height = container.clientHeight;
                }

                // Add mobile class for CSS targeting
                if (window.innerWidth <= 900) {
                    document.body.classList.add('mobile-view');
                } else {
                    document.body.classList.remove('mobile-view');
                }
            }
            
            initGame(gameType) {
                const canvas = this.gameCanvas;
                const ctx = canvas.getContext('2d');
                
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                
                if (this.gameAnimationFrame) {
                    cancelAnimationFrame(this.gameAnimationFrame);
                }
                
                this.gameObjects = [];
                
                switch(gameType) {
                    case 'carRace':
                        this.initCarRaceGame(ctx, canvas);
                        break;
                    case 'racket':
                        this.initRacketGame(ctx, canvas);
                        break;
                    case 'shooting':
                        this.initShootingGame(ctx, canvas);
                        break;
                    case 'balloons':
                        this.initBalloonsGame(ctx, canvas);
                        break;
                    case 'memory':
                        this.initMemoryGame(ctx, canvas);
                        break;
                    case 'wordsearch':
                        this.initWordSearchGame(ctx, canvas);
                        break;
                    case 'typing':
                        this.initTypingGame(ctx, canvas);
                        break;
                    case 'match':
                        this.initMatchGame(ctx, canvas);
                        break;
                    default:
                        this.initDefaultGame(ctx, canvas);
                }
            }
            
            initCarRaceGame(ctx, canvas) {
                const currentLetter = LETTERS[this.currentLetterIndex];
                const app = this;
                
                // ÿ•ÿ∏Ÿáÿßÿ± ÿ£ÿ≤ÿ±ÿßÿ± ÿßŸÑÿ™ÿ≠ŸÉŸÖ ÿ®ÿßŸÑŸÑŸÖÿ≥ ÿØÿßÿ¶ŸÖÿßŸã ŸÑŸÑÿ£ŸÑÿπÿßÿ® ÿßŸÑÿ™Ÿä ÿ™ÿ™ÿ∑ŸÑÿ® ÿ™ÿ≠ŸÉŸÖ
                this.touchControlsEl.style.display = 'flex';
                canvas.style.touchAction = 'none'; // Prevent scrolling

                // ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÑÿπÿ®ÿ©
                const gameDuration = 60; // 60 ÿ´ÿßŸÜŸäÿ©
                let timeLeft = gameDuration;
                let lastTime = Date.now();
                
                // ÿßŸÑÿ≥Ÿäÿßÿ±ÿ©
                const car = {
                    x: canvas.width / 2 - 35,
                    y: canvas.height - 120,
                    width: 70,
                    height: 110,
                    speed: 7, // ÿ≤ŸäÿßÿØÿ© ÿßŸÑÿ≥ÿ±ÿπÿ© ŸÇŸÑŸäŸÑÿßŸã
                    emoji: 'üèéÔ∏è',
                    draw: function() {
                        ctx.font = '90px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(this.emoji, this.x + this.width/2, this.y + this.height/2);
                    },
                    move: function(direction) {
                        if (direction === 'left' && this.x > 0) {
                            this.x -= this.speed;
                        }
                        if (direction === 'right' && this.x < canvas.width - this.width) {
                            this.x += this.speed;
                        }
                    }
                };

                // Touch Control for Car
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const rect = canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const touchX = touch.clientX - rect.left;
                    
                    car.x = touchX - car.width / 2;
                    
                    if (car.x < 0) car.x = 0;
                    if (car.x > canvas.width - car.width) car.x = canvas.width - car.width;
                }, { passive: false });
                
                // ÿßŸÑÿπŸÜÿßÿµÿ± ÿßŸÑŸÖÿ™ÿ≥ÿßŸÇÿ∑ÿ© (ÿ≠ÿ±ŸàŸÅ ŸàÿπŸàÿßÿ¶ŸÇ)
                const items = [];
                const allLetters = LETTERS.filter(l => l !== currentLetter);
                const obstacles = ['ü™®', 'üöß', 'üõ¢Ô∏è', 'ü™µ'];
                
                // ÿ•ÿ∂ÿßŸÅÿ© ÿπŸÜÿµÿ± ÿ¨ÿØŸäÿØ
                const spawnItem = () => {
                    const type = Math.random();
                    let item = {
                        x: Math.random() * (canvas.width - 40),
                        y: -50,
                        width: 40,
                        height: 40,
                        speed: 3 + Math.random() * 3,
                        isCollected: false
                    };

                    if (type < 0.3) { // 30% ÿπŸàÿßÿ¶ŸÇ
                        item.type = 'obstacle';
                        item.content = obstacles[Math.floor(Math.random() * obstacles.length)];
                    } else { // 70% ÿ≠ÿ±ŸàŸÅ
                        item.type = 'letter';
                        const isCorrect = Math.random() > 0.4; // 60% ÿ≠ÿ±ŸàŸÅ ÿµÿ≠Ÿäÿ≠ÿ© ŸÑÿ™ÿ¥ÿ¨Ÿäÿπ ÿßŸÑÿ∑ŸÅŸÑ
                        if (isCorrect) {
                            item.content = Math.random() > 0.5 ? currentLetter : currentLetter.toLowerCase();
                            item.isCorrect = true;
                        } else {
                            item.content = Math.random() > 0.5 ? 
                                allLetters[Math.floor(Math.random() * allLetters.length)] : 
                                allLetters[Math.floor(Math.random() * allLetters.length)].toLowerCase();
                            item.isCorrect = false;
                        }
                    }
                    items.push(item);
                };
                
                // Explosion Effect
                const explosions = [];
                const createExplosion = (x, y, color) => {
                    for (let i = 0; i < 15; i++) {
                        explosions.push({
                            x: x,
                            y: y,
                            vx: (Math.random() - 0.5) * 15,
                            vy: (Math.random() - 0.5) * 15,
                            life: 1.0,
                            color: color,
                            size: Math.random() * 5 + 2
                        });
                    }
                };

                // ÿ≠ŸÑŸÇÿ© ÿßŸÑŸÑÿπÿ®ÿ©
                const gameLoop = () => {
                    if (!app.gameRunning) return;
                    
                    if (app.isPaused) {
                        this.gameAnimationFrame = requestAnimationFrame(gameLoop);
                        return;
                    }

                    // ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸàŸÇÿ™
                    const now = Date.now();
                    if (now - lastTime >= 1000) {
                        timeLeft--;
                        lastTime = now;
                        app.gameTimerEl.textContent = timeLeft; // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿπÿØÿßÿØ ŸÅŸä ÿßŸÑŸàÿßÿ¨Ÿáÿ©
                    }

                    if (timeLeft <= 0) {
                        app.showWinGame(); // ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑŸàŸÇÿ™ = ŸÅŸàÿ≤ ÿ•ÿ∞ÿß ÿµŸÖÿØ
                        return;
                    }

                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // ÿ±ÿ≥ŸÖ ÿßŸÑÿ∑ÿ±ŸäŸÇ
                    ctx.fillStyle = '#334155';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // ÿÆÿ∑Ÿàÿ∑ ÿßŸÑÿ∑ÿ±ŸäŸÇ
                    ctx.fillStyle = '#f8fafc';
                    ctx.setLineDash([20, 20]);
                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2, 0);
                    ctx.lineTo(canvas.width / 2, canvas.height);
                    ctx.lineWidth = 4;
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // ÿ™ÿ≠ÿ±ŸäŸÉ ÿßŸÑÿ≥Ÿäÿßÿ±ÿ©
                    if (this.touchControls.left) car.move('left');
                    if (this.touchControls.right) car.move('right');
                    
                    // Ensure car stays within bounds (for resize)
                    if (car.x > canvas.width - car.width) car.x = canvas.width - car.width;
                    
                    car.draw();

                    // ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿπŸÜÿßÿµÿ±
                    if (Math.random() < 0.08) spawnItem(); // Increased spawn rate (was 0.05)

                    for (let i = items.length - 1; i >= 0; i--) {
                        let item = items[i];
                        item.y += item.speed;

                        // ÿ±ÿ≥ŸÖ ÿßŸÑÿπŸÜÿµÿ±
                        ctx.font = '30px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        if (item.type === 'letter') {
                            // ÿ±ÿ≥ŸÖ ÿÆŸÑŸÅŸäÿ© ŸÑŸÑÿ≠ÿ±ŸÅ
                            ctx.fillStyle = item.isCorrect ? '#4ade80' : '#f87171';
                            ctx.beginPath();
                            ctx.arc(item.x + item.width/2, item.y + item.height/2, 20, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.fillStyle = '#ffffff';
                            ctx.fillText(item.content, item.x + item.width/2, item.y + item.height/2);
                        } else {
                            ctx.fillText(item.content, item.x + item.width/2, item.y + item.height/2);
                        }

                        // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ™ÿµÿßÿØŸÖ
                        if (!item.isCollected && 
                            item.y + item.height > car.y &&
                            item.y < car.y + car.height &&
                            item.x + item.width > car.x &&
                            item.x < car.x + car.width) {
                            
                            item.isCollected = true;
                            
                            // Explosion Effect
                            createExplosion(item.x + item.width/2, item.y + item.height/2, item.type === 'obstacle' ? '#ef4444' : '#fbbf24');

                            if (item.type === 'obstacle') {
                                app.soundManager.playSound('error');
                                app.gameScoreEl.textContent = Math.max(0, parseInt(app.gameScoreEl.textContent) - 5);
                                // ÿ™ÿ£ÿ´Ÿäÿ± ÿßŸáÿ™ÿ≤ÿßÿ≤ ÿ£Ÿà ŸàŸÖŸäÿ∂ ŸäŸÖŸÉŸÜ ÿ•ÿ∂ÿßŸÅÿ™Ÿá ŸáŸÜÿß
                                canvas.style.transform = 'translateX(5px)';
                                setTimeout(() => canvas.style.transform = 'none', 100);
                            } else if (item.type === 'letter') {
                                if (item.isCorrect) {
                                    app.soundManager.playSound('success');
                                    app.gameScoreEl.textContent = parseInt(app.gameScoreEl.textContent) + 10;
                                    app.gameStats.successCount++;
                                } else {
                                    app.soundManager.playSound('error');
                                    app.gameScoreEl.textContent = Math.max(0, parseInt(app.gameScoreEl.textContent) - 5);
                                }
                                app.gameStats.totalAttempts++;
                                app.updateGameStats();
                            }
                            
                            items.splice(i, 1);
                            continue;
                        }

                        // ÿ≠ÿ∞ŸÅ ÿßŸÑÿπŸÜÿßÿµÿ± ÿÆÿßÿ±ÿ¨ ÿßŸÑÿ¥ÿßÿ¥ÿ©
                        if (item.y > canvas.height) {
                            items.splice(i, 1);
                        }
                    }

                    // Update and draw explosions
                    for (let i = explosions.length - 1; i >= 0; i--) {
                        let p = explosions[i];
                        p.x += p.vx;
                        p.y += p.vy;
                        p.life -= 0.05;
                        
                        if (p.life <= 0) {
                            explosions.splice(i, 1);
                        } else {
                            ctx.globalAlpha = p.life;
                            ctx.fillStyle = p.color;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, p.size || 3, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1.0;
                        }
                    }
                    
                    this.gameAnimationFrame = requestAnimationFrame(gameLoop);
                };
                
                gameLoop();
                
                const keyHandler = (e) => {
                    if (e.key === 'ArrowLeft') this.touchControls.left = true;
                    if (e.key === 'ArrowRight') this.touchControls.right = true;
                };
                
                const keyUpHandler = (e) => {
                    if (e.key === 'ArrowLeft') this.touchControls.left = false;
                    if (e.key === 'ArrowRight') this.touchControls.right = false;
                };
                
                document.addEventListener('keydown', keyHandler);
                document.addEventListener('keyup', keyUpHandler);
                
                this.currentKeyHandlers = { keydown: keyHandler, keyup: keyUpHandler };
            }
            
            initRacketGame(ctx, canvas) {
                const currentLetter = LETTERS[this.currentLetterIndex];
                const app = this;
                
                // ÿ•ÿ∏Ÿáÿßÿ± ÿ£ÿ≤ÿ±ÿßÿ± ÿßŸÑÿ™ÿ≠ŸÉŸÖ ÿ®ÿßŸÑŸÑŸÖÿ≥
                this.touchControlsEl.style.display = 'flex';
                canvas.style.touchAction = 'none';

                const racket = {
                    x: canvas.width / 2 - 50,
                    y: canvas.height - 30,
                    width: 100,
                    height: 20,
                    speed: 12, // Increased speed for better button response
                    color: '#f72585',
                    draw: function() {
                        ctx.fillStyle = this.color;
                        ctx.fillRect(this.x, this.y, this.width, this.height);
                        ctx.fillStyle = '#4cc9f0';
                        ctx.fillRect(this.x + 10, this.y + 5, this.width - 20, 10);
                    },
                    move: function(direction) {
                        if (direction === 'left' && this.x > 0) {
                            this.x -= this.speed;
                        }
                        if (direction === 'right' && this.x < canvas.width - this.width) {
                            this.x += this.speed;
                        }
                    },
                    updatePosition: function() {
                        // Update Y position in case of resize
                        this.y = canvas.height - 30;
                        // Ensure X is within bounds
                        if (this.x > canvas.width - this.width) {
                            this.x = canvas.width - this.width;
                        }
                    }
                };
                
                // Touch Control for Racket
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const rect = canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const touchX = touch.clientX - rect.left;
                    
                    // Center racket on touch
                    racket.x = touchX - racket.width / 2;
                    
                    // Bounds check
                    if (racket.x < 0) racket.x = 0;
                    if (racket.x > canvas.width - racket.width) racket.x = canvas.width - racket.width;
                }, { passive: false });
                
                let drops = 0; // Counter for dropped balls

                const ball = {
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    radius: 25, // Increased size
                    speedX: 4, // Start slightly faster
                    speedY: 4, // Start slightly faster
                    letter: `${currentLetter}${currentLetter.toLowerCase()}`,
                    color: '#4361ee',
                    draw: function() {
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 20px Arial'; // Increased font size
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(this.letter, this.x, this.y);
                    },
                    update: function() {
                        this.x += this.speedX;
                        this.y += this.speedY;
                        
                        if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
                            this.speedX = -this.speedX;
                            // Keep ball inside
                            if (this.x - this.radius < 0) this.x = this.radius;
                            if (this.x + this.radius > canvas.width) this.x = canvas.width - this.radius;
                        }
                        if (this.y - this.radius < 0) {
                            this.speedY = -this.speedY;
                            this.y = this.radius;
                        }
                        
                        if (this.y + this.radius > racket.y &&
                            this.y - this.radius < racket.y + racket.height &&
                            this.x + this.radius > racket.x &&
                            this.x - this.radius < racket.x + racket.width) {
                            
                            // Increase speed progressively on hit
                            const speedMultiplier = 1.1;
                            this.speedY = -Math.abs(this.speedY) * speedMultiplier;
                            this.speedX = this.speedX * speedMultiplier;
                            
                            // Cap max speed
                            const maxSpeed = 15;
                            if (Math.abs(this.speedY) > maxSpeed) this.speedY = maxSpeed * Math.sign(this.speedY);
                            if (Math.abs(this.speedX) > maxSpeed) this.speedX = maxSpeed * Math.sign(this.speedX);

                            const isCorrect = this.letter.includes(currentLetter) || this.letter.includes(currentLetter.toLowerCase());
                            
                            if (isCorrect) {
                                app.gameStats.successCount++;
                                app.gameStats.totalAttempts++;
                                app.gameScoreEl.textContent = parseInt(app.gameScoreEl.textContent) + 5;
                                app.soundManager.playSound('success');

                                // Win condition: 10 returns
                                if (app.gameStats.successCount >= 10) {
                                    app.showWinGame();
                                    return;
                                }
                            } else {
                                app.gameStats.totalAttempts++;
                                app.soundManager.playSound('error');
                            }
                            
                            this.letter = Math.random() > 0.5 ? 
                                `${currentLetter}${currentLetter.toLowerCase()}` : 
                                `${LETTERS[Math.floor(Math.random() * LETTERS.length)]}${LETTERS[Math.floor(Math.random() * LETTERS.length)].toLowerCase()}`;
                            this.color = isCorrect ? '#4ade80' : '#ef4444';
                            
                            app.updateGameStats();
                        }
                        
                        if (this.y - this.radius > canvas.height) {
                            drops++;
                            if (drops >= 3) {
                                app.endGame(); // Lose condition
                                return;
                            }

                            this.x = canvas.width / 2;
                            this.y = canvas.height / 2;
                            // Reset speed on drop, but keep it challenging
                            this.speedX = 4 * (Math.random() > 0.5 ? 1 : -1);
                            this.speedY = 4;
                            app.gameStats.totalAttempts++;
                            app.updateGameStats();
                            app.soundManager.playSound('error');
                            app.showToast(`‚ö†Ô∏è ÿßŸÜÿ™ÿ®Ÿá! ÿ≥ŸÇÿ∑ÿ™ ÿßŸÑŸÉÿ±ÿ© ${drops}/3 ŸÖÿ±ÿßÿ™`, 2000);
                        }
                    }
                };
                
                const gameLoop = () => {
                    if (!app.gameRunning) return; // Stop loop if game not running
                    
                    if (app.isPaused) {
                        this.gameAnimationFrame = requestAnimationFrame(gameLoop);
                        return;
                    }

                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#1e293b';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.strokeStyle = '#475569';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10, 10]);
                    ctx.beginPath();
                    ctx.moveTo(canvas.width/2, 0);
                    ctx.lineTo(canvas.width/2, canvas.height);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Update racket position for resize
                    racket.updatePosition();

                    if (this.touchControls.left) racket.move('left');
                    if (this.touchControls.right) racket.move('right');
                    
                    // Ensure racket stays within bounds
                    if (racket.x > canvas.width - racket.width) racket.x = canvas.width - racket.width;
                    
                    ball.update();
                    ball.draw();
                    
                    racket.draw();
                    
                    this.gameAnimationFrame = requestAnimationFrame(gameLoop);
                };
                
                gameLoop();
                
                const keyHandler = (e) => {
                    if (e.key === 'ArrowLeft') this.touchControls.left = true;
                    if (e.key === 'ArrowRight') this.touchControls.right = true;
                };
                
                const keyUpHandler = (e) => {
                    if (e.key === 'ArrowLeft') this.touchControls.left = false;
                    if (e.key === 'ArrowRight') this.touchControls.right = false;
                };
                
                document.addEventListener('keydown', keyHandler);
                document.addEventListener('keyup', keyUpHandler);
                
                this.currentKeyHandlers = { keydown: keyHandler, keyup: keyUpHandler };
            }
            
            initShootingGame(ctx, canvas) {
                const currentLetter = LETTERS[this.currentLetterIndex];
                const app = this;

                // ÿ•ÿ∏Ÿáÿßÿ± ÿ£ÿ≤ÿ±ÿßÿ± ÿßŸÑÿ™ÿ≠ŸÉŸÖ ÿ®ÿßŸÑŸÑŸÖÿ≥ ÿØÿßÿ¶ŸÖÿßŸã
                this.touchControlsEl.style.display = 'flex';
                canvas.style.touchAction = 'none'; // Prevent scrolling
                
                const cannon = {
                    x: canvas.width / 2,
                    y: canvas.height - 50,
                    width: 60,
                    height: 30,
                    draw: function() {
                        ctx.save();
                        ctx.translate(this.x, this.y);
                        
                        ctx.fillStyle = '#8b5a2b';
                        ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                        
                        ctx.fillStyle = '#1e293b';
                        ctx.fillRect(-5, -this.height/2 - 10, 10, 10); // Nozzle pointing up
                        
                        ctx.restore();
                    },
                    update: function() {
                        if (app.touchControls.left && this.x > this.width/2) this.x -= 5;
                        if (app.touchControls.right && this.x < canvas.width - this.width/2) this.x += 5;
                    }
                };
                
                const bullets = [];
                const fishes = [];
                
                // Increased fish count to 20 for density
                for (let i = 0; i < 20; i++) {
                    // Increased probability to 70% for correct letter
                    const isCorrect = Math.random() > 0.3;
                    const letter = isCorrect ? 
                        (Math.random() > 0.5 ? currentLetter : currentLetter.toLowerCase()) : 
                        LETTERS[Math.floor(Math.random() * LETTERS.length)];
                    
                    fishes.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * (canvas.height - 200),
                        width: 70, // Increased width
                        height: 35, // Increased height
                        speedX: (Math.random() - 0.5) * 2,
                        speedY: (Math.random() - 0.5) * 1,
                        letter: letter,
                        isCorrect: isCorrect || letter.toLowerCase() === currentLetter.toLowerCase(),
                        color: isCorrect ? '#4cc9f0' : '#ef4444',
                        draw: function() {
                            ctx.fillStyle = this.color;
                            ctx.beginPath();
                            ctx.ellipse(this.x, this.y, this.width/2, this.height/2, 0, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.beginPath();
                            ctx.moveTo(this.x - this.width/2, this.y);
                            ctx.lineTo(this.x - this.width, this.y - this.height/2);
                            ctx.lineTo(this.x - this.width, this.y + this.height/2);
                            ctx.closePath();
                            ctx.fill();
                            
                            ctx.fillStyle = 'white';
                            ctx.beginPath();
                            ctx.arc(this.x + this.width/3, this.y - 3, 3, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.fillStyle = 'white';
                            ctx.font = 'bold 28px Arial'; // Increased font size significantly
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(this.letter, this.x + this.width/4, this.y);
                        },
                        update: function() {
                            this.x += this.speedX;
                            this.y += this.speedY;
                            
                            if (this.x < this.width/2 || this.x > canvas.width - this.width/2) {
                                this.speedX = -this.speedX;
                            }
                            if (this.y < 20 || this.y > canvas.height - 100) {
                                this.speedY = -this.speedY;
                            }
                        }
                    });
                }
                
                const shoot = () => {
                    const bullet = {
                        x: cannon.x,
                        y: cannon.y - cannon.height/2 - 10,
                        radius: 5,
                        speed: 8,
                        color: '‚≠ê',
                        draw: function() {
                            ctx.fillStyle = '#f59e0b';
                            ctx.font = '24px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(this.color, this.x, this.y);
                        },
                        update: function() {
                            this.y -= this.speed; // Move straight up
                            
                            for (let i = fishes.length - 1; i >= 0; i--) {
                                const fish = fishes[i];
                                const dx = this.x - fish.x;
                                const dy = this.y - fish.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (distance < fish.width/2 + this.radius) {
                                    if (fish.isCorrect) {
                                        app.gameStats.successCount++;
                                        app.gameStats.totalAttempts++;
                                        app.gameScoreEl.textContent = parseInt(app.gameScoreEl.textContent) + 10;
                                        app.soundManager.playSound('success');
                                        
                                        // Win condition: 15 correct hits
                                        if (app.gameStats.successCount >= 15) {
                                            app.showWinGame();
                                            return;
                                        }
                                    } else {
                                        app.gameStats.totalAttempts++;
                                        app.gameScoreEl.textContent = Math.max(0, parseInt(app.gameScoreEl.textContent) - 5);
                                        app.soundManager.playSound('error');
                                    }
                                    
                                    fishes.splice(i, 1);
                                    bullets.splice(bullets.indexOf(this), 1);
                                    
                                    // Respawn logic with high probability for correct letter
                                    const isCorrect = Math.random() > 0.3;
                                    const letter = isCorrect ? 
                                        (Math.random() > 0.5 ? currentLetter : currentLetter.toLowerCase()) : 
                                        LETTERS[Math.floor(Math.random() * LETTERS.length)];
                                    
                                    fishes.push({
                                        x: Math.random() * canvas.width,
                                        y: Math.random() * (canvas.height - 200),
                                        width: 70, // Increased width
                                        height: 35, // Increased height
                                        speedX: (Math.random() - 0.5) * 2,
                                        speedY: (Math.random() - 0.5) * 1,
                                        letter: letter,
                                        isCorrect: isCorrect || letter.toLowerCase() === currentLetter.toLowerCase(),
                                        color: isCorrect ? '#4cc9f0' : '#ef4444',
                                        draw: function() {
                                            ctx.fillStyle = this.color;
                                            ctx.beginPath();
                                            ctx.ellipse(this.x, this.y, this.width/2, this.height/2, 0, 0, Math.PI * 2);
                                            ctx.fill();
                                            
                                            ctx.beginPath();
                                            ctx.moveTo(this.x - this.width/2, this.y);
                                            ctx.lineTo(this.x - this.width, this.y - this.height/2);
                                            ctx.lineTo(this.x - this.width, this.y + this.height/2);
                                            ctx.closePath();
                                            ctx.fill();
                                            
                                            ctx.fillStyle = 'white';
                                            ctx.beginPath();
                                            ctx.arc(this.x + this.width/3, this.y - 3, 3, 0, Math.PI * 2);
                                            ctx.fill();
                                            
                                            ctx.fillStyle = 'white';
                                            ctx.font = 'bold 28px Arial'; // Increased font size
                                            ctx.textAlign = 'center';
                                            ctx.textBaseline = 'middle';
                                            ctx.fillText(this.letter, this.x + this.width/4, this.y);
                                        },
                                        update: function() {
                                            this.x += this.speedX;
                                            this.y += this.speedY;
                                            
                                            if (this.x < this.width/2 || this.x > canvas.width - this.width/2) {
                                                this.speedX = -this.speedX;
                                            }
                                            if (this.y < 20 || this.y > canvas.height - 100) {
                                                this.speedY = -this.speedY;
                                            }
                                        }
                                    });
                                    
                                    app.updateGameStats();
                                    return;
                                }
                            }
                            
                            return this.x < -10 || this.x > canvas.width + 10 || this.y < -10;
                        }
                    };
                    
                    bullets.push(bullet);
                    app.soundManager.playSound('click');
                };
                
                // Touch Controls
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const rect = canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    const touchX = touch.clientX - rect.left;
                    
                    cannon.x = touchX;
                    
                    if (cannon.x < cannon.width/2) cannon.x = cannon.width/2;
                    if (cannon.x > canvas.width - cannon.width/2) cannon.x = canvas.width - cannon.width/2;
                }, { passive: false });

                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    // Fire on tap
                    shoot();
                }, { passive: false });

                const gameLoop = () => {
                    if (!app.gameRunning) return;
                    
                    if (app.isPaused) {
                        this.gameAnimationFrame = requestAnimationFrame(gameLoop);
                        return;
                    }

                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Re-center cannon on resize (only Y)
                    cannon.y = canvas.height - 50;
                    
                    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    gradient.addColorStop(0, '#4cc9f0');
                    gradient.addColorStop(1, '#3a0ca3');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    for (let i = 0; i < canvas.width; i += 20) {
                        ctx.beginPath();
                        ctx.arc(i, 50 + Math.sin(Date.now()/1000 + i/50) * 10, 8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    cannon.update();
                    cannon.draw();
                    
                    fishes.forEach(fish => {
                        fish.update();
                        fish.draw();
                    });
                    
                    for (let i = bullets.length - 1; i >= 0; i--) {
                        const bullet = bullets[i];
                        bullet.draw();
                        if (bullet.update()) {
                            bullets.splice(i, 1);
                        }
                    }
                    
                    if (app.touchControls.action) {
                        shoot();
                        app.touchControls.action = false;
                    }
                    
                    this.gameAnimationFrame = requestAnimationFrame(gameLoop);
                };
                
                gameLoop();
                
                const keyHandler = (e) => {
                    if (e.key === 'ArrowLeft') this.touchControls.left = true;
                    if (e.key === 'ArrowRight') this.touchControls.right = true;
                    if (e.key === ' ' || e.key === 'Spacebar') {
                        shoot();
                    }
                };
                
                const keyUpHandler = (e) => {
                    if (e.key === 'ArrowLeft') this.touchControls.left = false;
                    if (e.key === 'ArrowRight') this.touchControls.right = false;
                };
                
                document.addEventListener('keydown', keyHandler);
                document.addEventListener('keyup', keyUpHandler);
                
                this.currentKeyHandlers = { keydown: keyHandler, keyup: keyUpHandler };
            }
            
            initBalloonsGame(ctx, canvas) {
                const currentLetter = LETTERS[this.currentLetterIndex];
                const app = this;
                
                // Responsive configuration
                const isMobile = canvas.width < 600;
                const balloonCount = isMobile ? 15 : 20;
                
                // Timer Setup
                const gameDuration = 60; // 60 seconds
                let timeLeft = gameDuration;
                let lastTime = Date.now();
                
                const balloons = [];
                for (let i = 0; i < balloonCount; i++) {
                    this.addNewBalloon(balloons, canvas, currentLetter);
                }
                
                const clickHandler = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Iterate backwards to handle overlapping balloons (top one first)
                    for (let i = balloons.length - 1; i >= 0; i--) {
                        if (balloons[i].checkClick(mouseX, mouseY)) {
                            break; // Stop after clicking one balloon
                        }
                    }
                };
                
                canvas.addEventListener('click', clickHandler);
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const rect = canvas.getBoundingClientRect();
                    // Use changedTouches for better touch handling
                    const touch = e.changedTouches[0] || e.touches[0];
                    const mouseX = touch.clientX - rect.left;
                    const mouseY = touch.clientY - rect.top;
                    
                    for (let i = balloons.length - 1; i >= 0; i--) {
                        if (balloons[i].checkClick(mouseX, mouseY)) {
                            break;
                        }
                    }
                }, { passive: false });

                this.currentClickHandler = clickHandler;
                
                const gameLoop = () => {
                    if (!this.gameRunning || this.isGameEnding) {
                        return;
                    }
                    
                    if (this.isPaused) {
                        this.gameAnimationFrame = requestAnimationFrame(gameLoop);
                        return;
                    }
                    
                    try {
                        // Timer Logic
                        const now = Date.now();
                        if (now - lastTime >= 1000) {
                            timeLeft--;
                            lastTime = now;
                            app.gameTimerEl.textContent = timeLeft;
                        }

                        if (timeLeft <= 0) {
                            app.showWinGame();
                            app.showToast('üéâ ÿßŸÜÿ™ŸáŸâ ÿßŸÑŸàŸÇÿ™! ÿ£ÿ≠ÿ≥ŸÜÿ™!', 3000, 'success');
                            return;
                        }

                        // Apply FPS limiting
                        const perfNow = performance.now();
                        const deltaTime = perfNow - this.lastFrameTime;
                        
                        if (deltaTime >= this.frameInterval) {
                            this.lastFrameTime = perfNow - (deltaTime % this.frameInterval);
                            
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            
                            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                            gradient.addColorStop(0, '#4cc9f0');
                            gradient.addColorStop(1, '#4895ef');
                            ctx.fillStyle = gradient;
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            
                            // Reduced cloud animation frequency for performance
                            if (Math.floor(perfNow / 200) % 2 === 0) {
                                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                                for (let i = 0; i < 2; i++) {
                                    const x = (perfNow/1000 * 15 + i * 120) % (canvas.width + 200) - 100;
                                    ctx.beginPath();
                                    ctx.arc(x, 100 + i * 40, 30, 0, Math.PI * 2);
                                    ctx.arc(x + 25, 90 + i * 40, 25, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }
                            
                            // Update and draw balloons efficiently
                            for (let i = balloons.length - 1; i >= 0; i--) {
                                if (this.gameRunning && !this.isGameEnding) {
                                    const balloon = balloons[i];
                                    balloon.update();
                                    balloon.draw();
                                }
                            }
                        }
                        
                        if (this.gameRunning && !this.isGameEnding) {
                            this.gameAnimationFrame = requestAnimationFrame(gameLoop);
                        }
                    } catch (error) {
                        console.error('Error in balloon game loop:', error);
                        this.gameRunning = false;
                    }
                };
                
                gameLoop();
            }
            
            addNewBalloon(balloons, canvas, currentLetter) {
                const isCorrect = Math.random() > 0.2;
                const letter = isCorrect ? 
                    (Math.random() > 0.5 ? currentLetter : currentLetter.toLowerCase()) : 
                    LETTERS[Math.floor(Math.random() * LETTERS.length)];
                const colors = ['#f72585', '#4361ee', '#4cc9f0', '#4ade80', '#f59e0b'];
                
                const app = this; // Capture this context
                
                // Responsive size
                const isMobile = canvas.width < 600;
                const baseRadius = isMobile ? 35 : 25;

                balloons.push({
                    x: Math.random() * canvas.width,
                    y: canvas.height + Math.random() * 100,
                    radius: baseRadius + Math.random() * 20,
                    speed: 2 + Math.random() * 3,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    letter: letter,
                    isCorrect: isCorrect || letter.toLowerCase() === currentLetter.toLowerCase(),
                    popped: false,
                    popTime: 0,
                    draw: function() {
                        // Same draw function as before
                        const ctx = canvas.getContext('2d');
                        if (this.popped) {
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                            for (let i = 0; i < 8; i++) {
                                const angle = (i / 8) * Math.PI * 2;
                                const distance = this.radius * 1.5;
                                ctx.beginPath();
                                ctx.arc(
                                    this.x + Math.cos(angle) * distance,
                                    this.y + Math.sin(angle) * distance,
                                    5,
                                    0,
                                    Math.PI * 2
                                );
                                ctx.fill();
                            }
                            return;
                        }
                        
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.strokeStyle = this.color;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y + this.radius);
                        ctx.lineTo(this.x, this.y + this.radius + 30);
                        ctx.stroke();
                        
                        ctx.fillStyle = 'white';
                        ctx.font = `bold ${Math.floor(this.radius * 0.8)}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(this.letter, this.x, this.y);
                    },
                    update: function() {
                        if (this.popped) {
                            this.popTime++;
                            if (this.popTime > 30) {
                                const index = balloons.indexOf(this);
                                if (index > -1) {
                                    balloons.splice(index, 1);
                                    app.addNewBalloon(balloons, canvas, currentLetter);
                                }
                            }
                            return;
                        }
                        
                        this.y -= this.speed;
                        
                        // Handle resize
                        if (this.x > canvas.width) this.x = Math.random() * canvas.width;
                        
                        if (this.y < -this.radius) {
                            const index = balloons.indexOf(this);
                            if (index > -1) {
                                balloons.splice(index, 1);
                                app.addNewBalloon(balloons, canvas, currentLetter);
                            }
                        }
                    },
                    checkClick: function(mouseX, mouseY) {
                        if (this.popped) return false;
                        
                        const dx = mouseX - this.x;
                        const dy = mouseY - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Increased hit area slightly (radius * 1.2) for better touch
                        if (distance < this.radius * 1.2) {
                            this.popped = true;
                            
                            if (this.isCorrect) {
                                // Chain Reaction: Pop all balloons with the same letter
                                let extraPopped = 0;
                                balloons.forEach(b => {
                                    if (!b.popped && b.letter === this.letter && b !== this) {
                                        b.popped = true;
                                        extraPopped++;
                                    }
                                });
                                
                                app.gameStats.successCount += (1 + extraPopped);
                                app.gameStats.totalAttempts++;
                                app.gameScoreEl.textContent = parseInt(app.gameScoreEl.textContent) + 10 + (extraPopped * 5);
                                app.soundManager.playSound('success');
                                
                                // Win condition: 16 correct pops
                                if (app.gameStats.successCount >= 16) {
                                    app.showWinGame();
                                    app.showToast('üéâ ÿ£ÿ≠ÿ≥ŸÜÿ™! ŸÑŸÇÿØ ŸÅÿ¨ÿ±ÿ™ 16 ÿ®ÿßŸÑŸàŸÜÿßŸã ÿµÿ≠Ÿäÿ≠ÿßŸã!', 3000, 'success');
                                    return true;
                                }
                            } else {
                                app.gameStats.totalAttempts++;
                                app.gameScoreEl.textContent = Math.max(0, parseInt(app.gameScoreEl.textContent) - 5);
                                app.soundManager.playSound('error');
                            }
                            
                            app.updateGameStats();
                            return true;
                        }
                        return false;
                    }
                });
            }
            
            initTypingGame(ctx, canvas) {
                const currentLetter = LETTERS[this.currentLetterIndex];
                const app = this;
                
                // Mobile keyboard support
                const hiddenInput = document.createElement('input');
                hiddenInput.style.position = 'absolute';
                hiddenInput.style.opacity = '0';
                hiddenInput.style.top = '-1000px';
                // Prevent zooming on focus by setting font size
                hiddenInput.style.fontSize = '16px';
                document.body.appendChild(hiddenInput);
                this.hiddenInput = hiddenInput;
                
                const focusInput = (e) => {
                    // Don't prevent default on click, otherwise focus might not work
                    hiddenInput.focus();
                };
                
                canvas.addEventListener('click', focusInput);
                canvas.addEventListener('touchstart', (e) => {
                    // e.preventDefault(); // Don't prevent default here, we need focus
                    hiddenInput.focus();
                }, { passive: true });
                
                hiddenInput.addEventListener('input', (e) => {
                    if (e.data) {
                        const key = e.data.toLowerCase();
                        // Call keyHandler logic
                        if (this.currentKeyHandler) {
                            this.currentKeyHandler({ key: key });
                        }
                        hiddenInput.value = '';
                    }
                });
                
                const fallingLetters = [];
                const letterSpeed = 0.5; // Slower speed (was 1)
                let currentInput = '';
                let gameActive = true;
                
                const createLetter = () => {
                    const isCorrect = Math.random() > 0.5;
                    const letterData = LETTER_DATA[currentLetter];
                    
                    let content;
                    let isWord = false;

                    if (Math.random() > 0.6 && letterData.words.length > 0) {
                        // Spawn a word
                        const wordObj = letterData.words[Math.floor(Math.random() * letterData.words.length)];
                        content = wordObj.word;
                        isWord = true;
                    } else {
                        // Spawn a letter
                        content = isCorrect ? 
                            (Math.random() > 0.5 ? currentLetter : currentLetter.toLowerCase()) : 
                            LETTERS[Math.floor(Math.random() * LETTERS.length)];
                    }
                    
                    fallingLetters.push({
                        content: content,
                        isWord: isWord,
                        x: Math.random() * (canvas.width - 100) + 50,
                        y: -50,
                        speed: (letterSpeed + Math.random() * 0.5), // Slower variation
                        typed: '',
                        completed: false
                    });
                };
                
                createLetter();
                
                const keyHandler = (e) => {
                    if (!gameActive) return;
                    
                    if (e.key.length === 1 && e.key.match(/[a-zA-Z]/)) {
                        const char = e.key.toLowerCase();
                        app.soundManager.playSound('click');
                        
                        // Check all falling items
                        for (let i = fallingLetters.length - 1; i >= 0; i--) {
                            const item = fallingLetters[i];
                            if (item.completed) continue;

                            const target = item.content.toLowerCase();
                            const nextCharIndex = item.typed.length;
                            
                            if (target[nextCharIndex] === char) {
                                item.typed += char;
                                
                                if (item.typed === target) {
                                    item.completed = true;
                                    app.gameStats.successCount++;
                                    app.gameStats.totalAttempts++;
                                    app.gameScoreEl.textContent = parseInt(app.gameScoreEl.textContent) + (item.isWord ? 20 : 10);
                                    app.soundManager.playSound('success');
                                    app.updateGameStats();
                                    
                                    // Win condition: 10 correct types
                                    if (app.gameStats.successCount >= 10) {
                                        app.showWinGame();
                                    }
                                }
                                // Only process one correct keystroke per frame to avoid ambiguity if multiple same letters
                                break; 
                            }
                        }
                    }
                };
                
                document.addEventListener('keydown', keyHandler);
                this.currentKeyHandler = keyHandler;
                
                const gameLoop = () => {
                    if (!app.gameRunning) return;
                    if (!gameActive) return;
                    
                    if (app.isPaused) {
                        this.gameAnimationFrame = requestAnimationFrame(gameLoop);
                        return;
                    }
                    
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#0f172a';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#f1f5f9';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText(`ÿßŸÑŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿ≥ÿ±Ÿäÿπÿ© - ÿßŸÑÿ≠ÿ±ŸÅ ${currentLetter}`, canvas.width/2, 10);
                    
                    ctx.fillStyle = '#cbd5e1';
                    ctx.font = '16px Arial';
                    ctx.fillText('ÿßŸÉÿ™ÿ® ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿ£Ÿà ÿßŸÑÿ≠ÿ±ŸàŸÅ ŸÇÿ®ŸÑ ŸàÿµŸàŸÑŸáÿß ŸÑŸÑÿ£ÿ≥ŸÅŸÑ!', canvas.width/2, 40);
                    
                    fallingLetters.forEach((item, index) => {
                        item.y += item.speed;
                        
                        // Handle resize
                        if (item.x > canvas.width - 50) item.x = canvas.width - 50;
                        
                        if (item.y > canvas.height - 50 && !item.completed) {
                            app.gameStats.totalAttempts++;
                            fallingLetters.splice(index, 1);
                            app.updateGameStats();
                            app.soundManager.playSound('error');
                        }
                        
                        if (item.y > canvas.height) {
                            fallingLetters.splice(index, 1);
                        }
                        
                        // Draw
                        ctx.font = item.isWord ? 'bold 24px Arial' : 'bold 32px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        // Base text (faded)
                        ctx.fillStyle = item.completed ? '#22c55e' : '#f472b6';
                        ctx.fillText(item.content, item.x, item.y);
                        
                        // Typed part (highlighted)
                        if (item.typed.length > 0) {
                            const typedPart = item.content.substring(0, item.typed.length);
                            ctx.fillStyle = '#4cc9f0';
                            // Simple overlay for typed part (centered alignment makes exact overlay tricky without measuring)
                            // For simplicity in canvas centered text, we can just redraw the whole thing in a different color if fully typed,
                            // or measure width. Let's try measuring.
                            const totalWidth = ctx.measureText(item.content).width;
                            const typedWidth = ctx.measureText(typedPart).width;
                            const startX = item.x - totalWidth / 2;
                            
                            ctx.textAlign = 'left';
                            ctx.fillText(typedPart, startX, item.y);
                            ctx.textAlign = 'center'; // Reset
                        }
                    });
                    
                    // Increased spawn rate (0.03 instead of 0.015)
                    if (Math.random() < 0.03 && fallingLetters.length < 12) {
                        createLetter();
                    }
                    
                    this.gameAnimationFrame = requestAnimationFrame(gameLoop);
                };
                
                gameLoop();
            }
            
            initMemoryGame(ctx, canvas) {
                const currentLetter = LETTERS[this.currentLetterIndex];
                const app = this;
                
                const cards = [];
                const padding = 10;
                const cols = 4;
                const rows = 3;
                
                // Dynamic card size
                let availableWidth = canvas.width - (cols + 1) * padding;
                let cardWidth = Math.min(80, availableWidth / cols);
                let cardHeight = cardWidth * 1.25;
                
                const cardData = [];
                const letters = [currentLetter, currentLetter.toLowerCase()];
                
                for (let i = 0; i < 6; i++) {
                    const letter = letters[i % 2];
                    cardData.push({
                        type: 'letter',
                        value: letter,
                        pairId: i % 2
                    });
                }
                
                for (let i = 0; i < 6; i++) {
                    const letter = letters[i % 2];
                    cardData.push({
                        type: 'letter',
                        value: letter,
                        pairId: i % 2
                    });
                }
                
                cardData.sort(() => Math.random() - 0.5);
                
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        const index = i * cols + j;
                        if (index >= cardData.length) break;
                        
                        cards.push({
                            col: j, // Store column for resize
                            row: i, // Store row for resize
                            x: j * (cardWidth + padding) + (canvas.width - (cols * (cardWidth + padding) - padding)) / 2,
                            y: i * (cardHeight + padding) + 50,
                            width: cardWidth,
                            height: cardHeight,
                            data: cardData[index],
                            flipped: false,
                            matched: false,
                            draw: function() {
                                ctx.fillStyle = this.flipped || this.matched ? '#ffffff' : '#4361ee';
                                ctx.fillRect(this.x, this.y, this.width, this.height);
                                
                                ctx.strokeStyle = this.matched ? '#4ade80' : '#1e293b';
                                ctx.lineWidth = 2;
                                ctx.strokeRect(this.x, this.y, this.width, this.height);
                                
                                if (this.flipped || this.matched) {
                                    ctx.fillStyle = '#1e293b';
                                    ctx.font = 'bold 40px Arial';
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'middle';
                                    ctx.fillText(this.data.value, this.x + this.width/2, this.y + this.height/2);
                                    
                                    ctx.fillStyle = '#475569';
                                    ctx.font = '12px Arial';
                                    ctx.fillText(
                                        'ÿßŸÑÿ≠ÿ±ŸÅ',
                                        this.x + this.width/2,
                                        this.y + 15
                                    );
                                } else {
                                    ctx.fillStyle = '#3a0ca3';
                                    ctx.font = 'bold 24px Arial';
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'middle';
                                    ctx.fillText('?', this.x + this.width/2, this.y + this.height/2);
                                }
                            },
                            contains: function(x, y) {
                                return x >= this.x && x <= this.x + this.width &&
                                       y >= this.y && y <= this.y + this.height;
                            }
                        });
                    }
                }
                
                let firstCard = null;
                let secondCard = null;
                let canFlip = true;
                
                const clickHandler = (e) => {
                    if (!canFlip) return;
                    
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    const clickedCard = cards.find(card => 
                        !card.matched && !card.flipped && card.contains(mouseX, mouseY)
                    );
                    
                    if (!clickedCard) return;
                    
                    clickedCard.flipped = true;
                    app.soundManager.playSound('click');
                    
                    if (!firstCard) {
                        firstCard = clickedCard;
                    } else if (!secondCard) {
                        secondCard = clickedCard;
                        canFlip = false;
                        
                        app.gameStats.totalAttempts++;
                        
                        if (firstCard.data.pairId === secondCard.data.pairId && 
                            firstCard.data.value === secondCard.data.value) {
                            firstCard.matched = true;
                            secondCard.matched = true;
                            app.gameStats.successCount++;
                            app.gameScoreEl.textContent = parseInt(app.gameScoreEl.textContent) + 20;
                            app.soundManager.playSound('success');
                            
                            if (cards.every(card => card.matched)) {
                                setTimeout(() => {
                                    app.showWinGame();
                                }, 500);
                            }
                        } else {
                            app.soundManager.playSound('error');
                            setTimeout(() => {
                                firstCard.flipped = false;
                                secondCard.flipped = false;
                            }, 1000);
                        }
                        
                        setTimeout(() => {
                            firstCard = null;
                            secondCard = null;
                            canFlip = true;
                            app.updateGameStats();
                        }, 1000);
                    }
                };
                
                canvas.addEventListener('click', clickHandler);
                
                // Touch support for Memory Game
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    // Simulate click
                    clickHandler({ clientX: touch.clientX, clientY: touch.clientY });
                }, { passive: false });

                this.currentClickHandler = clickHandler;
                
                const gameLoop = () => {
                    if (!app.gameRunning) return;
                    
                    if (app.isPaused) {
                        this.gameAnimationFrame = requestAnimationFrame(gameLoop);
                        return;
                    }

                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Recalculate positions on resize
                    let availableWidth = canvas.width - (cols + 1) * padding;
                    cardWidth = Math.min(80, availableWidth / cols);
                    cardHeight = cardWidth * 1.25;
                    
                    const startX = (canvas.width - (cols * (cardWidth + padding) - padding)) / 2;
                    cards.forEach(card => {
                        card.width = cardWidth;
                        card.height = cardHeight;
                        card.x = card.col * (cardWidth + padding) + startX;
                        card.y = card.row * (cardHeight + padding) + 50;
                    });
                    
                    ctx.fillStyle = '#f8fafc';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#1e293b';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText(`ŸÑÿπÿ®ÿ© ÿßŸÑÿ∞ÿßŸÉÿ±ÿ© - ÿßŸÑÿ≠ÿ±ŸÅ ${currentLetter}`, canvas.width/2, 10);
                    
                    cards.forEach(card => card.draw());
                    
                    this.gameAnimationFrame = requestAnimationFrame(gameLoop);
                };
                
                gameLoop();
            }
            
            initWordSearchGame(ctx, canvas) {
                const currentLetter = LETTERS[this.currentLetterIndex];
                const letterData = LETTER_DATA[currentLetter];
                // Use the words from the letter data, limited to 6 to fit nicely
                const targetWords = letterData.words.slice(0, 6).map((w) => ({
                    word: w.word.toLowerCase(),
                    translation: w.translation,
                    found: false
                }));
                
                const app = this;
                
                const gridSize = 10;
                // Adjust cell size to fit grid on the left
                const cellSize = 35; 
                const gridOffsetX = 20;
                const gridOffsetY = 60;

                const grid = [];
                
                // Initialize grid with empty placeholders
                for (let i = 0; i < gridSize; i++) {
                    grid[i] = [];
                    for (let j = 0; j < gridSize; j++) {
                        grid[i][j] = '.';
                    }
                }
                
                const placedWords = [];
                let foundWordsCount = 0;
                
                targetWords.forEach(target => {
                    let placed = false;
                    let attempts = 0;
                    const word = target.word;
                    
                    while (!placed && attempts < 100) {
                        const direction = Math.floor(Math.random() * 3);
                        const row = Math.floor(Math.random() * gridSize);
                        const col = Math.floor(Math.random() * gridSize);
                        
                        if (this.canPlaceWord(grid, word, row, col, direction)) {
                            this.placeWord(grid, word, row, col, direction);
                            placedWords.push({
                                ...target, // Include translation and initial found state
                                row: row,
                                col: col,
                                direction: direction
                            });
                            placed = true;
                        }
                        attempts++;
                    }
                });

                // Fill remaining empty spots with random letters
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        if (grid[i][j] === '.') {
                            grid[i][j] = LETTERS[Math.floor(Math.random() * LETTERS.length)].toLowerCase();
                        }
                    }
                }
                
                const cells = [];
                let selectedCells = [];
                
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        cells.push({
                            row: i,
                            col: j,
                            x: j * cellSize + gridOffsetX,
                            y: i * cellSize + gridOffsetY,
                            size: cellSize,
                            letter: grid[i][j],
                            selected: false,
                            highlighted: false, // For permanently found words
                            draw: function() {
                                // Background
                                if (this.highlighted) {
                                    ctx.fillStyle = '#86efac'; // Green for found
                                } else if (this.selected) {
                                    ctx.fillStyle = '#4cc9f0'; // Blue for selecting
                                } else {
                                    ctx.fillStyle = '#ffffff';
                                }
                                ctx.fillRect(this.x, this.y, this.size, this.size);
                                
                                ctx.strokeStyle = '#cbd5e1';
                                ctx.lineWidth = 1;
                                ctx.strokeRect(this.x, this.y, this.size, this.size);
                                
                                ctx.fillStyle = '#1e293b';
                                // Dynamic font size based on cell size
                                const fontSize = Math.floor(this.size * 0.6);
                                ctx.font = `bold ${fontSize}px Arial`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(this.letter, this.x + this.size/2, this.y + this.size/2 + 2);
                            },
                            contains: function(x, y) {
                                return x >= this.x && x <= this.x + this.size &&
                                       y >= this.y && y <= this.y + this.size;
                            }
                        });
                    }
                }
                
                let isDragging = false;
                let startCell = null;
                
                const mouseDownHandler = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    startCell = cells.find(cell => cell.contains(mouseX, mouseY));
                    if (startCell) {
                        isDragging = true;
                        selectedCells = [startCell];
                        startCell.selected = true;
                    }
                };
                
                const mouseMoveHandler = (e) => {
                    if (!isDragging || !startCell) return;
                    
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    const currentCell = cells.find(cell => cell.contains(mouseX, mouseY));
                    if (currentCell && currentCell !== startCell) {
                        selectedCells = this.getCellsBetween(startCell, currentCell, cells);
                        
                        cells.forEach(cell => {
                            // Only select if not already part of a found word (optional, but good for clarity)
                            cell.selected = selectedCells.includes(cell);
                        });
                    }
                };
                
                const mouseUpHandler = (e) => {
                    if (!isDragging || selectedCells.length < 2) {
                        cells.forEach(cell => cell.selected = false);
                        isDragging = false;
                        startCell = null;
                        return;
                    }
                    
                    const selectedWord = selectedCells.map(cell => cell.letter).join('');
                    
                    let foundWord = null;
                    for (const placedWord of placedWords) {
                        if (!placedWord.found && selectedWord === placedWord.word) {
                            foundWord = placedWord;
                            break;
                        }
                    }
                    
                    if (foundWord) {
                        foundWord.found = true;
                        foundWordsCount++;
                        app.gameStats.successCount++;
                        app.gameStats.totalAttempts++;
                        app.gameScoreEl.textContent = parseInt(app.gameScoreEl.textContent) + 15;
                        app.soundManager.playSound('success');
                        
                        // ŸÜÿ∑ŸÇ ÿßŸÑŸÉŸÑŸÖÿ© ÿπŸÜÿØ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸäŸáÿß
                        app.speakText(foundWord.word.toLowerCase());
                        
                        const wordCells = this.getWordCells(foundWord, cells, gridSize, cellSize);
                        wordCells.forEach(cell => {
                            cell.highlighted = true; // Mark as permanently found
                            cell.selected = false;
                        });
                        
                        if (foundWordsCount >= placedWords.length) {
                            setTimeout(() => {
                                app.showWinGame();
                            }, 1000);
                        }
                    } else {
                        app.gameStats.totalAttempts++;
                        app.soundManager.playSound('error');
                        cells.forEach(cell => cell.selected = false);
                    }
                    
                    isDragging = false;
                    startCell = null;
                    selectedCells = [];
                    app.updateGameStats();
                };
                
                canvas.addEventListener('mousedown', mouseDownHandler);
                canvas.addEventListener('mousemove', mouseMoveHandler);
                canvas.addEventListener('mouseup', mouseUpHandler);
                
                // Touch support
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    mouseDownHandler({ clientX: touch.clientX, clientY: touch.clientY });
                }, { passive: false });
                
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    mouseMoveHandler({ clientX: touch.clientX, clientY: touch.clientY });
                }, { passive: false });
                
                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const touch = e.changedTouches[0];
                    mouseUpHandler({ clientX: touch.clientX, clientY: touch.clientY });
                }, { passive: false });

                this.currentMouseHandlers = {
                    mousedown: mouseDownHandler,
                    mousemove: mouseMoveHandler,
                    mouseup: mouseUpHandler
                };
                
                const gameLoop = () => {
                    if (!app.gameRunning) return;
                    
                    if (app.isPaused) {
                        this.gameAnimationFrame = requestAnimationFrame(gameLoop);
                        return;
                    }

                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Responsive Layout Calculation
                    const totalWidth = canvas.width;
                    const totalHeight = canvas.height;
                    const isMobile = totalWidth < 600; // Mobile breakpoint
                    
                    let newCellSize, newGridOffsetX, gridOffsetY_Dynamic;
                    
                    if (isMobile) {
                        // Mobile Layout: Grid on top, List below
                        // Grid takes full width minus padding
                        const availableGridWidth = totalWidth - 20;
                        // Grid takes about 60% of height
                        const availableGridHeight = totalHeight * 0.6;
                        
                        newCellSize = Math.min(availableGridWidth / gridSize, availableGridHeight / gridSize);
                        newCellSize = Math.min(40, Math.max(20, newCellSize)); // Cap size
                        
                        newGridOffsetX = (totalWidth - (gridSize * newCellSize)) / 2;
                        gridOffsetY_Dynamic = 50; // Space for title
                    } else {
                        // Desktop Layout: Side-by-Side
                        const gridWidthRatio = 0.75; 
                        const availableGridWidth = (totalWidth * gridWidthRatio) - 10;
                        const availableGridHeight = totalHeight - gridOffsetY - 10;
                        
                        newCellSize = Math.min(availableGridWidth / gridSize, availableGridHeight / gridSize);
                        newCellSize = Math.min(60, Math.max(25, newCellSize));
                        
                        newGridOffsetX = 10;
                        gridOffsetY_Dynamic = gridOffsetY;
                    }
                    
                    cells.forEach(cell => {
                        cell.size = newCellSize;
                        cell.x = cell.col * newCellSize + newGridOffsetX;
                        cell.y = cell.row * newCellSize + gridOffsetY_Dynamic;
                    });
                    
                    // Background
                    ctx.fillStyle = '#f8fafc';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Title
                    ctx.fillStyle = '#1e293b';
                    ctx.font = `bold ${Math.max(16, totalWidth / 25)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText(`ŸÑÿπÿ®ÿ© ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑŸÉŸÑŸÖÿßÿ™ - ÿßŸÑÿ≠ÿ±ŸÅ ${currentLetter}`, canvas.width/2, 10);
                    
                    // Draw Grid
                    cells.forEach(cell => cell.draw());
                    
                    // Draw Word List
                    let listX, listY;
                    
                    if (isMobile) {
                        // List below grid
                        listX = 20;
                        listY = gridOffsetY_Dynamic + (gridSize * newCellSize) + 20;
                        
                        ctx.textAlign = 'right'; // RTL for list
                        ctx.textBaseline = 'top';
                        ctx.fillStyle = '#334155';
                        ctx.font = 'bold 16px Arial';
                        ctx.fillText('ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ©:', totalWidth - 20, listY);
                        
                        // Draw words in a grid-like flow or columns if possible, or just a list
                        // For simplicity on mobile, let's do 2 columns
                        const colWidth = (totalWidth - 40) / 2;
                        const itemHeight = 25;
                        
                        placedWords.forEach((word, i) => {
                            const col = i % 2;
                            const row = Math.floor(i / 2);
                            const xPos = totalWidth - 20 - (col * colWidth); // RTL flow
                            const yPos = listY + 30 + (row * itemHeight);
                            
                            // Draw logic similar to desktop but adjusted
                            const iconSize = 12;
                            const textX = xPos - iconSize - 5;
                            
                            if (word.found) {
                                ctx.fillStyle = '#22c55e';
                                ctx.fillText('‚úÖ', xPos, yPos);
                            } else {
                                ctx.fillStyle = '#d8b4fe';
                                ctx.fillRect(xPos - iconSize, yPos, iconSize, iconSize);
                            }
                            
                            ctx.textAlign = 'right';
                            if (word.found) {
                                ctx.fillStyle = '#94a3b8';
                                ctx.font = 'bold 14px Arial';
                                ctx.fillText(word.word, textX, yPos);
                                const textWidth = ctx.measureText(word.word).width;
                                ctx.fillRect(textX - textWidth, yPos + 8, textWidth, 2);
                            } else {
                                ctx.fillStyle = '#1e293b';
                                ctx.font = 'bold 14px Arial';
                                ctx.fillText(word.word, textX, yPos);
                            }
                        });
                        
                    } else {
                        // Desktop List (Right Side)
                        listX = newGridOffsetX + (gridSize * newCellSize) + 15;
                        listY = gridOffsetY_Dynamic;
                        
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        
                        ctx.fillStyle = '#334155';
                        ctx.font = `bold ${Math.max(12, totalWidth / 35)}px Arial`;
                        ctx.fillText('ÿßŸÑŸÉŸÑŸÖÿßÿ™ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ©:', listX, listY - 30);
                        
                        const itemHeight = Math.max(30, newCellSize * 0.8);
                        
                        placedWords.forEach((word, i) => {
                            const yPos = listY + i * itemHeight;
                            const iconSize = Math.max(12, itemHeight * 0.5);
                            
                            if (word.found) {
                                ctx.fillStyle = '#22c55e';
                                ctx.font = `${iconSize}px Arial`;
                                ctx.fillText('‚úÖ', listX, yPos + (itemHeight - iconSize)/2);
                            } else {
                                ctx.fillStyle = '#d8b4fe';
                                ctx.fillRect(listX, yPos + (itemHeight - iconSize)/2, iconSize, iconSize);
                                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                                ctx.fillRect(listX, yPos + (itemHeight - iconSize)/2 + iconSize/2, iconSize, iconSize/2);
                            }
                            
                            const textX = listX + iconSize + 8;
                            const fontSize = Math.max(12, Math.min(20, (totalWidth - listX) / 8)); 
                            
                            if (word.found) {
                                ctx.fillStyle = '#94a3b8';
                                ctx.font = `bold ${fontSize}px Arial`;
                                ctx.fillText(word.word, textX, yPos + itemHeight/2 - fontSize/2);
                                const textWidth = ctx.measureText(word.word).width;
                                ctx.fillRect(textX, yPos + itemHeight/2, textWidth, 2);
                            } else {
                                ctx.fillStyle = '#1e293b';
                                ctx.font = `bold ${fontSize}px Arial`;
                                ctx.fillText(word.word, textX, yPos + itemHeight/2 - fontSize/2);
                            }
                        });
                        
                        // Progress
                        ctx.fillStyle = '#f72585';
                        ctx.font = `bold ${Math.max(12, totalWidth / 35)}px Arial`;
                        ctx.textAlign = 'center';
                        const listCenter = listX + (totalWidth - listX) / 2;
                        ctx.fillText(`ÿßŸÑŸÉŸÑŸÖÿßÿ™: ${foundWordsCount}/${placedWords.length}`, listCenter, listY + placedWords.length * itemHeight + 20);
                    }
                    
                    this.gameAnimationFrame = requestAnimationFrame(gameLoop);
                };
                
                gameLoop();
            }
            
            canPlaceWord(grid, word, row, col, direction) {
                const wordLength = word.length;
                
                switch(direction) {
                    case 0:
                        if (col + wordLength > grid[0].length) return false;
                        break;
                    case 1:
                        if (row + wordLength > grid.length) return false;
                        break;
                    case 2:
                        if (row + wordLength > grid.length || col + wordLength > grid[0].length) return false;
                        break;
                }
                
                for (let i = 0; i < wordLength; i++) {
                    let r = row, c = col;
                    
                    switch(direction) {
                        case 0: c = col + i; break;
                        case 1: r = row + i; break;
                        case 2: r = row + i; c = col + i; break;
                    }
                    
                    if (grid[r][c] !== '.' && grid[r][c] !== word[i]) {
                        return false;
                    }
                }
                
                return true;
            }
            
            placeWord(grid, word, row, col, direction) {
                for (let i = 0; i < word.length; i++) {
                    let r = row, c = col;
                    
                    switch(direction) {
                        case 0: c = col + i; break;
                        case 1: r = row + i; break;
                        case 2: r = row + i; c = col + i; break;
                    }
                    
                    grid[r][c] = word[i];
                }
            }
            
            getCellsBetween(startCell, endCell, allCells) {
                const cells = [startCell];
                
                const rowDiff = endCell.row - startCell.row;
                const colDiff = endCell.col - startCell.col;
                
                if (rowDiff !== 0 && colDiff !== 0 && Math.abs(rowDiff) !== Math.abs(colDiff)) {
                    return cells;
                }
                
                const rowStep = rowDiff === 0 ? 0 : rowDiff / Math.abs(rowDiff);
                const colStep = colDiff === 0 ? 0 : colDiff / Math.abs(colDiff);
                
                let currentRow = startCell.row + rowStep;
                let currentCol = startCell.col + colStep;
                
                while ((rowStep === 0 || (rowStep > 0 ? currentRow <= endCell.row : currentRow >= endCell.row)) &&
                       (colStep === 0 || (colStep > 0 ? currentCol <= endCell.col : currentCol >= endCell.col))) {
                    
                    const cell = allCells.find(c => c.row === currentRow && c.col === currentCol);
                    if (cell) {
                        cells.push(cell);
                    }
                    
                    currentRow += rowStep;
                    currentCol += colStep;
                }
                
                return cells;
            }
            
            getWordCells(placedWord, allCells, gridSize, cellSize) {
                const cells = [];
                const { word, row, col, direction } = placedWord;
                
                for (let i = 0; i < word.length; i++) {
                    let r = row, c = col;
                    
                    switch(direction) {
                        case 0: c = col + i; break;
                        case 1: r = row + i; break;
                        case 2: r = row + i; c = col + i; break;
                    }
                    
                    const cell = allCells.find(cell => cell.row === r && cell.col === c);
                    if (cell) {
                        cells.push(cell);
                    }
                }
                
                return cells;
            }
            
            initMatchGame(ctx, canvas) {
                const currentLetter = LETTERS[this.currentLetterIndex];
                const letterData = LETTER_DATA[currentLetter];
                const app = this;
                
                const letters = [];
                const words = [];
                const matches = [];
                
                // Responsive layout calculation
                const isMobile = canvas.width < 600;
                const letterWidth = isMobile ? 40 : Math.min(50, canvas.width * 0.15);
                const wordWidth = isMobile ? canvas.width * 0.5 : Math.min(150, canvas.width * 0.45);
                
                const letterX = isMobile ? 10 : canvas.width * 0.1;
                const wordX = isMobile ? canvas.width - wordWidth - 10 : canvas.width * 0.5;
                
                for (let i = 0; i < 6; i++) {
                    letters.push({
                        id: i,
                        letter: i % 2 === 0 ? currentLetter : currentLetter.toLowerCase(),
                        x: letterX,
                        y: 100 + i * (isMobile ? 50 : 60),
                        width: letterWidth,
                        height: isMobile ? 40 : 50,
                        dragging: false,
                        matched: false,
                        draw: function() {
                            ctx.fillStyle = this.matched ? '#4ade80' : '#4361ee';
                            ctx.fillRect(this.x, this.y, this.width, this.height);
                            
                            ctx.fillStyle = 'white';
                            ctx.font = isMobile ? 'bold 24px Arial' : 'bold 30px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(this.letter, this.x + this.width/2, this.y + this.height/2);
                        },
                        contains: function(x, y) {
                            return x >= this.x && x <= this.x + this.width &&
                                   y >= this.y && y <= this.y + this.height;
                        }
                    });
                }
                
                letterData.words.forEach((wordData, i) => {
                    if (i < 6) {
                        words.push({
                            id: i,
                            word: wordData.word,
                            translation: wordData.translation,
                            x: wordX,
                            y: 100 + i * (isMobile ? 50 : 60),
                            width: wordWidth,
                            height: isMobile ? 40 : 50,
                            matched: false,
                            draw: function() {
                                ctx.fillStyle = this.matched ? '#4ade80' : '#f59e0b';
                                ctx.fillRect(this.x, this.y, this.width, this.height);
                                
                                ctx.fillStyle = 'white';
                                ctx.font = isMobile ? 'bold 16px Arial' : 'bold 18px Arial';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                
                                const lines = this.wrapText(ctx, this.word, this.width - 10);
                                lines.forEach((line, idx) => {
                                    ctx.fillText(
                                        line,
                                        this.x + this.width/2,
                                        this.y + this.height/2 + (idx - (lines.length-1)/2) * (isMobile ? 16 : 20)
                                    );
                                });
                                
                                // Hide translation on very small screens if matched to save space, or keep it small
                                if (!isMobile || !this.matched) {
                                    ctx.fillStyle = '#cbd5e1';
                                    ctx.font = isMobile ? '10px Arial' : '12px Arial';
                                    ctx.fillText(this.translation, this.x + this.width/2, this.y + this.height + (isMobile ? 10 : 15));
                                }
                            },
                            wrapText: function(ctx, text, maxWidth) {
                                const words = text.split(' ');
                                const lines = [];
                                let currentLine = words[0];
                                
                                for (let i = 1; i < words.length; i++) {
                                    const word = words[i];
                                    const width = ctx.measureText(currentLine + " " + word).width;
                                    if (width < maxWidth) {
                                        currentLine += " " + word;
                                    } else {
                                        lines.push(currentLine);
                                        currentLine = word;
                                    }
                                }
                                lines.push(currentLine);
                                return lines;
                            },
                            contains: function(x, y) {
                                return x >= this.x && x <= this.x + this.width &&
                                       y >= this.y && y <= this.y + this.height;
                            }
                        });
                    }
                });
                
                let draggedLetter = null;
                let offsetX = 0, offsetY = 0;
                
                const mouseDownHandler = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    for (const letter of letters) {
                        if (!letter.matched && letter.contains(mouseX, mouseY)) {
                            draggedLetter = letter;
                            draggedLetter.dragging = true;
                            offsetX = mouseX - letter.x;
                            offsetY = mouseY - letter.y;
                            break;
                        }
                    }
                };
                
                const mouseMoveHandler = (e) => {
                    if (!draggedLetter) return;
                    
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    draggedLetter.x = mouseX - offsetX;
                    draggedLetter.y = mouseY - offsetY;
                };
                
                const mouseUpHandler = (e) => {
                    if (!draggedLetter) return;
                    
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    let matchedWord = null;
                    for (const word of words) {
                        if (!word.matched && word.contains(mouseX, mouseY)) {
                            if (word.word.startsWith(draggedLetter.letter.toUpperCase()) || 
                                word.word.toLowerCase().startsWith(draggedLetter.letter.toLowerCase())) {
                                matchedWord = word;
                                break;
                            }
                        }
                    }
                    
                    if (matchedWord) {
                        draggedLetter.matched = true;
                        matchedWord.matched = true;
                        
                        draggedLetter.x = matchedWord.x - 60;
                        draggedLetter.y = matchedWord.y;
                        
                        matches.push({
                            fromX: draggedLetter.x + draggedLetter.width,
                            fromY: draggedLetter.y + draggedLetter.height/2,
                            toX: matchedWord.x,
                            toY: matchedWord.y + matchedWord.height/2
                        });
                        
                        app.gameStats.successCount++;
                        app.gameStats.totalAttempts++;
                        app.gameScoreEl.textContent = parseInt(app.gameScoreEl.textContent) + 10;
                        app.soundManager.playSound('success');
                        
                        // ŸÜÿ∑ŸÇ ÿßŸÑŸÉŸÑŸÖÿ© ÿπŸÜÿØ ÿßŸÑŸÖÿ∑ÿßÿ®ŸÇÿ©
                        app.speakText(matchedWord.word.toLowerCase());
                        
                        // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸÅŸàÿ≤: ÿ•ÿ∞ÿß ÿ™ŸÖ ŸÖÿ∑ÿßÿ®ŸÇÿ© 5 ŸÉŸÑŸÖÿßÿ™ ÿ£Ÿà ÿ£ŸÉÿ´ÿ±
                        const matchedCount = letters.filter(l => l.matched).length;
                        if (matchedCount >= 5) {
                            setTimeout(() => {
                                app.showWinGame();
                            }, 1000);
                        }
                    } else {
                        const originalIndex = letters.findIndex(l => l.id === draggedLetter.id);
                        draggedLetter.x = 100;
                        draggedLetter.y = 100 + originalIndex * 60;
                        app.soundManager.playSound('error');
                    }
                    
                    draggedLetter.dragging = false;
                    draggedLetter = null;
                    app.updateGameStats();
                };
                
                canvas.addEventListener('mousedown', mouseDownHandler);
                canvas.addEventListener('mousemove', mouseMoveHandler);
                canvas.addEventListener('mouseup', mouseUpHandler);
                
                // Touch support
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    mouseDownHandler({ clientX: touch.clientX, clientY: touch.clientY });
                }, { passive: false });
                
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    mouseMoveHandler({ clientX: touch.clientX, clientY: touch.clientY });
                }, { passive: false });
                
                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const touch = e.changedTouches[0];
                    mouseUpHandler({ clientX: touch.clientX, clientY: touch.clientY });
                }, { passive: false });

                this.currentMouseHandlers = {
                    mousedown: mouseDownHandler,
                    mousemove: mouseMoveHandler,
                    mouseup: mouseUpHandler
                };
                
                const gameLoop = () => {
                    if (!app.gameRunning) return;
                    
                    if (app.isPaused) {
                        this.gameAnimationFrame = requestAnimationFrame(gameLoop);
                        return;
                    }

                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Responsive update
                    const letterX = canvas.width * 0.1;
                    const letterWidth = Math.min(50, canvas.width * 0.15);
                    const wordX = canvas.width * 0.5;
                    const wordWidth = Math.min(150, canvas.width * 0.45);
                    
                    letters.forEach(letter => {
                        if (!letter.dragging && !letter.matched) {
                            letter.x = letterX;
                            letter.width = letterWidth;
                        } else if (letter.matched) {
                            // Keep matched letters relative to words
                            // We need to find the matched word to position correctly, 
                            // but simpler is to just let them stay where they were placed relative to the word
                            // If word moves, letter should move too.
                            // But we don't have a link back to the word easily here without searching.
                            // For now, let's just update width.
                            letter.width = letterWidth;
                        }
                    });
                    
                    words.forEach(word => {
                        word.x = wordX;
                        word.width = wordWidth;
                    });

                    ctx.fillStyle = '#f8fafc';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#1e293b';
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText(`ŸÑÿπÿ®ÿ© ÿßŸÑŸÖÿ∑ÿßÿ®ŸÇÿ© - ÿßŸÑÿ≠ÿ±ŸÅ ${currentLetter}`, canvas.width/2, 10);
                    
                    ctx.fillStyle = '#475569';
                    ctx.font = '16px Arial';
                    ctx.fillText('ÿßÿ≥ÿ≠ÿ® ÿßŸÑÿ≠ÿ±ŸÅ ÿ•ŸÑŸâ ÿßŸÑŸÉŸÑŸÖÿ© ÿßŸÑÿ™Ÿä ÿ™ÿ®ÿØÿ£ ÿ®Ÿá', canvas.width/2, 40);
                    
                    ctx.strokeStyle = '#4cc9f0';
                    ctx.lineWidth = 3;
                    matches.forEach(match => {
                        ctx.beginPath();
                        ctx.moveTo(match.fromX, match.fromY);
                        ctx.lineTo(match.toX, match.toY);
                        ctx.stroke();
                    });
                    
                    words.forEach(word => word.draw());
                    
                    letters.forEach(letter => letter.draw());
                    
                    this.gameAnimationFrame = requestAnimationFrame(gameLoop);
                };
                
                gameLoop();
            }
            
            initDefaultGame(ctx, canvas) {
                const currentLetter = LETTERS[this.currentLetterIndex];
                
                this.gameTitle.textContent = 'üéÆ ŸÑÿπÿ®ÿ© ÿ™ÿπŸÑŸäŸÖŸäÿ©';
                this.gameInstructions.textContent = 'Ÿáÿ∞Ÿá ŸÑÿπÿ®ÿ© ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿäÿ©. ÿßÿ≥ÿ™ŸÖÿ™ÿπ!';
                
                ctx.fillStyle = '#4361ee';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`ŸÑÿπÿ®ÿ© ${this.getGameName(this.currentGame)}`, canvas.width / 2, canvas.height / 2 - 30);
                ctx.fillText(`ÿßŸÑÿ≠ÿ±ŸÅ ${currentLetter}`, canvas.width / 2, canvas.height / 2 + 30);
            }
            
            launchBalloonsCelebration() {
                // Prevent multiple celebrations
                if (this.isCelebrating) return;
                this.isCelebrating = true;
                
                const container = document.body;
                const celebrationElements = [];
                
                // Create fewer balloons for better performance
                for (let i = 0; i < 15; i++) {
                    const balloon = document.createElement('div');
                    balloon.className = 'celebrate-balloon';
                    balloon.textContent = 'üéà';
                    balloon.style.left = Math.random() * 100 + 'vw';
                    balloon.style.animationDuration = (Math.random() * 1.5 + 2) + 's';
                    balloon.style.fontSize = (Math.random() * 15 + 25) + 'px';
                    container.appendChild(balloon);
                    celebrationElements.push(balloon);
                }
                
                // Clean up celebration elements
                this.gameTimeouts.push(setTimeout(() => {
                    celebrationElements.forEach(element => {
                        if (element.parentNode) {
                            element.parentNode.removeChild(element);
                        }
                    });
                    this.isCelebrating = false;
                }, 4000));
                
                this.createConfetti();
            }

            createConfetti() {
                // Prevent multiple confetti
                if (this.isConfettiActive) return;
                this.isConfettiActive = true;
                
                const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
                const confettiElements = [];
                
                // Reduce confetti count for better performance
                for (let i = 0; i < 50; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.animationDuration = (Math.random() * 2 + 1.5) + 's';
                    confetti.style.opacity = Math.random();
                    document.body.appendChild(confetti);
                    confettiElements.push(confetti);
                }
                
                // Clean up confetti elements
                this.gameTimeouts.push(setTimeout(() => {
                    confettiElements.forEach(element => {
                        if (element.parentNode) {
                            element.parentNode.removeChild(element);
                        }
                    });
                    this.isConfettiActive = false;
                }, 4000));
            }

            // ============ ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÅŸàÿ≤ ŸàÿßŸÑÿÆÿ≥ÿßÿ±ÿ© ============
            
            handleGameWin(gameName, letter = null) {
                const targetLetter = letter || LETTERS[this.currentLetterIndex];
                this.markGameCompleted(targetLetter, gameName);

                // Show motivational message
                this.showGameWinMessage(gameName);

                // Clean up and show win modal
                this.cleanupGameResources();
                this.gameModal.style.display = 'none';
                this.winModal.style.display = 'flex';
            }
            
            handleGameLose(gameName) {
                this.cleanupGameResources();
                this.gameModal.style.display = 'none';
                this.showToast('ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ! ÿ£ŸÜÿ™ ÿ™ÿ™ÿπŸÑŸÖ Ÿàÿ™ÿ™ÿ≠ÿ≥ŸÜ üí™', 3000);
            }
            
            showGameWinMessage(gameName) {
                const messages = {
                    'match': [
                        'ÿ£ÿ≠ÿ≥ŸÜÿ™! ÿ£ŸÜÿ™ ÿ®ÿ∑ŸÑ ÿßŸÑÿ≠ÿ±ŸàŸÅ üí™',
                        'ÿ±ÿßÿ¶ÿπ! ÿØŸÖÿßÿ∫ŸÉ ŸäŸÑŸÖÿπ ÿ∞ŸÉÿßÿ° ‚ú®',
                        'ŸÖŸÖÿ™ÿßÿ≤! ÿ∞ÿßŸÉÿ±ÿ™ŸÉ ŸÇŸàŸäÿ© ÿ¨ÿØÿßŸã! üß†',
                        'ÿπŸÖŸÑ ŸÖÿØŸáÿ¥! ÿ£ŸÜÿ™ ÿ™ÿ™ŸÇŸÜ ÿßŸÑŸÖÿ∑ÿßÿ®ŸÇÿ©! üåü'
                    ],
                    'balloons': [
                        'ÿπÿ∏ŸäŸÖ! ÿ≥ÿ±ÿπÿ™ŸÉ ŸÖÿ∞ŸáŸÑÿ©! ‚ö°',
                        'ÿ®ÿ±ÿßŸÅŸà! ÿßŸÜÿ™ÿ®ÿßŸáŸÉ ÿ±ÿßÿ¶ÿπ! üéØ',
                        'Ÿáÿßÿ¶ŸÑ! ÿ™ÿ±ŸÉŸäÿ≤ŸÉ ŸÖÿØŸáÿ¥! üéÜ',
                        'ÿ£ŸÜÿ™ ÿ≥ÿ±Ÿäÿπ ÿ¨ÿØÿßŸã! ÿßÿ≥ÿ™ŸÖÿ± ŸáŸÉÿ∞ÿß! üöÄ'
                    ],
                    'racket': [
                        'ŸÖŸÖÿ™ÿßÿ≤! ÿØŸÇÿ™ŸÉ Ÿàÿ™ÿ±ŸÉŸäÿ≤ŸÉ ÿ±ÿßÿ¶ÿπŸäŸÜ! üè∏',
                        'ÿ±ÿßÿ¶ÿπ! ŸÑÿπÿ® ŸÖÿ™ŸÇŸÜ! üèÜ',
                        'ÿ£ÿ≠ÿ≥ŸÜÿ™! ŸÖŸáÿßÿ±ÿßÿ™ŸÉ ÿ™ÿ™ÿ∑Ÿàÿ±! ‚≠ê',
                        'ÿ£ŸÜÿ™ ŸÑÿßÿπÿ® ŸÖÿ≠ÿ™ÿ±ŸÅ! üéæ'
                    ],
                    'memory': [
                        'ÿπÿ®ŸÇÿ±Ÿä! ÿ∞ÿßŸÉÿ±ÿ™ŸÉ ŸÇŸàŸäÿ© ÿ¨ÿØÿßŸã! üß†',
                        'ÿ±ÿßÿ¶ÿπ! ÿ™ÿ∞ŸÉÿ± ÿ®ÿ¥ŸÉŸÑ ŸÖŸÖÿ™ÿßÿ≤! ‚ú®',
                        'ŸÖÿß ÿ¥ÿßÿ° ÿßŸÑŸÑŸá! ÿ∞ÿßŸÉÿ±ÿ© ÿ≠ÿØŸäÿØŸäÿ©! üíé',
                        'ÿ£ŸÜÿ™ ÿ∞ŸÉŸä ÿ¨ÿØÿßŸã! üéì'
                    ],
                    'wordsearch': [
                        'ÿ£ÿ≠ÿ≥ŸÜÿ™! ÿπŸäŸÜÿßŸÉ ŸÉÿßŸÑÿµŸÇÿ±! ü¶Ö',
                        'ÿ±ÿßÿ¶ÿπ! Ÿàÿ¨ÿØÿ™ ŸÉŸÑ ÿßŸÑŸÉŸÑŸÖÿßÿ™! üîç',
                        'ŸÖŸÖÿ™ÿßÿ≤! ŸÇŸàÿ© ŸÖŸÑÿßÿ≠ÿ∏ÿ© ÿπÿßŸÑŸäÿ©! üëÄ'
                    ]
                };
                
                const gameMessages = messages[gameName] || ['ÿ£ÿ≠ÿ≥ŸÜÿ™! ÿßÿ≥ÿ™ŸÖÿ± ŸÅŸä ÿßŸÑÿ™ŸÇÿØŸÖ! üéâ', 'ÿπŸÖŸÑ ÿ±ÿßÿ¶ÿπ! üåü', 'ÿ£ŸÜÿ™ ŸÖÿ®ÿØÿπ! ‚ú®'];
                const randomMessage = gameMessages[Math.floor(Math.random() * gameMessages.length)];
                
                this.showToast(randomMessage, 4000, 'success');
            }
            
            showWinGame() {
                // Prevent multiple calls
                if (this.isGameEnding) return;
                this.isGameEnding = true;
                
                // Stop the game immediately
                this.gameRunning = false;
                
                const currentLetter = LETTERS[this.currentLetterIndex];
                this.markGameCompleted(currentLetter, this.currentGame);

                // Clean up game resources first
                this.cleanupGameResources();
                
                // Launch celebration
                this.launchBalloonsCelebration();
                this.soundManager.playSound('applause');

                // Prepare Victory Screen Content
                const gameNames = {
                    'match': 'ŸÑÿπÿ®ÿ© ÿßŸÑŸÖÿ∑ÿßÿ®ŸÇÿ©',
                    'balloons': 'ŸÑÿπÿ®ÿ© ÿßŸÑÿ®ÿßŸÑŸàŸÜÿßÿ™',
                    'memory': 'ŸÑÿπÿ®ÿ© ÿßŸÑÿ∞ÿßŸÉÿ±ÿ©',
                    'carRace': 'ÿ≥ÿ®ÿßŸÇ ÿßŸÑÿ≥Ÿäÿßÿ±ÿßÿ™',
                    'racket': 'ŸÑÿπÿ®ÿ© ÿßŸÑŸÖÿ∂ÿ±ÿ®',
                    'shooting': 'ÿßÿµÿ∑ŸäÿßÿØ ÿßŸÑÿ≠ÿ±ŸÅ',
                    'search': 'ŸÑÿπÿ®ÿ© ÿßŸÑÿ®ÿ≠ÿ´',
                    'typing': 'ÿßŸÑŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿ≥ÿ±Ÿäÿπÿ©'
                };

                const motivationalMessages = [
                    "ÿ£ŸÜÿ™ ÿ®ÿ∑ŸÑ ÿ≠ŸÇŸäŸÇŸä! üåü",
                    "ÿ£ÿØÿßÿ° ŸÖÿ∞ŸáŸÑ! ÿßÿ≥ÿ™ŸÖÿ± ŸÅŸä ÿßŸÑÿ™ÿ£ŸÑŸÇ! ‚ú®",
                    "ÿ±ÿßÿ¶ÿπ! ÿ£ŸÜÿ™ ÿ™ÿ™ŸÇÿØŸÖ ÿ®ÿ≥ÿ±ÿπÿ©! üöÄ",
                    "ŸÖŸÖÿ™ÿßÿ≤! ÿ∞ŸÉÿßÿ§ŸÉ Ÿäÿ®Ÿáÿ±ŸÜÿß! üí°",
                    "ÿπŸÖŸÑ ÿ±ÿßÿ¶ÿπ! ÿßŸÑŸÖÿ≥ÿ™ŸÇÿ®ŸÑ ÿ®ÿßŸÜÿ™ÿ∏ÿßÿ±ŸÉ! üéì",
                    "ÿ£ŸÜÿ™ ŸÜÿ¨ŸÖ ÿ≥ÿßÿ∑ÿπ ŸÅŸä ÿ≥ŸÖÿßÿ° ÿßŸÑÿπŸÑŸÖ! ‚≠ê",
                    "ÿ•ŸÜÿ¨ÿßÿ≤ ÿ±ÿßÿ¶ÿπ! ŸÜÿ≠ŸÜ ŸÅÿÆŸàÿ±ŸàŸÜ ÿ®ŸÉ! üèÜ",
                    "ÿ∞ŸÉÿßÿ° ÿÆÿßÿ±ŸÇ! ÿßÿ≥ÿ™ŸÖÿ± ŸÅŸä ÿßŸÑÿ•ÿ®ÿØÿßÿπ! üß†"
                ];
                const randomMsg = motivationalMessages[Math.floor(Math.random() * motivationalMessages.length)];

                // Check remaining games
                this.updateLetterExerciseProgress(currentLetter);
                const missingGames = this.getMissingRequiredGames(currentLetter);
                
                let nextStepsHtml = '';
                if (missingGames.length > 0) {
                    const missingNames = missingGames.map(g => `<li>${gameNames[g] || g}</li>`).join('');
                    nextStepsHtml = `
                        <div style="margin-top: 20px; background: #f0f9ff; padding: 15px; border-radius: 10px; border: 2px solid #bae6fd;">
                            <h4 style="color: #0284c7; margin-bottom: 10px;">ÿßŸÑÿ£ŸÑÿπÿßÿ® ÿßŸÑŸÖÿ™ÿ®ŸÇŸäÿ© ŸÑÿ•ŸÉŸÖÿßŸÑ ÿßŸÑÿ≠ÿ±ŸÅ:</h4>
                            <ul style="list-style: none; padding: 0; color: #0369a1; font-weight: bold;">
                                ${missingNames}
                            </ul>
                        </div>
                    `;
                } else {
                    nextStepsHtml = `
                        <div style="margin-top: 20px; background: #dcfce7; padding: 15px; border-radius: 10px; border: 2px solid #86efac;">
                            <h4 style="color: #15803d; margin: 0;">üéâ ŸÖÿ®ÿ±ŸàŸÉ! ŸÑŸÇÿØ ÿ£ŸÉŸÖŸÑÿ™ ÿ¨ŸÖŸäÿπ ÿ£ŸÑÿπÿßÿ® Ÿáÿ∞ÿß ÿßŸÑÿ≠ÿ±ŸÅ!</h4>
                        </div>
                    `;
                }

                // Update Modal Content
                const modalContent = this.gameModal.querySelector('.game-modal-content');
                modalContent.innerHTML = `
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 60px; margin-bottom: 10px;">üèÜ</div>
                        <h2 style="color: #f59e0b; font-size: 28px; margin-bottom: 10px;">${randomMsg}</h2>
                        <p style="color: #64748b; font-size: 18px;">ŸÑŸÇÿØ ŸÅÿ≤ÿ™ ŸÅŸä ${gameNames[this.currentGame] || 'ÿßŸÑŸÑÿπÿ®ÿ©'}!</p>
                        
                        ${nextStepsHtml}
                        
                        <button id="backToGamesBtn" style="
                            margin-top: 25px;
                            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
                            color: white;
                            border: none;
                            padding: 12px 30px;
                            font-size: 18px;
                            border-radius: 50px;
                            cursor: pointer;
                            box-shadow: 0 4px 15px rgba(79, 70, 229, 0.4);
                            transition: transform 0.2s;
                        ">ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑÿ£ŸÑÿπÿßÿ® üéÆ</button>
                    </div>
                `;

                // Add event listener to the new button
                document.getElementById('backToGamesBtn').addEventListener('click', () => {
                    this.gameModal.style.display = 'none';
                    this.showGames(); // Return to games list
                });

                // Reset game ending flag
                setTimeout(() => {
                    this.isGameEnding = false;
                }, 1000);
            }
            
            showWinModal() {
                const score = parseInt(this.gameScoreEl.textContent);
                const timeLeft = this.gameTimeLeft;
                const accuracy = this.gameStats.accuracy;
                
                this.finalScoreEl.textContent = score;
                this.finalTimeEl.textContent = timeLeft;
                this.finalAccuracyEl.textContent = `${accuracy}%`;
                
                const winMessages = [
                    "ÿ≥ŸÑŸÖÿ™ Ÿäÿßÿ®ÿ∑ŸÑ! üî• ÿ£ŸÜÿ™ ŸÜÿ¨ŸÖ ÿßŸÑŸÖÿ≥ÿ™ŸÇÿ®ŸÑ!",
                    "ŸÖÿ∞ŸáŸÑ! ŸÖŸáÿßÿ±ÿßÿ™ŸÉ ŸÑÿß ÿ™ÿµÿØŸÇ! ‚ú®",
                    "ÿ•ÿ™ŸÇÿßŸÜ ÿ±ÿßÿ¶ÿπ! ÿ£ŸÜÿ™ ÿ®ÿ∑ŸÑ ÿßŸÑÿ≠ÿ±ŸàŸÅ! üèÜ",
                    "ÿ£ÿØÿßÿ° ŸÖÿ™ŸÖŸäÿ≤! ÿ™ÿ≥ÿ™ÿ≠ŸÇ ŸÉŸÑ ÿßŸÑÿ™ŸÇÿØŸäÿ±! ‚≠ê",
                    "ÿ®ÿ±ÿßÿπÿ© ŸÅÿßÿ¶ŸÇÿ©! ÿ£ŸÜÿ™ ŸÖÿ™ÿπŸÑŸÖ ŸÖŸÖÿ™ÿßÿ≤! üí´"
                ];
                
                const fireworkEmojis = ["üéÜ", "üéá", "‚ú®", "üåü", "üí•", "üî•", "‚≠ê", "‚ö°"];
                
                this.winTitle.textContent = winMessages[Math.floor(Math.random() * winMessages.length)];
                this.winSubtitle.textContent = `ÿ≠ŸÇŸÇÿ™ ${score} ŸÜŸÇÿ∑ÿ© ÿ®ÿØŸÇÿ© ${accuracy}%`;
                this.winAnimation.textContent = fireworkEmojis[Math.floor(Math.random() * fireworkEmojis.length)] + 
                                               fireworkEmojis[Math.floor(Math.random() * fireworkEmojis.length)] + 
                                               fireworkEmojis[Math.floor(Math.random() * fireworkEmojis.length)];
                
                this.winModal.style.display = 'flex';
                this.soundManager.playSound('fireworks');
            }
            
            endGame() {
                clearInterval(this.gameInterval);
                
                const canvas = this.gameCanvas;
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#4cc9f0');
                gradient.addColorStop(1, '#4895ef');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 36px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('ÿßŸÜÿ™ŸáŸâ ÿßŸÑŸàŸÇÿ™!', canvas.width / 2, canvas.height / 2 - 30);
                ctx.font = '24px Arial';
                ctx.fillText(`ÿßŸÑŸÜŸÇÿßÿ∑ ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ©: ${this.gameScoreEl.textContent}`, canvas.width / 2, canvas.height / 2 + 30);
                
                const finalScore = parseInt(this.gameScoreEl.textContent);
                let message = 'ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ!';
                if (finalScore >= 50) message = 'ŸÖÿ∞ŸáŸÑ! ÿ£ÿØÿßÿ° ÿ±ÿßÿ¶ÿπ!';
                else if (finalScore >= 30) message = 'ÿ¨ŸäÿØ ÿ¨ÿØÿßŸã!';
                else if (finalScore >= 15) message = 'ŸÑŸäÿ≥ ÿ≥Ÿäÿ¶ÿßŸã!';
                
                ctx.font = '20px Arial';
                ctx.fillText(message, canvas.width / 2, canvas.height / 2 + 70);
                
                this.soundManager.playSound('success');
            }
            
            closeGame() {
                // Ensure cleanup happens
                this.gameRunning = false;
                this.isGameEnding = false;
                
                // Hide modals
                this.gameModal.style.display = 'none';
                this.winModal.style.display = 'none';
                
                // Comprehensive cleanup
                this.cleanupGameResources();
                
                // Clear canvas
                const canvas = this.gameCanvas;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Reset game state
                this.currentGame = null;
                this.gameObjects = [];
                
                this.isPaused = false;
                this.pauseGameBtn.innerHTML = '<span>‚è∏Ô∏è</span> ÿ•ŸäŸÇÿßŸÅ';
                
                // Force garbage collection hint
                if (window.gc) {
                    window.gc();
                }
            }
            
            togglePause() {
                this.isPaused = !this.isPaused;
                this.pauseGameBtn.innerHTML = this.isPaused ? 
                    '<span>‚ñ∂Ô∏è</span> ÿßÿ≥ÿ™ŸÖÿ±ÿßÿ±' : 
                    '<span>‚è∏Ô∏è</span> ÿ•ŸäŸÇÿßŸÅ';
            }
            
            restartGame() {
                const gameToRestart = this.currentGame;
                this.closeGame();
                setTimeout(() => {
                    this.startGame(gameToRestart);
                }, 100);
            }
            
            playAgain() {
                this.winModal.style.display = 'none';
                this.restartGame();
            }
            
            backToGames() {
                this.winModal.style.display = 'none';
                this.closeGame();
                this.motivationModal.style.display = 'flex';
            }
            
            showCertificate() {
                // Check if all letters are truly completed
                if (this.completedLetters.length !== LETTERS.length) {
                    this.showToast('Ÿäÿ¨ÿ® ÿ•ŸÉŸÖÿßŸÑ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ≠ÿ±ŸàŸÅ ÿ£ŸàŸÑÿßŸã!');
                    return;
                }
                
                // Calculate total stars/points
                const totalStars = this.calculateTotalStars();
                const completionDate = new Date().toLocaleDateString('ar-SA');
                
                // Update certificate content
                this.certificateName.textContent = this.studentName || 'ÿßŸÑÿ∑ÿßŸÑÿ® ÿßŸÑŸÖÿ™ŸÖŸäÿ≤';
                document.getElementById('certificate-date').textContent = completionDate;
                document.getElementById('certificate-stars').textContent = totalStars;
                document.getElementById('certificate-letters-count').textContent = LETTERS.length;
                
                this.certificateModal.style.display = 'flex';
                
                // Save achievement
                localStorage.setItem('certificateEarned', 'true');
                localStorage.setItem('certificateDate', completionDate);
                localStorage.setItem('certificateStars', totalStars);
                this.soundManager.playSound('win');
            }
            
            calculateTotalStars() {
                let totalStars = 0;
                LETTERS.forEach(letter => {
                    const letterGames = this.passedGames[letter] || [];
                    totalStars += letterGames.length;
                });
                return totalStars;
            }
            
            printCertificate() {
                // Hide modal temporarily for clean print
                const modal = this.certificateModal;
                const originalDisplay = modal.style.display;
                modal.style.display = 'none';
                
                // Show only certificate content
                const certificate = document.querySelector('.certificate-content');
                const originalBody = document.body.innerHTML;
                
                document.body.innerHTML = certificate.outerHTML;
                window.print();
                
                // Restore original content
                document.body.innerHTML = originalBody;
                this.init(); // Re-initialize the app
                modal.style.display = originalDisplay;
            }

            sendCertificateEmail() {
                const email = prompt('ÿ£ÿØÿÆŸÑ ÿπŸÜŸàÿßŸÜ ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä:');
                if (!email) return;
                
                // Generate email content
                const subject = `ÿ¥ŸáÿßÿØÿ© ÿ•ÿ™ŸÇÿßŸÜ ÿßŸÑÿ≠ÿ±ŸàŸÅ ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ© - ${this.studentName}`;
                const body = `ÿ™ŸáÿßŸÜŸäŸÜÿß! ŸÑŸÇÿØ ÿ£ŸÉŸÖŸÑ ${this.studentName} ÿ¨ŸÖŸäÿπ ÿßŸÑÿ≠ÿ±ŸàŸÅ ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ© ÿ®ŸÜÿ¨ÿßÿ≠!\n\nÿπÿØÿØ ÿßŸÑŸÜÿ¨ŸàŸÖ ÿßŸÑŸÖÿ≠ÿµŸÑ ÿπŸÑŸäŸáÿß: ${this.calculateTotalStars()}\nÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ•ŸÜÿ¨ÿßÿ≤: ${new Date().toLocaleDateString('ar-SA')}`;
                
                // Open email client
                const mailtoLink = `mailto:${email}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
                window.open(mailtoLink);
                
                this.showToast('ÿ™ŸÖ ŸÅÿ™ÿ≠ ÿ®ÿ±ŸÜÿßŸÖÿ¨ ÿßŸÑÿ®ÿ±ŸäÿØ ŸÑÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ¥ŸáÿßÿØÿ©', 3000, 'success');
            }

            sendCertificateWhatsApp() {
                const phone = prompt('ÿ£ÿØÿÆŸÑ ÿ±ŸÇŸÖ ÿßŸÑŸàÿßÿ™ÿ≥ÿßÿ® (ŸÖÿπ ÿ±ŸÖÿ≤ ÿßŸÑÿØŸàŸÑÿ©):');
                if (!phone) return;
                
                const message = `üéâ ÿ™ŸáÿßŸÜŸäŸÜÿß! ŸÑŸÇÿØ ÿ£ŸÉŸÖŸÑ ${this.studentName} ÿ¨ŸÖŸäÿπ ÿßŸÑÿ≠ÿ±ŸàŸÅ ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ© ÿ®ŸÜÿ¨ÿßÿ≠! \n\n‚≠ê ÿπÿØÿØ ÿßŸÑŸÜÿ¨ŸàŸÖ: ${this.calculateTotalStars()} \nüìÖ ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ•ŸÜÿ¨ÿßÿ≤: ${new Date().toLocaleDateString('ar-SA')} \n\nüéì ÿ¥ŸáÿßÿØÿ© ÿ•ÿ™ŸÇÿßŸÜ ÿßŸÑÿ≠ÿ±ŸàŸÅ ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ©`;
                
                const whatsappLink = `https://wa.me/${phone.replace(/[^\d]/g, '')}?text=${encodeURIComponent(message)}`;
                window.open(whatsappLink, '_blank');
                
                this.showToast('ÿ™ŸÖ ŸÅÿ™ÿ≠ Ÿàÿßÿ™ÿ≥ÿßÿ® ŸÑŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑÿ¥ŸáÿßÿØÿ©', 3000, 'success');
            }
            
            showCompletionAnimation() {
                for (let i = 0; i < 150; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.animationDuration = (Math.random() * 3 + 2) + 's';
                    confetti.style.animationDelay = Math.random() * 5 + 's';
                    confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 70%, 60%)`;
                    
                    this.completionAnimation.appendChild(confetti);
                }
                
                setTimeout(() => {
                    this.completionAnimation.innerHTML = '';
                }, 7000);
            }
            
            setupScrollTop() {
                window.addEventListener('scroll', () => {
                    if (window.pageYOffset > 300) {
                        this.scrollTopBtn.classList.add('visible');
                    } else {
                        this.scrollTopBtn.classList.remove('visible');
                    }
                });
                
                this.scrollTopBtn.addEventListener('click', () => {
                    window.scrollTo({
                        top: 0,
                        behavior: 'smooth'
                    });
                });
            }
            
            disableCopyPaste() {
                document.addEventListener('contextmenu', (e) => {
                    if (e.target.classList.contains('writing-box') || 
                        e.target.classList.contains('word-input')) {
                        e.preventDefault();
                        this.showToast('ŸÑÿß Ÿäÿ≥ŸÖÿ≠ ÿ®ÿßŸÑŸÜÿ≥ÿÆ ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑÿ™ŸÖÿ±ŸäŸÜ', 2000);
                    }
                });
                
                document.addEventListener('dragstart', (e) => {
                    if (e.target.classList.contains('writing-box') || 
                        e.target.classList.contains('word-input')) {
                        e.preventDefault();
                    }
                });
            }
            
            disableCopyPasteForElement(element) {
                element.addEventListener('copy', (e) => {
                    e.preventDefault();
                    this.showToast('ŸÑÿß Ÿäÿ≥ŸÖÿ≠ ÿ®ÿßŸÑŸÜÿ≥ÿÆ ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑÿ™ŸÖÿ±ŸäŸÜ', 2000);
                });
                
                element.addEventListener('paste', (e) => {
                    e.preventDefault();
                    this.showToast('ŸÑÿß Ÿäÿ≥ŸÖÿ≠ ÿ®ÿßŸÑŸÑÿµŸÇ ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑÿ™ŸÖÿ±ŸäŸÜ', 2000);
                });
                
                element.addEventListener('cut', (e) => {
                    e.preventDefault();
                    this.showToast('ŸÑÿß Ÿäÿ≥ŸÖÿ≠ ÿ®ÿßŸÑŸÇÿµ ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑÿ™ŸÖÿ±ŸäŸÜ', 2000);
                });
                
                element.addEventListener('dragstart', (e) => {
                    e.preventDefault();
                });
                
                element.addEventListener('drop', (e) => {
                    e.preventDefault();
                    this.showToast('ŸÑÿß Ÿäÿ≥ŸÖÿ≠ ÿ®ÿßŸÑÿ≥ÿ≠ÿ® ŸàÿßŸÑÿ•ŸÅŸÑÿßÿ™ ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑÿ™ŸÖÿ±ŸäŸÜ', 2000);
                });
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new PhonicsGameLab();
            
            // Setup scroll arrows for games grid
            const gamesGrid = document.getElementById('gamesGrid');
            const scrollUpBtn = document.getElementById('scrollUpBtn');
            const scrollDownBtn = document.getElementById('scrollDownBtn');
            
            if (gamesGrid && scrollUpBtn && scrollDownBtn) {
                // Scroll up
                scrollUpBtn.addEventListener('click', () => {
                    gamesGrid.scrollBy({
                        top: -150, // Scroll up by 150px
                        behavior: 'smooth'
                    });
                });
                
                // Scroll down
                scrollDownBtn.addEventListener('click', () => {
                    gamesGrid.scrollBy({
                        top: 150, // Scroll down by 150px
                        behavior: 'smooth'
                    });
                });
                
                // Update button states based on scroll position
                const updateScrollButtons = () => {
                    const scrollTop = gamesGrid.scrollTop;
                    const scrollHeight = gamesGrid.scrollHeight;
                    const clientHeight = gamesGrid.clientHeight;
                    
                    // Disable scroll up if at top
                    scrollUpBtn.disabled = scrollTop <= 0;
                    
                    // Disable scroll down if at bottom
                    scrollDownBtn.disabled = scrollTop + clientHeight >= scrollHeight - 5;
                };
                
                // Initial check
                updateScrollButtons();
                
                // Update on scroll
                gamesGrid.addEventListener('scroll', updateScrollButtons);
                
                // Update on resize
                window.addEventListener('resize', updateScrollButtons);
            }
            
            // Improve game card click detection - prevent accidental taps
            document.querySelectorAll('.game-card').forEach(card => {
                let touchStartTime = 0;
                let touchStartY = 0;
                
                card.addEventListener('touchstart', (e) => {
                    touchStartTime = Date.now();
                    touchStartY = e.touches[0].clientY;
                }, { passive: true });
                
                card.addEventListener('touchend', (e) => {
                    const touchDuration = Date.now() - touchStartTime;
                    const touchEndY = e.changedTouches[0].clientY;
                    const touchMoveDistance = Math.abs(touchEndY - touchStartY);
                    
                    // Only trigger if:
                    // 1. Touch duration is reasonable (not too quick)
                    // 2. Touch didn't move much (not a scroll)
                    if (touchDuration > 50 && touchDuration < 500 && touchMoveDistance < 10) {
                        // Valid tap - the default click handler will fire
                    } else {
                        // Invalid tap - prevent click
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }, { passive: false });
            });
        });
    </script>
<script>
function postProgress(letter, score, student) {
    fetch("/api/save-progress/", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({
            letter: letter,
            score: score,
            student: student
        })
    })
    .then(res => res.json())
    .then(r => console.log("Saved:", r));
}


// ÿ•ÿ±ÿ≥ÿßŸÑ ÿµŸàÿ™ ŸÑŸÑÿ®ÿßŸÉŸÜÿØ
function sendAudioToServer(blob, letter){
    let form = new FormData();
    form.append("audio", blob);
    form.append("letter", letter);

    fetch("/api/speech/", {
        method: "POST",
        body: form
    })
    .then(res => res.json())
    .then(res => console.log("Speech:", res));
}
</script>
    <!-- AI Assistant -->
    <div id="ai-assistant-container">
        <!-- Floating Button -->
        <button id="ai-btn" class="ai-float-btn" onclick="toggleAI()">
            <!-- New colorful robot image -->
            <img src="https://img.freepik.com/free-vector/cute-robot-mascot-logo-cartoon-character-illustration_138676-2067.jpg" alt="AI" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover;">
            <span class="pulse-ring"></span>
        </button>

        <!-- Chat Box -->
        <div id="ai-chat-box" class="ai-chat-box">
            <div class="ai-header">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <div style="width: 35px; height: 35px; background: white; border-radius: 50%; overflow: hidden;">
                        <img src="https://img.freepik.com/free-vector/cute-robot-mascot-logo-cartoon-character-illustration_138676-2067.jpg" style="width: 100%; height: 100%; object-fit: cover;">
                    </div>
                    <span>ÿßŸÑŸÖÿ≥ÿßÿπÿØ ÿßŸÑÿ∞ŸÉŸä</span>
                </div>
                <button onclick="toggleAI()" style="background: none; border: none; color: white; cursor: pointer; font-size: 1.2rem;">‚úñ</button>
            </div>
            <div class="ai-body" id="ai-chat-body">
                <div class="ai-msg bot">
                    ŸÖÿ±ÿ≠ÿ®ÿßŸã ÿ®ŸÉ! üëã
                    <br>
                    ÿ£ŸÜÿß ÿµÿØŸäŸÇŸÉ ÿßŸÑÿ±Ÿàÿ®Ÿàÿ™ ÿßŸÑÿ∞ŸÉŸä ŸÅŸä ŸÖŸÜÿµÿ© ÿßŸÑÿ≠ÿ±ŸàŸÅ. ü§ñ
                    <br>
                    ŸäŸÖŸÉŸÜŸÉ ÿ≥ÿ§ÿßŸÑŸä ÿπŸÜ ÿßŸÑÿØÿ±Ÿàÿ≥ÿå ÿßŸÑÿ£ŸÑÿπÿßÿ®ÿå ÿ£Ÿà ÿßŸÑÿ≠ŸäŸàÿßŸÜÿßÿ™!
                </div>
            </div>
            <div class="ai-footer">
                <input type="text" id="ai-user-input" placeholder="ÿßŸÉÿ™ÿ® ÿ≥ÿ§ÿßŸÑŸÉ ŸáŸÜÿß..." style="width: 100%; padding: 10px; border-radius: 20px; border: 1px solid #ddd; outline: none;">
                <button id="ai-send-btn" onclick="sendMessage()" style="background: var(--primary); color: white; border: none; padding: 10px 15px; border-radius: 50%; margin-right: 5px; cursor: pointer; min-width: 45px;">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>

    <style>
        .ai-float-btn {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: white;
            border: 2px solid white;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            cursor: pointer;
            z-index: 9999;
            padding: 0;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            overflow: visible;
        }

        .ai-float-btn:hover {
            transform: scale(1.1) rotate(5deg);
        }

        .pulse-ring {
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            border-radius: 50%;
            border: 3px solid var(--primary);
            animation: pulse 2s infinite;
            z-index: -1;
        }

        @keyframes pulse {
            0% { transform: scale(0.95); opacity: 0.8; }
            100% { transform: scale(1.4); opacity: 0; }
        }

        .ai-chat-box {
            position: fixed;
            bottom: 100px;
            left: 30px;
            width: 320px;
            height: 450px;
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
            display: none;
            flex-direction: column;
            z-index: 9999;
            overflow: hidden;
            border: 1px solid rgba(0,0,0,0.05);
            animation: slideUp 0.4s ease;
        }

        .ai-chat-box.active {
            display: flex;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .ai-header {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            padding: 15px;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
        }

        .ai-body {
            flex: 1;
            padding: 15px;
            background: #f8f9fa;
            overflow-y: auto;
            direction: rtl;
        }

        .ai-msg {
            max-width: 80%;
            padding: 10px 15px;
            border-radius: 15px;
            margin-bottom: 15px;
            font-size: 0.95rem;
            line-height: 1.5;
            position: relative;
            word-wrap: break-word;
        }

        .ai-msg.bot {
            background: white;
            color: #333;
            border-bottom-right-radius: 2px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            margin-left: auto;
        }

        .ai-msg.user {
            background: var(--primary);
            color: white;
            border-bottom-left-radius: 2px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-right: auto;
        }

        .ai-footer {
            padding: 10px;
            background: white;
            border-top: 1px solid #eee;
            display: flex;
            align-items: center;
        }
        
        .typing-indicator {
            display: inline-block;
            padding: 5px 10px;
            background: white;
            border-radius: 15px;
            margin-left: auto;
            margin-bottom: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .typing-dot {
            display: inline-block;
            width: 6px;
            height: 6px;
            background: #999;
            border-radius: 50%;
            margin: 0 2px;
            animation: typing 1.4s infinite;
        }
        
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes typing {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
    </style>

    <script>
        function toggleAI() {
            const chatBox = document.getElementById('ai-chat-box');
            chatBox.classList.toggle('active');
            if (chatBox.classList.contains('active')) {
                document.getElementById('ai-user-input').focus();
            }
        }

        document.getElementById('ai-user-input').addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        function sendMessage() {
            const inputField = document.getElementById('ai-user-input');
            const message = inputField.value.trim();
            
            if (message === "") return;
            
            // Add User Message
            addMessage(message, 'user');
            inputField.value = '';
            
            // Show Typing Indicator
            showTyping();
            
            // Simple Bot Logic (Simulation)
            setTimeout(() => {
                removeTyping();
                const response = getBotResponse(message);
                addMessage(response, 'bot');
            }, 1000);
        }

        function addMessage(text, sender) {
            const chatBody = document.getElementById('ai-chat-body');
            const msgDiv = document.createElement('div');
            msgDiv.classList.add('ai-msg', sender);
            msgDiv.innerHTML = text; // Using innerHTML to allow <br> or formatting
            chatBody.appendChild(msgDiv);
            chatBody.scrollTop = chatBody.scrollHeight;
        }
        
        function showTyping() {
            const chatBody = document.getElementById('ai-chat-body');
            const typingDiv = document.createElement('div');
            typingDiv.id = 'ai-typing';
            typingDiv.className = 'typing-indicator';
            typingDiv.innerHTML = '<span class="typing-dot"></span><span class="typing-dot"></span><span class="typing-dot"></span>';
            chatBody.appendChild(typingDiv);
            chatBody.scrollTop = chatBody.scrollHeight;
        }
        
        function removeTyping() {
            const typingDiv = document.getElementById('ai-typing');
            if (typingDiv) typingDiv.remove();
        }

        function getBotResponse(input) {
            input = input.toLowerCase();
            
            // Greetings
            if (input.includes('ŸÖÿ±ÿ≠ÿ®ÿß') || input.includes('ŸáŸÑÿß') || input.includes('ÿ≥ŸÑÿßŸÖ') || input.includes('hi') || input.includes('hello')) {
                return "ÿ£ŸáŸÑÿßŸã ÿ®ŸÉ Ÿäÿß ÿ®ÿ∑ŸÑ! üåü ÿ£ŸÜÿß ŸáŸÜÿß ŸÑŸÖÿ≥ÿßÿπÿØÿ™ŸÉ ŸÅŸä ÿ±ÿ≠ŸÑÿ© ÿßŸÑÿ™ÿπŸÑŸÖ ÿßŸÑŸÖŸÖÿ™ÿπÿ©. ŸÖÿßÿ∞ÿß ÿ™ÿ±ŸäÿØ ÿ£ŸÜ ÿ™ÿ™ÿπŸÑŸÖ ÿßŸÑŸäŸàŸÖÿü";
            }
            
            // Usage / How to
            if (input.includes('ŸÉŸäŸÅ') || input.includes('ÿßÿ≥ÿ™ÿÆÿØŸÖ') || input.includes('ÿπŸÖŸÑ') || input.includes('ÿßÿπŸÖŸÑ') || input.includes('how')) {
                return "ÿßŸÑÿ£ŸÖÿ± ÿ®ÿ≥Ÿäÿ∑ ÿ¨ÿØÿßŸã! üß©<br>1Ô∏è‚É£ ÿßÿÆÿ™ÿ± ÿ≠ÿ±ŸÅÿßŸã ÿ£Ÿà ÿØÿ±ÿ≥ÿßŸã ŸÖŸÜ ÿßŸÑŸÇÿßÿ¶ŸÖÿ©.<br>2Ô∏è‚É£ ÿßÿ≥ÿ™ŸÖÿ™ÿπ ÿ®ÿßŸÑÿ£ŸÑÿπÿßÿ® ŸàÿßŸÑÿ£ŸÜÿ¥ÿ∑ÿ© ÿßŸÑÿ™ŸÅÿßÿπŸÑŸäÿ©.<br>3Ô∏è‚É£ ÿ¨ŸÖÿπ ÿßŸÑŸÜŸÇÿßÿ∑ Ÿàÿßÿ≠ÿµŸÑ ÿπŸÑŸâ ÿßŸÑÿ¥ŸáÿßÿØÿßÿ™! üèÜ<br>ÿßÿ®ÿØÿ£ ÿ®ÿßÿÆÿ™Ÿäÿßÿ± ÿ≠ÿ±ŸÅ ŸÖŸÜ ÿßŸÑÿ£ÿπŸÑŸâ!";
            }
            
            // Grade 2 Specific
            if (input.includes('ÿ´ÿßŸÜŸä') || input.includes('ÿ≠ŸäŸàÿßŸÜÿßÿ™') || input.includes('wild') || input.includes('animals')) {
                return "ÿØÿ±ÿ≥ ÿßŸÑÿ≠ŸäŸàÿßŸÜÿßÿ™ ÿßŸÑÿ®ÿ±Ÿäÿ© ü¶Å ŸÑŸÑÿµŸÅ ÿßŸÑÿ´ÿßŸÜŸä ŸÖŸàÿ¨ŸàÿØ ŸÅŸä ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ¨ÿßŸÜÿ®Ÿäÿ© (ÿ£Ÿà ÿßŸÑÿ≤ÿ± ÿßŸÑÿπÿßÿ¶ŸÖ). ŸÅŸäŸá ÿ£ŸÑÿπÿßÿ® ŸÖŸÖÿ™ÿπÿ© ŸÖÿ´ŸÑ 'Animal Chart' Ÿà 'Guessing Game'!";
            }
            
            // General Help
            if (input.includes('ŸÖÿ≥ÿßÿπÿØÿ©') || input.includes('help')) {
                return "ÿ£ŸÉŸäÿØ! ŸÑÿØŸäŸÉ ŸÇÿßÿ¶ŸÖÿ© ÿ®ÿßŸÑÿ≠ÿ±ŸàŸÅ ŸÅŸä ÿßŸÑÿ£ÿπŸÑŸâÿå ŸàŸÇÿßÿ¶ŸÖÿ© ÿ®ÿßŸÑÿµŸÅŸàŸÅ ŸÅŸä ÿßŸÑÿ¨ÿßŸÜÿ®. ÿßÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ ÿ£Ÿä ŸÖŸÜŸáÿß ŸÑÿ™ÿ®ÿØÿ£.";
            }

            // Games
            if (input.includes('ŸÑÿπÿ®ÿ©') || input.includes('game') || input.includes('ŸÑÿπÿ®')) {
                return "ŸÜÿ≠ŸÜ ŸÜÿ≠ÿ® ÿßŸÑŸÑÿπÿ®! üéÆ ŸÉŸÑ ÿ≠ÿ±ŸÅ ŸàÿØÿ±ÿ≥ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ÿ£ŸÑÿπÿßÿ® ŸÖŸÖÿ™ÿπÿ©. ÿ¨ÿ±ÿ® ÿØÿ±ÿ≥ ÿßŸÑÿ≠ŸäŸàÿßŸÜÿßÿ™ ŸÑŸÑÿπÿ® 'Find the Animal'!";
            }
            
            // Thanks/Bye
            if (input.includes('ÿ¥ŸÉÿ±ÿß') || input.includes('ÿ¥ŸÉÿ±ÿßŸã') || input.includes('thanks')) {
                return "ÿπŸÅŸàÿßŸã Ÿäÿß ÿ®ÿ∑ŸÑ! ÿßÿ≥ÿ™ŸÖÿ™ÿπ ÿ®ŸàŸÇÿ™ŸÉ! üéà";
            }
            if (input.includes('ÿ®ÿßŸä') || input.includes('ŸÖÿπ ÿßŸÑÿ≥ŸÑÿßŸÖÿ©')) {
                return "ÿ•ŸÑŸâ ÿßŸÑŸÑŸÇÿßÿ°! ŸÜÿ±ÿßŸÉ ŸÇÿ±Ÿäÿ®ÿßŸã! üëã";
            }
            
            // Default Fallback
            return "ÿ≥ÿ§ÿßŸÑ ÿ¨ŸÖŸäŸÑ! üòä<br>ŸäŸÖŸÉŸÜŸÉ ÿ™ÿ¨ÿ±ÿ®ÿ© ÿßŸÑÿØÿ±Ÿàÿ≥ ÿßŸÑŸÖŸàÿ¨ŸàÿØÿ© ŸÅŸä ÿßŸÑÿµŸÅÿ≠ÿ©ÿå ÿ£Ÿà ÿ≥ÿ§ÿßŸÑŸä ÿπŸÜ 'ŸÉŸäŸÅ ÿ£ÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÖŸàŸÇÿπ' ÿ£Ÿà 'ÿ£ŸäŸÜ ÿØÿ±ÿ≥ ÿßŸÑÿ≠ŸäŸàÿßŸÜÿßÿ™'.";
        }
    </script>
        // Menu Toggle Logic - Definitive Fix
        document.addEventListener('DOMContentLoaded', () => {
            const userMenuBtn = document.getElementById('userMenuBtn');
            const mobileMenuBtn = document.getElementById('mobileMenuBtn'); // Using ID as per line 2460
            const menu = document.getElementById('userDropdown');
            const menuOverlay = document.getElementById('menuOverlay');

            function toggleMenu(e) {
                if (e) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                
                // Toggle Show Class
                const isNowShown = menu.classList.toggle('show');
                
                // Handle Overlay
                if (menuOverlay) {
                    if (isNowShown) {
                        menuOverlay.classList.add('active');
                        document.body.style.overflow = 'hidden';
                    } else {
                        menuOverlay.classList.remove('active');
                        document.body.style.overflow = '';
                    }
                }
            }

            function closeMenu() {
                menu.classList.remove('show');
                if (menuOverlay) {
                    menuOverlay.classList.remove('active');
                }
                document.body.style.overflow = '';
            }

            // Bind Events
            if (userMenuBtn) userMenuBtn.addEventListener('click', toggleMenu);
            if (mobileMenuBtn) mobileMenuBtn.addEventListener('click', toggleMenu);

            // Close on outside click
            document.addEventListener('click', (e) => {
                const target = e.target;
                const isClickInsideMenu = menu.contains(target);
                const isClickOnUserBtn = userMenuBtn && userMenuBtn.contains(target);
                const isClickOnMobileBtn = mobileMenuBtn && mobileMenuBtn.contains(target);

                if (!isClickInsideMenu && !isClickOnUserBtn && !isClickOnMobileBtn) {
                    closeMenu();
                }
            });

            // Prevent closing when clicking inside menu
            menu.addEventListener('click', (e) => {
                // Allow links/buttons to work, but don't close unless it's a specific close action
                // For now, let's stop propagation so the document click doesn't catch it
                // e.stopPropagation(); 
                // Actually, we usually WANT links to close the menu.
            });
            
            // Explicit Close Buttons inside menu
            menu.querySelectorAll('a, button.menu-item').forEach(item => {
                item.addEventListener('click', closeMenu);
            });
        });
    </script>
    <div class="dropdown-menu" id="userDropdown">
        <button class="menu-item mobile-only" id="closeMenuBtn" style="display: none; color: var(--text-secondary);">
            <i class="fas fa-arrow-right"></i> ÿ±ÿ¨Ÿàÿπ
        </button>
        
        <button class="menu-item" id="profileBtn">
            <i class="fas fa-sign-in-alt"></i> ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ / ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ¥ÿÆÿµŸä
        </button>
        <a href="{% url 'leaderboard' %}" class="menu-item" style="text-decoration:none;">
            <i class="fas fa-trophy"></i> ŸÑŸàÿ≠ÿ© ÿßŸÑŸÖÿ™ÿµÿØÿ±ŸäŸÜ
        </a>

        <div class="menu-divider"></div>

        <a href="{% url 'top_goal_unit_1' %}" class="menu-item" style="text-decoration:none; color: #7209b7; font-weight: bold;">
            <i class="fas fa-film"></i> ÿßŸÑÿµŸÅ ÿßŸÑÿ≥ÿßÿØÿ≥
        </a>
        <a href="{% url 'grade_2_unit_1' %}" class="menu-item" style="text-decoration:none; color: #ff6b6b; font-weight: bold;">
            <i class="fas fa-paw"></i> ÿ´ÿßŸÜŸä ÿßÿ®ÿ™ÿØÿßÿ¶Ÿä - ÿßŸÑŸàÿ≠ÿØÿ© 1
        </a>
        <a href="{% url 'grade_3_unit_1' %}" class="menu-item" style="text-decoration:none; color: #2196f3; font-weight: bold;">
            <i class="fas fa-book-open"></i> ÿ´ÿßŸÑÿ´ ÿßŸÑŸàÿ≠ÿØŸá ÿßŸÑÿßŸàŸÑŸâ
        </a>
        <a href="{% url 'grade_4_unit_1' %}" class="menu-item" style="text-decoration:none; color: #10b981; font-weight: bold;">
            <i class="fas fa-tree"></i> ÿ±ÿßÿ®ÿπ ÿßŸÑŸàÿ≠ÿØŸá ÿßŸÑÿßŸàŸÑŸâ
        </a>
        
        <div class="menu-divider"></div>
        
        <button class="menu-item" id="viewInstructions">
            <i class="fas fa-info-circle"></i> ÿ™ÿπŸÑŸäŸÖÿßÿ™ ÿßŸÑŸÖŸàŸÇÿπ
        </button>
        <button class="menu-item" id="viewAllLetters">
            <i class="fas fa-th"></i> ÿ¨ŸÖŸäÿπ ÿßŸÑÿ≠ÿ±ŸàŸÅ
        </button>
        <button class="menu-item" id="jumpToLetter">
            <i class="fas fa-share"></i> ÿßŸÜÿ™ŸÇŸÑ ÿ•ŸÑŸâ ÿ≠ÿ±ŸÅ
        </button>
        <button class="menu-item" id="viewCertificate">
            <i class="fas fa-certificate"></i> ÿßŸÑÿ¥ŸáÿßÿØÿ©
        </button>
        <a href="{% url 'cvc_reading' %}" class="menu-item" style="text-decoration:none;">
            <i class="fas fa-book-reader"></i> ŸÇÿ±ÿßÿ°ÿ© CVC
        </a>
        
        <div class="menu-divider"></div>
        
        <button class="menu-item" id="toggleSound">
            <i class="fas fa-volume-up"></i> ŸÉÿ™ŸÖ/ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿµŸàÿ™
        </button>
        <button class="menu-item" id="testMicrophone">
            <i class="fas fa-microphone"></i> ÿßÿÆÿ™ÿ®ÿßÿ± ÿßŸÑŸÖŸäŸÉÿ±ŸàŸÅŸàŸÜ
        </button>

        <div class="menu-divider"></div>
        
        <button class="menu-item" id="resetProgressBtn" style="color: var(--error);">
            <i class="fas fa-power-off"></i> ÿ•ÿπÿßÿØÿ© ÿ∂ÿ®ÿ∑ ÿßŸÑÿ™ŸÇÿØŸÖ
        </button>
    </div>
</body>
</html>